var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name2 in all3)
    __defProp(target, name2, { get: all3[name2], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/@atproto+common@0.3.0/node_modules/@atproto/common/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/@atproto+common@0.3.0/node_modules/@atproto/common/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __commonJS2 = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export2 = (target2, all3) => {
      for (var name3 in all3)
        __defProp2(target2, name3, { get: all3[name3], enumerable: true });
    };
    var __copyProps2 = (to, from32, except, desc) => {
      if (from32 && typeof from32 === "object" || typeof from32 === "function") {
        for (let key of __getOwnPropNames2(from32))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from32[key], enumerable: !(desc = __getOwnPropDesc2(from32, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target2) => (target2 = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target2, "default", { value: mod, enumerable: true }) : target2,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var require_boundaries = __commonJS2({
      "../../node_modules/graphemer/lib/boundaries.js"(exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        exports3.EXTENDED_PICTOGRAPHIC = exports3.CLUSTER_BREAK = void 0;
        var CLUSTER_BREAK;
        (function(CLUSTER_BREAK2) {
          CLUSTER_BREAK2[CLUSTER_BREAK2["CR"] = 0] = "CR";
          CLUSTER_BREAK2[CLUSTER_BREAK2["LF"] = 1] = "LF";
          CLUSTER_BREAK2[CLUSTER_BREAK2["CONTROL"] = 2] = "CONTROL";
          CLUSTER_BREAK2[CLUSTER_BREAK2["EXTEND"] = 3] = "EXTEND";
          CLUSTER_BREAK2[CLUSTER_BREAK2["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
          CLUSTER_BREAK2[CLUSTER_BREAK2["SPACINGMARK"] = 5] = "SPACINGMARK";
          CLUSTER_BREAK2[CLUSTER_BREAK2["L"] = 6] = "L";
          CLUSTER_BREAK2[CLUSTER_BREAK2["V"] = 7] = "V";
          CLUSTER_BREAK2[CLUSTER_BREAK2["T"] = 8] = "T";
          CLUSTER_BREAK2[CLUSTER_BREAK2["LV"] = 9] = "LV";
          CLUSTER_BREAK2[CLUSTER_BREAK2["LVT"] = 10] = "LVT";
          CLUSTER_BREAK2[CLUSTER_BREAK2["OTHER"] = 11] = "OTHER";
          CLUSTER_BREAK2[CLUSTER_BREAK2["PREPEND"] = 12] = "PREPEND";
          CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE"] = 13] = "E_BASE";
          CLUSTER_BREAK2[CLUSTER_BREAK2["E_MODIFIER"] = 14] = "E_MODIFIER";
          CLUSTER_BREAK2[CLUSTER_BREAK2["ZWJ"] = 15] = "ZWJ";
          CLUSTER_BREAK2[CLUSTER_BREAK2["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
          CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
        })(CLUSTER_BREAK = exports3.CLUSTER_BREAK || (exports3.CLUSTER_BREAK = {}));
        exports3.EXTENDED_PICTOGRAPHIC = 101;
      }
    });
    var require_GraphemerHelper = __commonJS2({
      "../../node_modules/graphemer/lib/GraphemerHelper.js"(exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var boundaries_1 = require_boundaries();
        var NotBreak = 0;
        var BreakStart = 1;
        var Break = 2;
        var BreakLastRegional = 3;
        var BreakPenultimateRegional = 4;
        var GraphemerHelper = class {
          static isSurrogate(str, pos) {
            return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
          }
          static codePointAt(str, idx) {
            if (idx === void 0) {
              idx = 0;
            }
            const code4 = str.charCodeAt(idx);
            if (55296 <= code4 && code4 <= 56319 && idx < str.length - 1) {
              const hi = code4;
              const low = str.charCodeAt(idx + 1);
              if (56320 <= low && low <= 57343) {
                return (hi - 55296) * 1024 + (low - 56320) + 65536;
              }
              return hi;
            }
            if (56320 <= code4 && code4 <= 57343 && idx >= 1) {
              const hi = str.charCodeAt(idx - 1);
              const low = code4;
              if (55296 <= hi && hi <= 56319) {
                return (hi - 55296) * 1024 + (low - 56320) + 65536;
              }
              return low;
            }
            return code4;
          }
          static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
            const all3 = [start].concat(mid).concat([end]);
            const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
            const previous = all3[all3.length - 2];
            const next = end;
            const nextEmoji = endEmoji;
            const rIIndex = all3.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
            if (rIIndex > 0 && all3.slice(1, rIIndex).every(function(c) {
              return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
            }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
              if (all3.filter(function(c) {
                return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
              }).length % 2 === 1) {
                return BreakLastRegional;
              } else {
                return BreakPenultimateRegional;
              }
            }
            if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
              return NotBreak;
            } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
              return BreakStart;
            } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
              return BreakStart;
            } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
              return NotBreak;
            } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
              return NotBreak;
            } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
              return NotBreak;
            } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
              return NotBreak;
            } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
              return NotBreak;
            } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
              return NotBreak;
            }
            const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
            if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all3.slice(previousNonExtendIndex + 1, -2).every(function(c) {
              return c === boundaries_1.CLUSTER_BREAK.EXTEND;
            }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
              return NotBreak;
            }
            if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
              return Break;
            }
            if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
              return NotBreak;
            }
            return BreakStart;
          }
        };
        exports3.default = GraphemerHelper;
      }
    });
    var require_GraphemerIterator = __commonJS2({
      "../../node_modules/graphemer/lib/GraphemerIterator.js"(exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", { value: true });
        var GraphemerIterator = class {
          constructor(str, nextBreak) {
            this._index = 0;
            this._str = str;
            this._nextBreak = nextBreak;
          }
          [Symbol.iterator]() {
            return this;
          }
          next() {
            let brk;
            if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
              const value = this._str.slice(this._index, brk);
              this._index = brk;
              return { value, done: false };
            }
            if (this._index < this._str.length) {
              const value = this._str.slice(this._index);
              this._index = this._str.length;
              return { value, done: false };
            }
            return { value: void 0, done: true };
          }
        };
        exports3.default = GraphemerIterator;
      }
    });
    var require_Graphemer = __commonJS2({
      "../../node_modules/graphemer/lib/Graphemer.js"(exports3) {
        "use strict";
        var __importDefault = exports3 && exports3.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var boundaries_1 = require_boundaries();
        var GraphemerHelper_1 = __importDefault(require_GraphemerHelper());
        var GraphemerIterator_1 = __importDefault(require_GraphemerIterator());
        var Graphemer2 = class {
          static nextBreak(string22, index) {
            if (index === void 0) {
              index = 0;
            }
            if (index < 0) {
              return 0;
            }
            if (index >= string22.length - 1) {
              return string22.length;
            }
            const prevCP = GraphemerHelper_1.default.codePointAt(string22, index);
            const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
            const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
            const mid = [];
            const midEmoji = [];
            for (let i = index + 1; i < string22.length; i++) {
              if (GraphemerHelper_1.default.isSurrogate(string22, i - 1)) {
                continue;
              }
              const nextCP = GraphemerHelper_1.default.codePointAt(string22, i);
              const next = Graphemer2.getGraphemeBreakProperty(nextCP);
              const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
              if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
                return i;
              }
              mid.push(next);
              midEmoji.push(nextEmoji);
            }
            return string22.length;
          }
          splitGraphemes(str) {
            const res = [];
            let index = 0;
            let brk;
            while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
              res.push(str.slice(index, brk));
              index = brk;
            }
            if (index < str.length) {
              res.push(str.slice(index));
            }
            return res;
          }
          iterateGraphemes(str) {
            return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
          }
          countGraphemes(str) {
            let count = 0;
            let index = 0;
            let brk;
            while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
              index = brk;
              count++;
            }
            if (index < str.length) {
              count++;
            }
            return count;
          }
          static getGraphemeBreakProperty(code4) {
            if (code4 < 48905) {
              if (code4 < 44116) {
                if (code4 < 4141) {
                  if (code4 < 2818) {
                    if (code4 < 2363) {
                      if (code4 < 1759) {
                        if (code4 < 1471) {
                          if (code4 < 127) {
                            if (code4 < 11) {
                              if (code4 < 10) {
                                if (0 <= code4 && code4 <= 9) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (10 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LF;
                                }
                              }
                            } else {
                              if (code4 < 13) {
                                if (11 <= code4 && code4 <= 12) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code4 < 14) {
                                  if (13 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.CR;
                                  }
                                } else {
                                  if (14 <= code4 && code4 <= 31) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 768) {
                              if (code4 < 173) {
                                if (127 <= code4 && code4 <= 159) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (173 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              }
                            } else {
                              if (code4 < 1155) {
                                if (768 <= code4 && code4 <= 879) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 1425) {
                                  if (1155 <= code4 && code4 <= 1161) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1425 <= code4 && code4 <= 1469) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 1552) {
                            if (code4 < 1476) {
                              if (code4 < 1473) {
                                if (1471 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (1473 <= code4 && code4 <= 1474) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 1479) {
                                if (1476 <= code4 && code4 <= 1477) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 1536) {
                                  if (1479 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1536 <= code4 && code4 <= 1541) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 1648) {
                              if (code4 < 1564) {
                                if (1552 <= code4 && code4 <= 1562) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 1611) {
                                  if (1564 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (1611 <= code4 && code4 <= 1631) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 1750) {
                                if (1648 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 1757) {
                                  if (1750 <= code4 && code4 <= 1756) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (1757 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2075) {
                          if (code4 < 1840) {
                            if (code4 < 1770) {
                              if (code4 < 1767) {
                                if (1759 <= code4 && code4 <= 1764) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (1767 <= code4 && code4 <= 1768) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 1807) {
                                if (1770 <= code4 && code4 <= 1773) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (1807 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                                if (1809 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 2027) {
                              if (code4 < 1958) {
                                if (1840 <= code4 && code4 <= 1866) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (1958 <= code4 && code4 <= 1968) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 2045) {
                                if (2027 <= code4 && code4 <= 2035) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2070) {
                                  if (2045 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2070 <= code4 && code4 <= 2073) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 2200) {
                            if (code4 < 2089) {
                              if (code4 < 2085) {
                                if (2075 <= code4 && code4 <= 2083) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (2085 <= code4 && code4 <= 2087) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 2137) {
                                if (2089 <= code4 && code4 <= 2093) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2192) {
                                  if (2137 <= code4 && code4 <= 2139) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2192 <= code4 && code4 <= 2193) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2275) {
                              if (code4 < 2250) {
                                if (2200 <= code4 && code4 <= 2207) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2274) {
                                  if (2250 <= code4 && code4 <= 2273) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2274 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2307) {
                                if (2275 <= code4 && code4 <= 2306) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (2307 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (2362 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 2561) {
                        if (code4 < 2434) {
                          if (code4 < 2381) {
                            if (code4 < 2366) {
                              if (2363 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (2364 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 2369) {
                                if (2366 <= code4 && code4 <= 2368) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 2377) {
                                  if (2369 <= code4 && code4 <= 2376) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2377 <= code4 && code4 <= 2380) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2385) {
                              if (code4 < 2382) {
                                if (2381 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (2382 <= code4 && code4 <= 2383) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 2402) {
                                if (2385 <= code4 && code4 <= 2391) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2433) {
                                  if (2402 <= code4 && code4 <= 2403) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2433 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 2503) {
                            if (code4 < 2494) {
                              if (code4 < 2492) {
                                if (2434 <= code4 && code4 <= 2435) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (2492 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 2495) {
                                if (2494 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2497) {
                                  if (2495 <= code4 && code4 <= 2496) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2497 <= code4 && code4 <= 2500) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2519) {
                              if (code4 < 2507) {
                                if (2503 <= code4 && code4 <= 2504) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 2509) {
                                  if (2507 <= code4 && code4 <= 2508) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2509 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2530) {
                                if (2519 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2558) {
                                  if (2530 <= code4 && code4 <= 2531) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2558 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 2691) {
                          if (code4 < 2631) {
                            if (code4 < 2620) {
                              if (code4 < 2563) {
                                if (2561 <= code4 && code4 <= 2562) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (2563 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 2622) {
                                if (2620 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2625) {
                                  if (2622 <= code4 && code4 <= 2624) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2625 <= code4 && code4 <= 2626) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2672) {
                              if (code4 < 2635) {
                                if (2631 <= code4 && code4 <= 2632) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2641) {
                                  if (2635 <= code4 && code4 <= 2637) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2641 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2677) {
                                if (2672 <= code4 && code4 <= 2673) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2689) {
                                  if (2677 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2689 <= code4 && code4 <= 2690) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 2761) {
                            if (code4 < 2750) {
                              if (2691 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (2748 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 2753) {
                                if (2750 <= code4 && code4 <= 2752) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 2759) {
                                  if (2753 <= code4 && code4 <= 2757) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2759 <= code4 && code4 <= 2760) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2786) {
                              if (code4 < 2763) {
                                if (2761 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 2765) {
                                  if (2763 <= code4 && code4 <= 2764) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2765 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 2810) {
                                if (2786 <= code4 && code4 <= 2787) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2817) {
                                  if (2810 <= code4 && code4 <= 2815) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2817 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 3315) {
                      if (code4 < 3076) {
                        if (code4 < 2946) {
                          if (code4 < 2887) {
                            if (code4 < 2878) {
                              if (code4 < 2876) {
                                if (2818 <= code4 && code4 <= 2819) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (2876 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 2880) {
                                if (2878 <= code4 && code4 <= 2879) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2881) {
                                  if (2880 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (2881 <= code4 && code4 <= 2884) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 2893) {
                              if (code4 < 2891) {
                                if (2887 <= code4 && code4 <= 2888) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (2891 <= code4 && code4 <= 2892) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 2901) {
                                if (2893 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 2914) {
                                  if (2901 <= code4 && code4 <= 2903) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (2914 <= code4 && code4 <= 2915) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 3014) {
                            if (code4 < 3007) {
                              if (2946 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (3006 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 3008) {
                                if (3007 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 3009) {
                                  if (3008 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3009 <= code4 && code4 <= 3010) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3031) {
                              if (code4 < 3018) {
                                if (3014 <= code4 && code4 <= 3016) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 3021) {
                                  if (3018 <= code4 && code4 <= 3020) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3021 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3072) {
                                if (3031 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3073) {
                                  if (3072 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3073 <= code4 && code4 <= 3075) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3262) {
                          if (code4 < 3146) {
                            if (code4 < 3134) {
                              if (3076 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (3132 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 3137) {
                                if (3134 <= code4 && code4 <= 3136) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3142) {
                                  if (3137 <= code4 && code4 <= 3140) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3142 <= code4 && code4 <= 3144) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3201) {
                              if (code4 < 3157) {
                                if (3146 <= code4 && code4 <= 3149) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3170) {
                                  if (3157 <= code4 && code4 <= 3158) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3170 <= code4 && code4 <= 3171) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3202) {
                                if (3201 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3260) {
                                  if (3202 <= code4 && code4 <= 3203) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3260 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 3270) {
                            if (code4 < 3264) {
                              if (3262 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (3263 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 3266) {
                                if (3264 <= code4 && code4 <= 3265) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 3267) {
                                  if (3266 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3267 <= code4 && code4 <= 3268) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3276) {
                              if (code4 < 3271) {
                                if (3270 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3274) {
                                  if (3271 <= code4 && code4 <= 3272) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3274 <= code4 && code4 <= 3275) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3285) {
                                if (3276 <= code4 && code4 <= 3277) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3298) {
                                  if (3285 <= code4 && code4 <= 3286) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3298 <= code4 && code4 <= 3299) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 3551) {
                        if (code4 < 3406) {
                          if (code4 < 3391) {
                            if (code4 < 3330) {
                              if (code4 < 3328) {
                                if (3315 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (3328 <= code4 && code4 <= 3329) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 3387) {
                                if (3330 <= code4 && code4 <= 3331) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 3390) {
                                  if (3387 <= code4 && code4 <= 3388) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3390 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3398) {
                              if (code4 < 3393) {
                                if (3391 <= code4 && code4 <= 3392) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (3393 <= code4 && code4 <= 3396) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 3402) {
                                if (3398 <= code4 && code4 <= 3400) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 3405) {
                                  if (3402 <= code4 && code4 <= 3404) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3405 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 3530) {
                            if (code4 < 3426) {
                              if (3406 === code4) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                              if (3415 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 3457) {
                                if (3426 <= code4 && code4 <= 3427) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3458) {
                                  if (3457 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3458 <= code4 && code4 <= 3459) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3538) {
                              if (code4 < 3535) {
                                if (3530 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3536) {
                                  if (3535 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3536 <= code4 && code4 <= 3537) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3542) {
                                if (3538 <= code4 && code4 <= 3540) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3544) {
                                  if (3542 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3544 <= code4 && code4 <= 3550) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 3893) {
                          if (code4 < 3655) {
                            if (code4 < 3633) {
                              if (code4 < 3570) {
                                if (3551 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (3570 <= code4 && code4 <= 3571) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 3635) {
                                if (3633 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3636) {
                                  if (3635 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3636 <= code4 && code4 <= 3642) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3764) {
                              if (code4 < 3761) {
                                if (3655 <= code4 && code4 <= 3662) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (3761 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (3763 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 3784) {
                                if (3764 <= code4 && code4 <= 3772) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3864) {
                                  if (3784 <= code4 && code4 <= 3790) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3864 <= code4 && code4 <= 3865) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 3967) {
                            if (code4 < 3897) {
                              if (3893 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (3895 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 3902) {
                                if (3897 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 3953) {
                                  if (3902 <= code4 && code4 <= 3903) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (3953 <= code4 && code4 <= 3966) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 3981) {
                              if (code4 < 3968) {
                                if (3967 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 3974) {
                                  if (3968 <= code4 && code4 <= 3972) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (3974 <= code4 && code4 <= 3975) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 3993) {
                                if (3981 <= code4 && code4 <= 3991) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 4038) {
                                  if (3993 <= code4 && code4 <= 4028) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4038 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 7204) {
                    if (code4 < 6448) {
                      if (code4 < 5938) {
                        if (code4 < 4226) {
                          if (code4 < 4157) {
                            if (code4 < 4146) {
                              if (code4 < 4145) {
                                if (4141 <= code4 && code4 <= 4144) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (4145 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 4153) {
                                if (4146 <= code4 && code4 <= 4151) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 4155) {
                                  if (4153 <= code4 && code4 <= 4154) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4155 <= code4 && code4 <= 4156) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 4184) {
                              if (code4 < 4182) {
                                if (4157 <= code4 && code4 <= 4158) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (4182 <= code4 && code4 <= 4183) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 4190) {
                                if (4184 <= code4 && code4 <= 4185) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 4209) {
                                  if (4190 <= code4 && code4 <= 4192) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (4209 <= code4 && code4 <= 4212) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 4352) {
                            if (code4 < 4229) {
                              if (4226 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (4228 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 < 4237) {
                                if (4229 <= code4 && code4 <= 4230) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (4237 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (4253 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 4957) {
                              if (code4 < 4448) {
                                if (4352 <= code4 && code4 <= 4447) {
                                  return boundaries_1.CLUSTER_BREAK.L;
                                }
                              } else {
                                if (code4 < 4520) {
                                  if (4448 <= code4 && code4 <= 4519) {
                                    return boundaries_1.CLUSTER_BREAK.V;
                                  }
                                } else {
                                  if (4520 <= code4 && code4 <= 4607) {
                                    return boundaries_1.CLUSTER_BREAK.T;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 5906) {
                                if (4957 <= code4 && code4 <= 4959) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 5909) {
                                  if (5906 <= code4 && code4 <= 5908) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (5909 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 6089) {
                          if (code4 < 6070) {
                            if (code4 < 5970) {
                              if (code4 < 5940) {
                                if (5938 <= code4 && code4 <= 5939) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (5940 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 6002) {
                                if (5970 <= code4 && code4 <= 5971) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 6068) {
                                  if (6002 <= code4 && code4 <= 6003) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6068 <= code4 && code4 <= 6069) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 6078) {
                              if (code4 < 6071) {
                                if (6070 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (6071 <= code4 && code4 <= 6077) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 6086) {
                                if (6078 <= code4 && code4 <= 6085) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 6087) {
                                  if (6086 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6087 <= code4 && code4 <= 6088) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 6277) {
                            if (code4 < 6155) {
                              if (code4 < 6109) {
                                if (6089 <= code4 && code4 <= 6099) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (6109 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 6158) {
                                if (6155 <= code4 && code4 <= 6157) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (6158 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                                if (6159 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 6435) {
                              if (code4 < 6313) {
                                if (6277 <= code4 && code4 <= 6278) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 6432) {
                                  if (6313 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6432 <= code4 && code4 <= 6434) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 6439) {
                                if (6435 <= code4 && code4 <= 6438) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 6441) {
                                  if (6439 <= code4 && code4 <= 6440) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6441 <= code4 && code4 <= 6443) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 6971) {
                        if (code4 < 6744) {
                          if (code4 < 6681) {
                            if (code4 < 6451) {
                              if (code4 < 6450) {
                                if (6448 <= code4 && code4 <= 6449) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (6450 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 6457) {
                                if (6451 <= code4 && code4 <= 6456) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 6679) {
                                  if (6457 <= code4 && code4 <= 6459) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6679 <= code4 && code4 <= 6680) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 6741) {
                              if (code4 < 6683) {
                                if (6681 <= code4 && code4 <= 6682) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (6683 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 6742) {
                                if (6741 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (6742 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (6743 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 6771) {
                            if (code4 < 6754) {
                              if (code4 < 6752) {
                                if (6744 <= code4 && code4 <= 6750) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (6752 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 6757) {
                                if (6754 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 6765) {
                                  if (6757 <= code4 && code4 <= 6764) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6765 <= code4 && code4 <= 6770) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 6912) {
                              if (code4 < 6783) {
                                if (6771 <= code4 && code4 <= 6780) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 6832) {
                                  if (6783 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6832 <= code4 && code4 <= 6862) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 6916) {
                                if (6912 <= code4 && code4 <= 6915) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 6964) {
                                  if (6916 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (6964 <= code4 && code4 <= 6970) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 7080) {
                          if (code4 < 7019) {
                            if (code4 < 6973) {
                              if (6971 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (6972 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 6978) {
                                if (6973 <= code4 && code4 <= 6977) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 6979) {
                                  if (6978 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (6979 <= code4 && code4 <= 6980) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 7073) {
                              if (code4 < 7040) {
                                if (7019 <= code4 && code4 <= 7027) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 7042) {
                                  if (7040 <= code4 && code4 <= 7041) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (7042 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 7074) {
                                if (7073 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 7078) {
                                  if (7074 <= code4 && code4 <= 7077) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (7078 <= code4 && code4 <= 7079) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 7144) {
                            if (code4 < 7083) {
                              if (code4 < 7082) {
                                if (7080 <= code4 && code4 <= 7081) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (7082 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 7142) {
                                if (7083 <= code4 && code4 <= 7085) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (7142 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (7143 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          } else {
                            if (code4 < 7150) {
                              if (code4 < 7146) {
                                if (7144 <= code4 && code4 <= 7145) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 7149) {
                                  if (7146 <= code4 && code4 <= 7148) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (7149 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 7151) {
                                if (7150 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 7154) {
                                  if (7151 <= code4 && code4 <= 7153) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (7154 <= code4 && code4 <= 7155) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 43346) {
                      if (code4 < 11647) {
                        if (code4 < 7415) {
                          if (code4 < 7380) {
                            if (code4 < 7220) {
                              if (code4 < 7212) {
                                if (7204 <= code4 && code4 <= 7211) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (7212 <= code4 && code4 <= 7219) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 7222) {
                                if (7220 <= code4 && code4 <= 7221) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 7376) {
                                  if (7222 <= code4 && code4 <= 7223) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (7376 <= code4 && code4 <= 7378) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 7394) {
                              if (code4 < 7393) {
                                if (7380 <= code4 && code4 <= 7392) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (7393 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 7405) {
                                if (7394 <= code4 && code4 <= 7400) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (7405 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (7412 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 8205) {
                            if (code4 < 7616) {
                              if (code4 < 7416) {
                                if (7415 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (7416 <= code4 && code4 <= 7417) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 8203) {
                                if (7616 <= code4 && code4 <= 7679) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (8203 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                                if (8204 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 8288) {
                              if (code4 < 8206) {
                                if (8205 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.ZWJ;
                                }
                              } else {
                                if (code4 < 8232) {
                                  if (8206 <= code4 && code4 <= 8207) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (8232 <= code4 && code4 <= 8238) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 8400) {
                                if (8288 <= code4 && code4 <= 8303) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code4 < 11503) {
                                  if (8400 <= code4 && code4 <= 8432) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (11503 <= code4 && code4 <= 11505) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 43043) {
                          if (code4 < 42612) {
                            if (code4 < 12330) {
                              if (code4 < 11744) {
                                if (11647 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (11744 <= code4 && code4 <= 11775) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 12441) {
                                if (12330 <= code4 && code4 <= 12335) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 42607) {
                                  if (12441 <= code4 && code4 <= 12442) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (42607 <= code4 && code4 <= 42610) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 43010) {
                              if (code4 < 42654) {
                                if (42612 <= code4 && code4 <= 42621) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 42736) {
                                  if (42654 <= code4 && code4 <= 42655) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (42736 <= code4 && code4 <= 42737) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 43014) {
                                if (43010 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (43014 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (43019 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 43188) {
                            if (code4 < 43047) {
                              if (code4 < 43045) {
                                if (43043 <= code4 && code4 <= 43044) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (43045 <= code4 && code4 <= 43046) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 43052) {
                                if (43047 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 43136) {
                                  if (43052 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43136 <= code4 && code4 <= 43137) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 43263) {
                              if (code4 < 43204) {
                                if (43188 <= code4 && code4 <= 43203) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 43232) {
                                  if (43204 <= code4 && code4 <= 43205) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43232 <= code4 && code4 <= 43249) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 43302) {
                                if (43263 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 43335) {
                                  if (43302 <= code4 && code4 <= 43309) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43335 <= code4 && code4 <= 43345) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 43698) {
                        if (code4 < 43493) {
                          if (code4 < 43444) {
                            if (code4 < 43392) {
                              if (code4 < 43360) {
                                if (43346 <= code4 && code4 <= 43347) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (43360 <= code4 && code4 <= 43388) {
                                  return boundaries_1.CLUSTER_BREAK.L;
                                }
                              }
                            } else {
                              if (code4 < 43395) {
                                if (43392 <= code4 && code4 <= 43394) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (43395 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (43443 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 43450) {
                              if (code4 < 43446) {
                                if (43444 <= code4 && code4 <= 43445) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (43446 <= code4 && code4 <= 43449) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 43452) {
                                if (43450 <= code4 && code4 <= 43451) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 43454) {
                                  if (43452 <= code4 && code4 <= 43453) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43454 <= code4 && code4 <= 43456) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 43573) {
                            if (code4 < 43567) {
                              if (code4 < 43561) {
                                if (43493 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (43561 <= code4 && code4 <= 43566) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 43569) {
                                if (43567 <= code4 && code4 <= 43568) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 43571) {
                                  if (43569 <= code4 && code4 <= 43570) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (43571 <= code4 && code4 <= 43572) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 43597) {
                              if (code4 < 43587) {
                                if (43573 <= code4 && code4 <= 43574) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (43587 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (43596 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 43644) {
                                if (43597 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (43644 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (43696 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44006) {
                          if (code4 < 43756) {
                            if (code4 < 43710) {
                              if (code4 < 43703) {
                                if (43698 <= code4 && code4 <= 43700) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (43703 <= code4 && code4 <= 43704) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 43713) {
                                if (43710 <= code4 && code4 <= 43711) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (43713 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (43755 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          } else {
                            if (code4 < 43766) {
                              if (code4 < 43758) {
                                if (43756 <= code4 && code4 <= 43757) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 43765) {
                                  if (43758 <= code4 && code4 <= 43759) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (43765 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44003) {
                                if (43766 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 44005) {
                                  if (44003 <= code4 && code4 <= 44004) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (44005 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 44032) {
                            if (code4 < 44009) {
                              if (code4 < 44008) {
                                if (44006 <= code4 && code4 <= 44007) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (44008 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 44012) {
                                if (44009 <= code4 && code4 <= 44010) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (44012 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (44013 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 44061) {
                              if (code4 < 44033) {
                                if (44032 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44060) {
                                  if (44033 <= code4 && code4 <= 44059) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44060 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44088) {
                                if (44061 <= code4 && code4 <= 44087) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 44089) {
                                  if (44088 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44089 <= code4 && code4 <= 44115) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 46497) {
                  if (code4 < 45293) {
                    if (code4 < 44704) {
                      if (code4 < 44397) {
                        if (code4 < 44256) {
                          if (code4 < 44173) {
                            if (code4 < 44144) {
                              if (code4 < 44117) {
                                if (44116 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44117 <= code4 && code4 <= 44143) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 44145) {
                                if (44144 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44172) {
                                  if (44145 <= code4 && code4 <= 44171) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44172 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44201) {
                              if (code4 < 44200) {
                                if (44173 <= code4 && code4 <= 44199) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (44200 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 44228) {
                                if (44201 <= code4 && code4 <= 44227) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 44229) {
                                  if (44228 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44229 <= code4 && code4 <= 44255) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 44313) {
                            if (code4 < 44284) {
                              if (code4 < 44257) {
                                if (44256 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44257 <= code4 && code4 <= 44283) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 44285) {
                                if (44284 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44312) {
                                  if (44285 <= code4 && code4 <= 44311) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44312 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44368) {
                              if (code4 < 44340) {
                                if (44313 <= code4 && code4 <= 44339) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 44341) {
                                  if (44340 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44341 <= code4 && code4 <= 44367) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44369) {
                                if (44368 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44396) {
                                  if (44369 <= code4 && code4 <= 44395) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44396 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 44537) {
                          if (code4 < 44480) {
                            if (code4 < 44425) {
                              if (code4 < 44424) {
                                if (44397 <= code4 && code4 <= 44423) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (44424 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 44452) {
                                if (44425 <= code4 && code4 <= 44451) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 44453) {
                                  if (44452 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44453 <= code4 && code4 <= 44479) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44508) {
                              if (code4 < 44481) {
                                if (44480 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44481 <= code4 && code4 <= 44507) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 44509) {
                                if (44508 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44536) {
                                  if (44509 <= code4 && code4 <= 44535) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44536 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 44620) {
                            if (code4 < 44565) {
                              if (code4 < 44564) {
                                if (44537 <= code4 && code4 <= 44563) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (44564 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 44592) {
                                if (44565 <= code4 && code4 <= 44591) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 44593) {
                                  if (44592 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44593 <= code4 && code4 <= 44619) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44649) {
                              if (code4 < 44621) {
                                if (44620 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44648) {
                                  if (44621 <= code4 && code4 <= 44647) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44648 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44676) {
                                if (44649 <= code4 && code4 <= 44675) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 44677) {
                                  if (44676 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44677 <= code4 && code4 <= 44703) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 44985) {
                        if (code4 < 44844) {
                          if (code4 < 44761) {
                            if (code4 < 44732) {
                              if (code4 < 44705) {
                                if (44704 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44705 <= code4 && code4 <= 44731) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 44733) {
                                if (44732 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44760) {
                                  if (44733 <= code4 && code4 <= 44759) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44760 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44789) {
                              if (code4 < 44788) {
                                if (44761 <= code4 && code4 <= 44787) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (44788 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 44816) {
                                if (44789 <= code4 && code4 <= 44815) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 44817) {
                                  if (44816 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44817 <= code4 && code4 <= 44843) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 44901) {
                            if (code4 < 44872) {
                              if (code4 < 44845) {
                                if (44844 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (44845 <= code4 && code4 <= 44871) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 44873) {
                                if (44872 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44900) {
                                  if (44873 <= code4 && code4 <= 44899) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44900 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 44956) {
                              if (code4 < 44928) {
                                if (44901 <= code4 && code4 <= 44927) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 44929) {
                                  if (44928 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (44929 <= code4 && code4 <= 44955) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 44957) {
                                if (44956 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 44984) {
                                  if (44957 <= code4 && code4 <= 44983) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (44984 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45152) {
                          if (code4 < 45068) {
                            if (code4 < 45013) {
                              if (code4 < 45012) {
                                if (44985 <= code4 && code4 <= 45011) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (45012 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 45040) {
                                if (45013 <= code4 && code4 <= 45039) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45041) {
                                  if (45040 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45041 <= code4 && code4 <= 45067) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45097) {
                              if (code4 < 45069) {
                                if (45068 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45096) {
                                  if (45069 <= code4 && code4 <= 45095) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45096 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45124) {
                                if (45097 <= code4 && code4 <= 45123) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45125) {
                                  if (45124 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45125 <= code4 && code4 <= 45151) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 45209) {
                            if (code4 < 45180) {
                              if (code4 < 45153) {
                                if (45152 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (45153 <= code4 && code4 <= 45179) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 45181) {
                                if (45180 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45208) {
                                  if (45181 <= code4 && code4 <= 45207) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45208 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45264) {
                              if (code4 < 45236) {
                                if (45209 <= code4 && code4 <= 45235) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45237) {
                                  if (45236 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45237 <= code4 && code4 <= 45263) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45265) {
                                if (45264 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45292) {
                                  if (45265 <= code4 && code4 <= 45291) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45292 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 45908) {
                      if (code4 < 45600) {
                        if (code4 < 45433) {
                          if (code4 < 45376) {
                            if (code4 < 45321) {
                              if (code4 < 45320) {
                                if (45293 <= code4 && code4 <= 45319) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (45320 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 45348) {
                                if (45321 <= code4 && code4 <= 45347) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45349) {
                                  if (45348 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45349 <= code4 && code4 <= 45375) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45404) {
                              if (code4 < 45377) {
                                if (45376 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (45377 <= code4 && code4 <= 45403) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 45405) {
                                if (45404 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45432) {
                                  if (45405 <= code4 && code4 <= 45431) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45432 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 45516) {
                            if (code4 < 45461) {
                              if (code4 < 45460) {
                                if (45433 <= code4 && code4 <= 45459) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (45460 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 45488) {
                                if (45461 <= code4 && code4 <= 45487) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45489) {
                                  if (45488 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45489 <= code4 && code4 <= 45515) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45545) {
                              if (code4 < 45517) {
                                if (45516 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45544) {
                                  if (45517 <= code4 && code4 <= 45543) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45544 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45572) {
                                if (45545 <= code4 && code4 <= 45571) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45573) {
                                  if (45572 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45573 <= code4 && code4 <= 45599) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 45741) {
                          if (code4 < 45657) {
                            if (code4 < 45628) {
                              if (code4 < 45601) {
                                if (45600 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (45601 <= code4 && code4 <= 45627) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 45629) {
                                if (45628 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45656) {
                                  if (45629 <= code4 && code4 <= 45655) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45656 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45712) {
                              if (code4 < 45684) {
                                if (45657 <= code4 && code4 <= 45683) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45685) {
                                  if (45684 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45685 <= code4 && code4 <= 45711) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45713) {
                                if (45712 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45740) {
                                  if (45713 <= code4 && code4 <= 45739) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45740 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 45824) {
                            if (code4 < 45769) {
                              if (code4 < 45768) {
                                if (45741 <= code4 && code4 <= 45767) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (45768 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 45796) {
                                if (45769 <= code4 && code4 <= 45795) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45797) {
                                  if (45796 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45797 <= code4 && code4 <= 45823) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45853) {
                              if (code4 < 45825) {
                                if (45824 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45852) {
                                  if (45825 <= code4 && code4 <= 45851) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45852 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 45880) {
                                if (45853 <= code4 && code4 <= 45879) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 45881) {
                                  if (45880 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (45881 <= code4 && code4 <= 45907) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 46189) {
                        if (code4 < 46048) {
                          if (code4 < 45965) {
                            if (code4 < 45936) {
                              if (code4 < 45909) {
                                if (45908 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (45909 <= code4 && code4 <= 45935) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 45937) {
                                if (45936 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 45964) {
                                  if (45937 <= code4 && code4 <= 45963) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (45964 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 45993) {
                              if (code4 < 45992) {
                                if (45965 <= code4 && code4 <= 45991) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (45992 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 46020) {
                                if (45993 <= code4 && code4 <= 46019) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46021) {
                                  if (46020 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46021 <= code4 && code4 <= 46047) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 46105) {
                            if (code4 < 46076) {
                              if (code4 < 46049) {
                                if (46048 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (46049 <= code4 && code4 <= 46075) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 46077) {
                                if (46076 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46104) {
                                  if (46077 <= code4 && code4 <= 46103) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46104 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46160) {
                              if (code4 < 46132) {
                                if (46105 <= code4 && code4 <= 46131) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46133) {
                                  if (46132 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46133 <= code4 && code4 <= 46159) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46161) {
                                if (46160 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46188) {
                                  if (46161 <= code4 && code4 <= 46187) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46188 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46356) {
                          if (code4 < 46272) {
                            if (code4 < 46217) {
                              if (code4 < 46216) {
                                if (46189 <= code4 && code4 <= 46215) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (46216 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 46244) {
                                if (46217 <= code4 && code4 <= 46243) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46245) {
                                  if (46244 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46245 <= code4 && code4 <= 46271) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46301) {
                              if (code4 < 46273) {
                                if (46272 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46300) {
                                  if (46273 <= code4 && code4 <= 46299) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46300 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46328) {
                                if (46301 <= code4 && code4 <= 46327) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46329) {
                                  if (46328 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46329 <= code4 && code4 <= 46355) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 46413) {
                            if (code4 < 46384) {
                              if (code4 < 46357) {
                                if (46356 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (46357 <= code4 && code4 <= 46383) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 46385) {
                                if (46384 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46412) {
                                  if (46385 <= code4 && code4 <= 46411) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46412 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46468) {
                              if (code4 < 46440) {
                                if (46413 <= code4 && code4 <= 46439) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46441) {
                                  if (46440 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46441 <= code4 && code4 <= 46467) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46469) {
                                if (46468 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46496) {
                                  if (46469 <= code4 && code4 <= 46495) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46496 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 47701) {
                    if (code4 < 47112) {
                      if (code4 < 46804) {
                        if (code4 < 46637) {
                          if (code4 < 46580) {
                            if (code4 < 46525) {
                              if (code4 < 46524) {
                                if (46497 <= code4 && code4 <= 46523) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (46524 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 46552) {
                                if (46525 <= code4 && code4 <= 46551) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46553) {
                                  if (46552 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46553 <= code4 && code4 <= 46579) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46608) {
                              if (code4 < 46581) {
                                if (46580 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (46581 <= code4 && code4 <= 46607) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 46609) {
                                if (46608 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46636) {
                                  if (46609 <= code4 && code4 <= 46635) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46636 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 46720) {
                            if (code4 < 46665) {
                              if (code4 < 46664) {
                                if (46637 <= code4 && code4 <= 46663) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (46664 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 46692) {
                                if (46665 <= code4 && code4 <= 46691) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46693) {
                                  if (46692 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46693 <= code4 && code4 <= 46719) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46749) {
                              if (code4 < 46721) {
                                if (46720 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46748) {
                                  if (46721 <= code4 && code4 <= 46747) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46748 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46776) {
                                if (46749 <= code4 && code4 <= 46775) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46777) {
                                  if (46776 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46777 <= code4 && code4 <= 46803) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 46945) {
                          if (code4 < 46861) {
                            if (code4 < 46832) {
                              if (code4 < 46805) {
                                if (46804 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (46805 <= code4 && code4 <= 46831) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 46833) {
                                if (46832 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46860) {
                                  if (46833 <= code4 && code4 <= 46859) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46860 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 46916) {
                              if (code4 < 46888) {
                                if (46861 <= code4 && code4 <= 46887) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 46889) {
                                  if (46888 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (46889 <= code4 && code4 <= 46915) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 46917) {
                                if (46916 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 46944) {
                                  if (46917 <= code4 && code4 <= 46943) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (46944 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 47028) {
                            if (code4 < 46973) {
                              if (code4 < 46972) {
                                if (46945 <= code4 && code4 <= 46971) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (46972 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 47e3) {
                                if (46973 <= code4 && code4 <= 46999) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47001) {
                                  if (47e3 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47001 <= code4 && code4 <= 47027) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47057) {
                              if (code4 < 47029) {
                                if (47028 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47056) {
                                  if (47029 <= code4 && code4 <= 47055) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47056 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47084) {
                                if (47057 <= code4 && code4 <= 47083) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47085) {
                                  if (47084 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47085 <= code4 && code4 <= 47111) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 47393) {
                        if (code4 < 47252) {
                          if (code4 < 47169) {
                            if (code4 < 47140) {
                              if (code4 < 47113) {
                                if (47112 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (47113 <= code4 && code4 <= 47139) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 47141) {
                                if (47140 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47168) {
                                  if (47141 <= code4 && code4 <= 47167) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47168 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47197) {
                              if (code4 < 47196) {
                                if (47169 <= code4 && code4 <= 47195) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (47196 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 47224) {
                                if (47197 <= code4 && code4 <= 47223) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47225) {
                                  if (47224 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47225 <= code4 && code4 <= 47251) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 47309) {
                            if (code4 < 47280) {
                              if (code4 < 47253) {
                                if (47252 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (47253 <= code4 && code4 <= 47279) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 47281) {
                                if (47280 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47308) {
                                  if (47281 <= code4 && code4 <= 47307) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47308 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47364) {
                              if (code4 < 47336) {
                                if (47309 <= code4 && code4 <= 47335) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47337) {
                                  if (47336 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47337 <= code4 && code4 <= 47363) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47365) {
                                if (47364 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47392) {
                                  if (47365 <= code4 && code4 <= 47391) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47392 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 47560) {
                          if (code4 < 47476) {
                            if (code4 < 47421) {
                              if (code4 < 47420) {
                                if (47393 <= code4 && code4 <= 47419) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (47420 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 47448) {
                                if (47421 <= code4 && code4 <= 47447) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47449) {
                                  if (47448 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47449 <= code4 && code4 <= 47475) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47505) {
                              if (code4 < 47477) {
                                if (47476 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47504) {
                                  if (47477 <= code4 && code4 <= 47503) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47504 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47532) {
                                if (47505 <= code4 && code4 <= 47531) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47533) {
                                  if (47532 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47533 <= code4 && code4 <= 47559) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 47617) {
                            if (code4 < 47588) {
                              if (code4 < 47561) {
                                if (47560 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (47561 <= code4 && code4 <= 47587) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 47589) {
                                if (47588 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47616) {
                                  if (47589 <= code4 && code4 <= 47615) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47616 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47672) {
                              if (code4 < 47644) {
                                if (47617 <= code4 && code4 <= 47643) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47645) {
                                  if (47644 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47645 <= code4 && code4 <= 47671) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47673) {
                                if (47672 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47700) {
                                  if (47673 <= code4 && code4 <= 47699) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47700 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 48316) {
                      if (code4 < 48008) {
                        if (code4 < 47841) {
                          if (code4 < 47784) {
                            if (code4 < 47729) {
                              if (code4 < 47728) {
                                if (47701 <= code4 && code4 <= 47727) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (47728 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 47756) {
                                if (47729 <= code4 && code4 <= 47755) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47757) {
                                  if (47756 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47757 <= code4 && code4 <= 47783) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47812) {
                              if (code4 < 47785) {
                                if (47784 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (47785 <= code4 && code4 <= 47811) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 47813) {
                                if (47812 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47840) {
                                  if (47813 <= code4 && code4 <= 47839) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47840 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 47924) {
                            if (code4 < 47869) {
                              if (code4 < 47868) {
                                if (47841 <= code4 && code4 <= 47867) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (47868 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 47896) {
                                if (47869 <= code4 && code4 <= 47895) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47897) {
                                  if (47896 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47897 <= code4 && code4 <= 47923) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 47953) {
                              if (code4 < 47925) {
                                if (47924 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 47952) {
                                  if (47925 <= code4 && code4 <= 47951) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (47952 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 47980) {
                                if (47953 <= code4 && code4 <= 47979) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 47981) {
                                  if (47980 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (47981 <= code4 && code4 <= 48007) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48149) {
                          if (code4 < 48065) {
                            if (code4 < 48036) {
                              if (code4 < 48009) {
                                if (48008 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48009 <= code4 && code4 <= 48035) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 48037) {
                                if (48036 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48064) {
                                  if (48037 <= code4 && code4 <= 48063) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48064 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48120) {
                              if (code4 < 48092) {
                                if (48065 <= code4 && code4 <= 48091) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48093) {
                                  if (48092 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48093 <= code4 && code4 <= 48119) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48121) {
                                if (48120 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48148) {
                                  if (48121 <= code4 && code4 <= 48147) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48148 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 48232) {
                            if (code4 < 48177) {
                              if (code4 < 48176) {
                                if (48149 <= code4 && code4 <= 48175) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (48176 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 48204) {
                                if (48177 <= code4 && code4 <= 48203) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48205) {
                                  if (48204 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48205 <= code4 && code4 <= 48231) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48261) {
                              if (code4 < 48233) {
                                if (48232 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48260) {
                                  if (48233 <= code4 && code4 <= 48259) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48260 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48288) {
                                if (48261 <= code4 && code4 <= 48287) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48289) {
                                  if (48288 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48289 <= code4 && code4 <= 48315) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 48597) {
                        if (code4 < 48456) {
                          if (code4 < 48373) {
                            if (code4 < 48344) {
                              if (code4 < 48317) {
                                if (48316 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48317 <= code4 && code4 <= 48343) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 48345) {
                                if (48344 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48372) {
                                  if (48345 <= code4 && code4 <= 48371) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48372 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48401) {
                              if (code4 < 48400) {
                                if (48373 <= code4 && code4 <= 48399) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (48400 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 48428) {
                                if (48401 <= code4 && code4 <= 48427) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48429) {
                                  if (48428 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48429 <= code4 && code4 <= 48455) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 48513) {
                            if (code4 < 48484) {
                              if (code4 < 48457) {
                                if (48456 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48457 <= code4 && code4 <= 48483) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 48485) {
                                if (48484 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48512) {
                                  if (48485 <= code4 && code4 <= 48511) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48512 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48568) {
                              if (code4 < 48540) {
                                if (48513 <= code4 && code4 <= 48539) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48541) {
                                  if (48540 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48541 <= code4 && code4 <= 48567) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48569) {
                                if (48568 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48596) {
                                  if (48569 <= code4 && code4 <= 48595) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48596 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 48764) {
                          if (code4 < 48680) {
                            if (code4 < 48625) {
                              if (code4 < 48624) {
                                if (48597 <= code4 && code4 <= 48623) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (48624 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 48652) {
                                if (48625 <= code4 && code4 <= 48651) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48653) {
                                  if (48652 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48653 <= code4 && code4 <= 48679) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48709) {
                              if (code4 < 48681) {
                                if (48680 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48708) {
                                  if (48681 <= code4 && code4 <= 48707) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48708 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48736) {
                                if (48709 <= code4 && code4 <= 48735) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48737) {
                                  if (48736 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48737 <= code4 && code4 <= 48763) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 48821) {
                            if (code4 < 48792) {
                              if (code4 < 48765) {
                                if (48764 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48765 <= code4 && code4 <= 48791) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 48793) {
                                if (48792 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48820) {
                                  if (48793 <= code4 && code4 <= 48819) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48820 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 48876) {
                              if (code4 < 48848) {
                                if (48821 <= code4 && code4 <= 48847) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48849) {
                                  if (48848 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48849 <= code4 && code4 <= 48875) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 48877) {
                                if (48876 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 48904) {
                                  if (48877 <= code4 && code4 <= 48903) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (48904 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code4 < 53720) {
                if (code4 < 51312) {
                  if (code4 < 50108) {
                    if (code4 < 49493) {
                      if (code4 < 49212) {
                        if (code4 < 49045) {
                          if (code4 < 48988) {
                            if (code4 < 48933) {
                              if (code4 < 48932) {
                                if (48905 <= code4 && code4 <= 48931) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (48932 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 48960) {
                                if (48933 <= code4 && code4 <= 48959) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 48961) {
                                  if (48960 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (48961 <= code4 && code4 <= 48987) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49016) {
                              if (code4 < 48989) {
                                if (48988 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (48989 <= code4 && code4 <= 49015) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 49017) {
                                if (49016 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49044) {
                                  if (49017 <= code4 && code4 <= 49043) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49044 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 49128) {
                            if (code4 < 49073) {
                              if (code4 < 49072) {
                                if (49045 <= code4 && code4 <= 49071) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (49072 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 49100) {
                                if (49073 <= code4 && code4 <= 49099) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49101) {
                                  if (49100 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49101 <= code4 && code4 <= 49127) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49157) {
                              if (code4 < 49129) {
                                if (49128 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49156) {
                                  if (49129 <= code4 && code4 <= 49155) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49156 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49184) {
                                if (49157 <= code4 && code4 <= 49183) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49185) {
                                  if (49184 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49185 <= code4 && code4 <= 49211) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49352) {
                          if (code4 < 49269) {
                            if (code4 < 49240) {
                              if (code4 < 49213) {
                                if (49212 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (49213 <= code4 && code4 <= 49239) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 49241) {
                                if (49240 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49268) {
                                  if (49241 <= code4 && code4 <= 49267) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49268 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49297) {
                              if (code4 < 49296) {
                                if (49269 <= code4 && code4 <= 49295) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (49296 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 49324) {
                                if (49297 <= code4 && code4 <= 49323) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49325) {
                                  if (49324 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49325 <= code4 && code4 <= 49351) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 49409) {
                            if (code4 < 49380) {
                              if (code4 < 49353) {
                                if (49352 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (49353 <= code4 && code4 <= 49379) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 49381) {
                                if (49380 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49408) {
                                  if (49381 <= code4 && code4 <= 49407) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49408 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49464) {
                              if (code4 < 49436) {
                                if (49409 <= code4 && code4 <= 49435) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49437) {
                                  if (49436 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49437 <= code4 && code4 <= 49463) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49465) {
                                if (49464 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49492) {
                                  if (49465 <= code4 && code4 <= 49491) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49492 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 49800) {
                        if (code4 < 49633) {
                          if (code4 < 49576) {
                            if (code4 < 49521) {
                              if (code4 < 49520) {
                                if (49493 <= code4 && code4 <= 49519) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (49520 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 49548) {
                                if (49521 <= code4 && code4 <= 49547) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49549) {
                                  if (49548 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49549 <= code4 && code4 <= 49575) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49604) {
                              if (code4 < 49577) {
                                if (49576 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (49577 <= code4 && code4 <= 49603) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 49605) {
                                if (49604 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49632) {
                                  if (49605 <= code4 && code4 <= 49631) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49632 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 49716) {
                            if (code4 < 49661) {
                              if (code4 < 49660) {
                                if (49633 <= code4 && code4 <= 49659) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (49660 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 49688) {
                                if (49661 <= code4 && code4 <= 49687) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49689) {
                                  if (49688 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49689 <= code4 && code4 <= 49715) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49745) {
                              if (code4 < 49717) {
                                if (49716 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49744) {
                                  if (49717 <= code4 && code4 <= 49743) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49744 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49772) {
                                if (49745 <= code4 && code4 <= 49771) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49773) {
                                  if (49772 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49773 <= code4 && code4 <= 49799) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 49941) {
                          if (code4 < 49857) {
                            if (code4 < 49828) {
                              if (code4 < 49801) {
                                if (49800 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (49801 <= code4 && code4 <= 49827) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 49829) {
                                if (49828 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49856) {
                                  if (49829 <= code4 && code4 <= 49855) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49856 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 49912) {
                              if (code4 < 49884) {
                                if (49857 <= code4 && code4 <= 49883) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49885) {
                                  if (49884 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49885 <= code4 && code4 <= 49911) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 49913) {
                                if (49912 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 49940) {
                                  if (49913 <= code4 && code4 <= 49939) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (49940 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 50024) {
                            if (code4 < 49969) {
                              if (code4 < 49968) {
                                if (49941 <= code4 && code4 <= 49967) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (49968 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 49996) {
                                if (49969 <= code4 && code4 <= 49995) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 49997) {
                                  if (49996 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (49997 <= code4 && code4 <= 50023) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50053) {
                              if (code4 < 50025) {
                                if (50024 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50052) {
                                  if (50025 <= code4 && code4 <= 50051) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50052 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50080) {
                                if (50053 <= code4 && code4 <= 50079) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50081) {
                                  if (50080 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50081 <= code4 && code4 <= 50107) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 50697) {
                      if (code4 < 50389) {
                        if (code4 < 50248) {
                          if (code4 < 50165) {
                            if (code4 < 50136) {
                              if (code4 < 50109) {
                                if (50108 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (50109 <= code4 && code4 <= 50135) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 50137) {
                                if (50136 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50164) {
                                  if (50137 <= code4 && code4 <= 50163) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50164 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50193) {
                              if (code4 < 50192) {
                                if (50165 <= code4 && code4 <= 50191) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (50192 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 50220) {
                                if (50193 <= code4 && code4 <= 50219) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50221) {
                                  if (50220 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50221 <= code4 && code4 <= 50247) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 50305) {
                            if (code4 < 50276) {
                              if (code4 < 50249) {
                                if (50248 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (50249 <= code4 && code4 <= 50275) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 50277) {
                                if (50276 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50304) {
                                  if (50277 <= code4 && code4 <= 50303) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50304 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50360) {
                              if (code4 < 50332) {
                                if (50305 <= code4 && code4 <= 50331) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50333) {
                                  if (50332 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50333 <= code4 && code4 <= 50359) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50361) {
                                if (50360 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50388) {
                                  if (50361 <= code4 && code4 <= 50387) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50388 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 50556) {
                          if (code4 < 50472) {
                            if (code4 < 50417) {
                              if (code4 < 50416) {
                                if (50389 <= code4 && code4 <= 50415) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (50416 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 50444) {
                                if (50417 <= code4 && code4 <= 50443) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50445) {
                                  if (50444 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50445 <= code4 && code4 <= 50471) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50501) {
                              if (code4 < 50473) {
                                if (50472 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50500) {
                                  if (50473 <= code4 && code4 <= 50499) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50500 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50528) {
                                if (50501 <= code4 && code4 <= 50527) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50529) {
                                  if (50528 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50529 <= code4 && code4 <= 50555) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 50613) {
                            if (code4 < 50584) {
                              if (code4 < 50557) {
                                if (50556 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (50557 <= code4 && code4 <= 50583) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 50585) {
                                if (50584 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50612) {
                                  if (50585 <= code4 && code4 <= 50611) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50612 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50668) {
                              if (code4 < 50640) {
                                if (50613 <= code4 && code4 <= 50639) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50641) {
                                  if (50640 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50641 <= code4 && code4 <= 50667) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50669) {
                                if (50668 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50696) {
                                  if (50669 <= code4 && code4 <= 50695) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50696 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 51004) {
                        if (code4 < 50837) {
                          if (code4 < 50780) {
                            if (code4 < 50725) {
                              if (code4 < 50724) {
                                if (50697 <= code4 && code4 <= 50723) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (50724 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 50752) {
                                if (50725 <= code4 && code4 <= 50751) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50753) {
                                  if (50752 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50753 <= code4 && code4 <= 50779) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50808) {
                              if (code4 < 50781) {
                                if (50780 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (50781 <= code4 && code4 <= 50807) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 50809) {
                                if (50808 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50836) {
                                  if (50809 <= code4 && code4 <= 50835) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50836 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 50920) {
                            if (code4 < 50865) {
                              if (code4 < 50864) {
                                if (50837 <= code4 && code4 <= 50863) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (50864 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 50892) {
                                if (50865 <= code4 && code4 <= 50891) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50893) {
                                  if (50892 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50893 <= code4 && code4 <= 50919) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 50949) {
                              if (code4 < 50921) {
                                if (50920 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 50948) {
                                  if (50921 <= code4 && code4 <= 50947) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (50948 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 50976) {
                                if (50949 <= code4 && code4 <= 50975) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 50977) {
                                  if (50976 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (50977 <= code4 && code4 <= 51003) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51145) {
                          if (code4 < 51061) {
                            if (code4 < 51032) {
                              if (code4 < 51005) {
                                if (51004 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51005 <= code4 && code4 <= 51031) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 51033) {
                                if (51032 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51060) {
                                  if (51033 <= code4 && code4 <= 51059) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51060 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51116) {
                              if (code4 < 51088) {
                                if (51061 <= code4 && code4 <= 51087) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51089) {
                                  if (51088 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51089 <= code4 && code4 <= 51115) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51117) {
                                if (51116 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51144) {
                                  if (51117 <= code4 && code4 <= 51143) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51144 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 51228) {
                            if (code4 < 51173) {
                              if (code4 < 51172) {
                                if (51145 <= code4 && code4 <= 51171) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (51172 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 51200) {
                                if (51173 <= code4 && code4 <= 51199) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51201) {
                                  if (51200 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51201 <= code4 && code4 <= 51227) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51257) {
                              if (code4 < 51229) {
                                if (51228 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51256) {
                                  if (51229 <= code4 && code4 <= 51255) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51256 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51284) {
                                if (51257 <= code4 && code4 <= 51283) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51285) {
                                  if (51284 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51285 <= code4 && code4 <= 51311) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 52516) {
                    if (code4 < 51901) {
                      if (code4 < 51593) {
                        if (code4 < 51452) {
                          if (code4 < 51369) {
                            if (code4 < 51340) {
                              if (code4 < 51313) {
                                if (51312 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51313 <= code4 && code4 <= 51339) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 51341) {
                                if (51340 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51368) {
                                  if (51341 <= code4 && code4 <= 51367) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51368 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51397) {
                              if (code4 < 51396) {
                                if (51369 <= code4 && code4 <= 51395) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (51396 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 51424) {
                                if (51397 <= code4 && code4 <= 51423) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51425) {
                                  if (51424 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51425 <= code4 && code4 <= 51451) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 51509) {
                            if (code4 < 51480) {
                              if (code4 < 51453) {
                                if (51452 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51453 <= code4 && code4 <= 51479) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 51481) {
                                if (51480 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51508) {
                                  if (51481 <= code4 && code4 <= 51507) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51508 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51564) {
                              if (code4 < 51536) {
                                if (51509 <= code4 && code4 <= 51535) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51537) {
                                  if (51536 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51537 <= code4 && code4 <= 51563) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51565) {
                                if (51564 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51592) {
                                  if (51565 <= code4 && code4 <= 51591) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51592 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 51760) {
                          if (code4 < 51676) {
                            if (code4 < 51621) {
                              if (code4 < 51620) {
                                if (51593 <= code4 && code4 <= 51619) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (51620 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 51648) {
                                if (51621 <= code4 && code4 <= 51647) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51649) {
                                  if (51648 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51649 <= code4 && code4 <= 51675) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51705) {
                              if (code4 < 51677) {
                                if (51676 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51704) {
                                  if (51677 <= code4 && code4 <= 51703) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51704 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51732) {
                                if (51705 <= code4 && code4 <= 51731) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51733) {
                                  if (51732 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51733 <= code4 && code4 <= 51759) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 51817) {
                            if (code4 < 51788) {
                              if (code4 < 51761) {
                                if (51760 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51761 <= code4 && code4 <= 51787) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 51789) {
                                if (51788 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51816) {
                                  if (51789 <= code4 && code4 <= 51815) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51816 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 51872) {
                              if (code4 < 51844) {
                                if (51817 <= code4 && code4 <= 51843) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51845) {
                                  if (51844 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51845 <= code4 && code4 <= 51871) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 51873) {
                                if (51872 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 51900) {
                                  if (51873 <= code4 && code4 <= 51899) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (51900 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 52208) {
                        if (code4 < 52041) {
                          if (code4 < 51984) {
                            if (code4 < 51929) {
                              if (code4 < 51928) {
                                if (51901 <= code4 && code4 <= 51927) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (51928 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 51956) {
                                if (51929 <= code4 && code4 <= 51955) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 51957) {
                                  if (51956 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (51957 <= code4 && code4 <= 51983) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52012) {
                              if (code4 < 51985) {
                                if (51984 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (51985 <= code4 && code4 <= 52011) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 52013) {
                                if (52012 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52040) {
                                  if (52013 <= code4 && code4 <= 52039) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52040 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 52124) {
                            if (code4 < 52069) {
                              if (code4 < 52068) {
                                if (52041 <= code4 && code4 <= 52067) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (52068 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 52096) {
                                if (52069 <= code4 && code4 <= 52095) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52097) {
                                  if (52096 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52097 <= code4 && code4 <= 52123) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52153) {
                              if (code4 < 52125) {
                                if (52124 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52152) {
                                  if (52125 <= code4 && code4 <= 52151) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52152 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52180) {
                                if (52153 <= code4 && code4 <= 52179) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52181) {
                                  if (52180 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52181 <= code4 && code4 <= 52207) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52349) {
                          if (code4 < 52265) {
                            if (code4 < 52236) {
                              if (code4 < 52209) {
                                if (52208 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (52209 <= code4 && code4 <= 52235) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 52237) {
                                if (52236 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52264) {
                                  if (52237 <= code4 && code4 <= 52263) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52264 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52320) {
                              if (code4 < 52292) {
                                if (52265 <= code4 && code4 <= 52291) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52293) {
                                  if (52292 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52293 <= code4 && code4 <= 52319) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52321) {
                                if (52320 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52348) {
                                  if (52321 <= code4 && code4 <= 52347) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52348 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 52432) {
                            if (code4 < 52377) {
                              if (code4 < 52376) {
                                if (52349 <= code4 && code4 <= 52375) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (52376 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 52404) {
                                if (52377 <= code4 && code4 <= 52403) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52405) {
                                  if (52404 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52405 <= code4 && code4 <= 52431) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52461) {
                              if (code4 < 52433) {
                                if (52432 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52460) {
                                  if (52433 <= code4 && code4 <= 52459) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52460 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52488) {
                                if (52461 <= code4 && code4 <= 52487) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52489) {
                                  if (52488 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52489 <= code4 && code4 <= 52515) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 53105) {
                      if (code4 < 52797) {
                        if (code4 < 52656) {
                          if (code4 < 52573) {
                            if (code4 < 52544) {
                              if (code4 < 52517) {
                                if (52516 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (52517 <= code4 && code4 <= 52543) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 52545) {
                                if (52544 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52572) {
                                  if (52545 <= code4 && code4 <= 52571) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52572 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52601) {
                              if (code4 < 52600) {
                                if (52573 <= code4 && code4 <= 52599) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (52600 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 52628) {
                                if (52601 <= code4 && code4 <= 52627) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52629) {
                                  if (52628 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52629 <= code4 && code4 <= 52655) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 52713) {
                            if (code4 < 52684) {
                              if (code4 < 52657) {
                                if (52656 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (52657 <= code4 && code4 <= 52683) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 52685) {
                                if (52684 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52712) {
                                  if (52685 <= code4 && code4 <= 52711) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52712 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52768) {
                              if (code4 < 52740) {
                                if (52713 <= code4 && code4 <= 52739) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52741) {
                                  if (52740 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52741 <= code4 && code4 <= 52767) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52769) {
                                if (52768 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52796) {
                                  if (52769 <= code4 && code4 <= 52795) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52796 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 52964) {
                          if (code4 < 52880) {
                            if (code4 < 52825) {
                              if (code4 < 52824) {
                                if (52797 <= code4 && code4 <= 52823) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (52824 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 52852) {
                                if (52825 <= code4 && code4 <= 52851) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52853) {
                                  if (52852 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52853 <= code4 && code4 <= 52879) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 52909) {
                              if (code4 < 52881) {
                                if (52880 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 52908) {
                                  if (52881 <= code4 && code4 <= 52907) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (52908 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 52936) {
                                if (52909 <= code4 && code4 <= 52935) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 52937) {
                                  if (52936 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (52937 <= code4 && code4 <= 52963) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 53021) {
                            if (code4 < 52992) {
                              if (code4 < 52965) {
                                if (52964 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (52965 <= code4 && code4 <= 52991) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 52993) {
                                if (52992 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53020) {
                                  if (52993 <= code4 && code4 <= 53019) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53020 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53076) {
                              if (code4 < 53048) {
                                if (53021 <= code4 && code4 <= 53047) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53049) {
                                  if (53048 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53049 <= code4 && code4 <= 53075) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53077) {
                                if (53076 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53104) {
                                  if (53077 <= code4 && code4 <= 53103) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53104 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 53412) {
                        if (code4 < 53245) {
                          if (code4 < 53188) {
                            if (code4 < 53133) {
                              if (code4 < 53132) {
                                if (53105 <= code4 && code4 <= 53131) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (53132 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 53160) {
                                if (53133 <= code4 && code4 <= 53159) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53161) {
                                  if (53160 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53161 <= code4 && code4 <= 53187) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53216) {
                              if (code4 < 53189) {
                                if (53188 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (53189 <= code4 && code4 <= 53215) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 53217) {
                                if (53216 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53244) {
                                  if (53217 <= code4 && code4 <= 53243) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53244 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 53328) {
                            if (code4 < 53273) {
                              if (code4 < 53272) {
                                if (53245 <= code4 && code4 <= 53271) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (53272 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 53300) {
                                if (53273 <= code4 && code4 <= 53299) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53301) {
                                  if (53300 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53301 <= code4 && code4 <= 53327) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53357) {
                              if (code4 < 53329) {
                                if (53328 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53356) {
                                  if (53329 <= code4 && code4 <= 53355) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53356 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53384) {
                                if (53357 <= code4 && code4 <= 53383) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53385) {
                                  if (53384 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53385 <= code4 && code4 <= 53411) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 53553) {
                          if (code4 < 53469) {
                            if (code4 < 53440) {
                              if (code4 < 53413) {
                                if (53412 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (53413 <= code4 && code4 <= 53439) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 53441) {
                                if (53440 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53468) {
                                  if (53441 <= code4 && code4 <= 53467) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53468 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53524) {
                              if (code4 < 53496) {
                                if (53469 <= code4 && code4 <= 53495) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53497) {
                                  if (53496 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53497 <= code4 && code4 <= 53523) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53525) {
                                if (53524 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53552) {
                                  if (53525 <= code4 && code4 <= 53551) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53552 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 53636) {
                            if (code4 < 53581) {
                              if (code4 < 53580) {
                                if (53553 <= code4 && code4 <= 53579) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (53580 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 53608) {
                                if (53581 <= code4 && code4 <= 53607) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53609) {
                                  if (53608 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53609 <= code4 && code4 <= 53635) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53665) {
                              if (code4 < 53637) {
                                if (53636 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53664) {
                                  if (53637 <= code4 && code4 <= 53663) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53664 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53692) {
                                if (53665 <= code4 && code4 <= 53691) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53693) {
                                  if (53692 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53693 <= code4 && code4 <= 53719) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 70459) {
                  if (code4 < 54897) {
                    if (code4 < 54308) {
                      if (code4 < 54001) {
                        if (code4 < 53860) {
                          if (code4 < 53777) {
                            if (code4 < 53748) {
                              if (code4 < 53721) {
                                if (53720 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (53721 <= code4 && code4 <= 53747) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 53749) {
                                if (53748 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53776) {
                                  if (53749 <= code4 && code4 <= 53775) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53776 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53805) {
                              if (code4 < 53804) {
                                if (53777 <= code4 && code4 <= 53803) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (53804 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 53832) {
                                if (53805 <= code4 && code4 <= 53831) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53833) {
                                  if (53832 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53833 <= code4 && code4 <= 53859) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 53917) {
                            if (code4 < 53888) {
                              if (code4 < 53861) {
                                if (53860 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (53861 <= code4 && code4 <= 53887) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 53889) {
                                if (53888 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 53916) {
                                  if (53889 <= code4 && code4 <= 53915) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (53916 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 53972) {
                              if (code4 < 53944) {
                                if (53917 <= code4 && code4 <= 53943) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 53945) {
                                  if (53944 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (53945 <= code4 && code4 <= 53971) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 53973) {
                                if (53972 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54e3) {
                                  if (53973 <= code4 && code4 <= 53999) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54e3 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54141) {
                          if (code4 < 54084) {
                            if (code4 < 54029) {
                              if (code4 < 54028) {
                                if (54001 <= code4 && code4 <= 54027) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (54028 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 54056) {
                                if (54029 <= code4 && code4 <= 54055) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54057) {
                                  if (54056 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54057 <= code4 && code4 <= 54083) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54112) {
                              if (code4 < 54085) {
                                if (54084 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54085 <= code4 && code4 <= 54111) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 54113) {
                                if (54112 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54140) {
                                  if (54113 <= code4 && code4 <= 54139) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54140 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 54224) {
                            if (code4 < 54169) {
                              if (code4 < 54168) {
                                if (54141 <= code4 && code4 <= 54167) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (54168 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 54196) {
                                if (54169 <= code4 && code4 <= 54195) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54197) {
                                  if (54196 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54197 <= code4 && code4 <= 54223) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54253) {
                              if (code4 < 54225) {
                                if (54224 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54252) {
                                  if (54225 <= code4 && code4 <= 54251) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54252 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54280) {
                                if (54253 <= code4 && code4 <= 54279) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54281) {
                                  if (54280 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54281 <= code4 && code4 <= 54307) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 54589) {
                        if (code4 < 54448) {
                          if (code4 < 54365) {
                            if (code4 < 54336) {
                              if (code4 < 54309) {
                                if (54308 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54309 <= code4 && code4 <= 54335) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 54337) {
                                if (54336 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54364) {
                                  if (54337 <= code4 && code4 <= 54363) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54364 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54393) {
                              if (code4 < 54392) {
                                if (54365 <= code4 && code4 <= 54391) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (54392 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 54420) {
                                if (54393 <= code4 && code4 <= 54419) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54421) {
                                  if (54420 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54421 <= code4 && code4 <= 54447) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 54505) {
                            if (code4 < 54476) {
                              if (code4 < 54449) {
                                if (54448 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54449 <= code4 && code4 <= 54475) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 54477) {
                                if (54476 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54504) {
                                  if (54477 <= code4 && code4 <= 54503) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54504 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54560) {
                              if (code4 < 54532) {
                                if (54505 <= code4 && code4 <= 54531) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54533) {
                                  if (54532 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54533 <= code4 && code4 <= 54559) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54561) {
                                if (54560 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54588) {
                                  if (54561 <= code4 && code4 <= 54587) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54588 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 54756) {
                          if (code4 < 54672) {
                            if (code4 < 54617) {
                              if (code4 < 54616) {
                                if (54589 <= code4 && code4 <= 54615) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (54616 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 54644) {
                                if (54617 <= code4 && code4 <= 54643) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54645) {
                                  if (54644 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54645 <= code4 && code4 <= 54671) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54701) {
                              if (code4 < 54673) {
                                if (54672 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54700) {
                                  if (54673 <= code4 && code4 <= 54699) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54700 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54728) {
                                if (54701 <= code4 && code4 <= 54727) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54729) {
                                  if (54728 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54729 <= code4 && code4 <= 54755) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 54813) {
                            if (code4 < 54784) {
                              if (code4 < 54757) {
                                if (54756 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54757 <= code4 && code4 <= 54783) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 54785) {
                                if (54784 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54812) {
                                  if (54785 <= code4 && code4 <= 54811) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54812 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 54868) {
                              if (code4 < 54840) {
                                if (54813 <= code4 && code4 <= 54839) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54841) {
                                  if (54840 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54841 <= code4 && code4 <= 54867) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 54869) {
                                if (54868 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 54896) {
                                  if (54869 <= code4 && code4 <= 54895) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (54896 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 69632) {
                      if (code4 < 55216) {
                        if (code4 < 55037) {
                          if (code4 < 54980) {
                            if (code4 < 54925) {
                              if (code4 < 54924) {
                                if (54897 <= code4 && code4 <= 54923) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (54924 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 54952) {
                                if (54925 <= code4 && code4 <= 54951) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 54953) {
                                  if (54952 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (54953 <= code4 && code4 <= 54979) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 55008) {
                              if (code4 < 54981) {
                                if (54980 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (54981 <= code4 && code4 <= 55007) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              }
                            } else {
                              if (code4 < 55009) {
                                if (55008 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 55036) {
                                  if (55009 <= code4 && code4 <= 55035) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (55036 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 55120) {
                            if (code4 < 55065) {
                              if (code4 < 55064) {
                                if (55037 <= code4 && code4 <= 55063) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (55064 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              }
                            } else {
                              if (code4 < 55092) {
                                if (55065 <= code4 && code4 <= 55091) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 55093) {
                                  if (55092 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (55093 <= code4 && code4 <= 55119) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 55149) {
                              if (code4 < 55121) {
                                if (55120 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.LV;
                                }
                              } else {
                                if (code4 < 55148) {
                                  if (55121 <= code4 && code4 <= 55147) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                } else {
                                  if (55148 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 55176) {
                                if (55149 <= code4 && code4 <= 55175) {
                                  return boundaries_1.CLUSTER_BREAK.LVT;
                                }
                              } else {
                                if (code4 < 55177) {
                                  if (55176 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.LV;
                                  }
                                } else {
                                  if (55177 <= code4 && code4 <= 55203) {
                                    return boundaries_1.CLUSTER_BREAK.LVT;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 68097) {
                          if (code4 < 65279) {
                            if (code4 < 64286) {
                              if (code4 < 55243) {
                                if (55216 <= code4 && code4 <= 55238) {
                                  return boundaries_1.CLUSTER_BREAK.V;
                                }
                              } else {
                                if (55243 <= code4 && code4 <= 55291) {
                                  return boundaries_1.CLUSTER_BREAK.T;
                                }
                              }
                            } else {
                              if (code4 < 65024) {
                                if (64286 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 65056) {
                                  if (65024 <= code4 && code4 <= 65039) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (65056 <= code4 && code4 <= 65071) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 66045) {
                              if (code4 < 65438) {
                                if (65279 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code4 < 65520) {
                                  if (65438 <= code4 && code4 <= 65439) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (65520 <= code4 && code4 <= 65531) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 66272) {
                                if (66045 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 66422) {
                                  if (66272 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (66422 <= code4 && code4 <= 66426) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 68325) {
                            if (code4 < 68108) {
                              if (code4 < 68101) {
                                if (68097 <= code4 && code4 <= 68099) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (68101 <= code4 && code4 <= 68102) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 68152) {
                                if (68108 <= code4 && code4 <= 68111) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 68159) {
                                  if (68152 <= code4 && code4 <= 68154) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (68159 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 69373) {
                              if (code4 < 68900) {
                                if (68325 <= code4 && code4 <= 68326) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 69291) {
                                  if (68900 <= code4 && code4 <= 68903) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69291 <= code4 && code4 <= 69292) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 69446) {
                                if (69373 <= code4 && code4 <= 69375) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 69506) {
                                  if (69446 <= code4 && code4 <= 69456) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69506 <= code4 && code4 <= 69509) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 70016) {
                        if (code4 < 69815) {
                          if (code4 < 69747) {
                            if (code4 < 69634) {
                              if (69632 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (69633 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 69688) {
                                if (69634 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 69744) {
                                  if (69688 <= code4 && code4 <= 69702) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69744 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 69762) {
                              if (code4 < 69759) {
                                if (69747 <= code4 && code4 <= 69748) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (69759 <= code4 && code4 <= 69761) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 69808) {
                                if (69762 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 69811) {
                                  if (69808 <= code4 && code4 <= 69810) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (69811 <= code4 && code4 <= 69814) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 69888) {
                            if (code4 < 69821) {
                              if (code4 < 69817) {
                                if (69815 <= code4 && code4 <= 69816) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (69817 <= code4 && code4 <= 69818) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 69826) {
                                if (69821 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (69826 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (69837 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 69933) {
                              if (code4 < 69927) {
                                if (69888 <= code4 && code4 <= 69890) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 69932) {
                                  if (69927 <= code4 && code4 <= 69931) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (69932 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 69957) {
                                if (69933 <= code4 && code4 <= 69940) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70003) {
                                  if (69957 <= code4 && code4 <= 69958) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70003 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 70194) {
                          if (code4 < 70082) {
                            if (code4 < 70067) {
                              if (code4 < 70018) {
                                if (70016 <= code4 && code4 <= 70017) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (70018 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 70070) {
                                if (70067 <= code4 && code4 <= 70069) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 70079) {
                                  if (70070 <= code4 && code4 <= 70078) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70079 <= code4 && code4 <= 70080) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 70095) {
                              if (code4 < 70089) {
                                if (70082 <= code4 && code4 <= 70083) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (code4 < 70094) {
                                  if (70089 <= code4 && code4 <= 70092) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70094 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 70188) {
                                if (70095 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70191) {
                                  if (70188 <= code4 && code4 <= 70190) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70191 <= code4 && code4 <= 70193) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 70209) {
                            if (code4 < 70197) {
                              if (code4 < 70196) {
                                if (70194 <= code4 && code4 <= 70195) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (70196 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 70198) {
                                if (70197 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 70206) {
                                  if (70198 <= code4 && code4 <= 70199) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70206 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 70371) {
                              if (code4 < 70367) {
                                if (70209 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70368) {
                                  if (70367 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70368 <= code4 && code4 <= 70370) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 70400) {
                                if (70371 <= code4 && code4 <= 70378) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70402) {
                                  if (70400 <= code4 && code4 <= 70401) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70402 <= code4 && code4 <= 70403) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 72343) {
                    if (code4 < 71339) {
                      if (code4 < 70841) {
                        if (code4 < 70512) {
                          if (code4 < 70471) {
                            if (code4 < 70463) {
                              if (code4 < 70462) {
                                if (70459 <= code4 && code4 <= 70460) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (70462 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 70464) {
                                if (70463 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 70465) {
                                  if (70464 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (70465 <= code4 && code4 <= 70468) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 70487) {
                              if (code4 < 70475) {
                                if (70471 <= code4 && code4 <= 70472) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (70475 <= code4 && code4 <= 70477) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 70498) {
                                if (70487 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70502) {
                                  if (70498 <= code4 && code4 <= 70499) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70502 <= code4 && code4 <= 70508) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 70725) {
                            if (code4 < 70712) {
                              if (code4 < 70709) {
                                if (70512 <= code4 && code4 <= 70516) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (70709 <= code4 && code4 <= 70711) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 70720) {
                                if (70712 <= code4 && code4 <= 70719) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70722) {
                                  if (70720 <= code4 && code4 <= 70721) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70722 <= code4 && code4 <= 70724) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 70832) {
                              if (code4 < 70726) {
                                if (70725 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (70726 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (70750 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 70833) {
                                if (70832 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70835) {
                                  if (70833 <= code4 && code4 <= 70834) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70835 <= code4 && code4 <= 70840) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 71096) {
                          if (code4 < 70847) {
                            if (code4 < 70843) {
                              if (70841 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (70842 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 70845) {
                                if (70843 <= code4 && code4 <= 70844) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (70845 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (70846 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          } else {
                            if (code4 < 71087) {
                              if (code4 < 70849) {
                                if (70847 <= code4 && code4 <= 70848) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 70850) {
                                  if (70849 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (70850 <= code4 && code4 <= 70851) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 71088) {
                                if (71087 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 71090) {
                                  if (71088 <= code4 && code4 <= 71089) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71090 <= code4 && code4 <= 71093) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 71216) {
                            if (code4 < 71102) {
                              if (code4 < 71100) {
                                if (71096 <= code4 && code4 <= 71099) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (71100 <= code4 && code4 <= 71101) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 71103) {
                                if (71102 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 71132) {
                                  if (71103 <= code4 && code4 <= 71104) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71132 <= code4 && code4 <= 71133) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 71229) {
                              if (code4 < 71219) {
                                if (71216 <= code4 && code4 <= 71218) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 71227) {
                                  if (71219 <= code4 && code4 <= 71226) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71227 <= code4 && code4 <= 71228) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 71230) {
                                if (71229 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 71231) {
                                  if (71230 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71231 <= code4 && code4 <= 71232) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 71999) {
                        if (code4 < 71463) {
                          if (code4 < 71350) {
                            if (code4 < 71341) {
                              if (71339 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                              if (71340 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 < 71342) {
                                if (71341 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 71344) {
                                  if (71342 <= code4 && code4 <= 71343) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71344 <= code4 && code4 <= 71349) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 71453) {
                              if (71350 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (71351 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 71458) {
                                if (71453 <= code4 && code4 <= 71455) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 71462) {
                                  if (71458 <= code4 && code4 <= 71461) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (71462 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 71984) {
                            if (code4 < 71727) {
                              if (code4 < 71724) {
                                if (71463 <= code4 && code4 <= 71467) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (71724 <= code4 && code4 <= 71726) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 71736) {
                                if (71727 <= code4 && code4 <= 71735) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 71737) {
                                  if (71736 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71737 <= code4 && code4 <= 71738) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 71995) {
                              if (code4 < 71985) {
                                if (71984 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 71991) {
                                  if (71985 <= code4 && code4 <= 71989) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (71991 <= code4 && code4 <= 71992) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 71997) {
                                if (71995 <= code4 && code4 <= 71996) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (71997 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (71998 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 72193) {
                          if (code4 < 72145) {
                            if (code4 < 72001) {
                              if (71999 === code4) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                              if (72e3 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (code4 < 72002) {
                                if (72001 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (72002 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (72003 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 72156) {
                              if (code4 < 72148) {
                                if (72145 <= code4 && code4 <= 72147) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 72154) {
                                  if (72148 <= code4 && code4 <= 72151) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72154 <= code4 && code4 <= 72155) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 72160) {
                                if (72156 <= code4 && code4 <= 72159) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (72160 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (72164 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 72263) {
                            if (code4 < 72249) {
                              if (code4 < 72243) {
                                if (72193 <= code4 && code4 <= 72202) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (72243 <= code4 && code4 <= 72248) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 72250) {
                                if (72249 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 72251) {
                                  if (72250 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (72251 <= code4 && code4 <= 72254) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 72281) {
                              if (code4 < 72273) {
                                if (72263 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 72279) {
                                  if (72273 <= code4 && code4 <= 72278) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72279 <= code4 && code4 <= 72280) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 72324) {
                                if (72281 <= code4 && code4 <= 72283) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 72330) {
                                  if (72324 <= code4 && code4 <= 72329) {
                                    return boundaries_1.CLUSTER_BREAK.PREPEND;
                                  }
                                } else {
                                  if (72330 <= code4 && code4 <= 72342) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 94033) {
                      if (code4 < 73104) {
                        if (code4 < 72881) {
                          if (code4 < 72766) {
                            if (code4 < 72751) {
                              if (code4 < 72344) {
                                if (72343 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (72344 <= code4 && code4 <= 72345) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 72752) {
                                if (72751 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 72760) {
                                  if (72752 <= code4 && code4 <= 72758) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (72760 <= code4 && code4 <= 72765) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 72850) {
                              if (72766 === code4) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                              if (72767 === code4) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (code4 < 72873) {
                                if (72850 <= code4 && code4 <= 72871) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 72874) {
                                  if (72873 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (72874 <= code4 && code4 <= 72880) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 73018) {
                            if (code4 < 72884) {
                              if (code4 < 72882) {
                                if (72881 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (72882 <= code4 && code4 <= 72883) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 72885) {
                                if (72884 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (code4 < 73009) {
                                  if (72885 <= code4 && code4 <= 72886) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73009 <= code4 && code4 <= 73014) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 73030) {
                              if (code4 < 73020) {
                                if (73018 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 73023) {
                                  if (73020 <= code4 && code4 <= 73021) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73023 <= code4 && code4 <= 73029) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 73031) {
                                if (73030 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (code4 < 73098) {
                                  if (73031 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (73098 <= code4 && code4 <= 73102) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 73526) {
                          if (code4 < 73459) {
                            if (code4 < 73109) {
                              if (code4 < 73107) {
                                if (73104 <= code4 && code4 <= 73105) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (73107 <= code4 && code4 <= 73108) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 73110) {
                                if (73109 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (73110 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (73111 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 73474) {
                              if (code4 < 73461) {
                                if (73459 <= code4 && code4 <= 73460) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 73472) {
                                  if (73461 <= code4 && code4 <= 73462) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (73472 <= code4 && code4 <= 73473) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 73475) {
                                if (73474 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.PREPEND;
                                }
                              } else {
                                if (code4 < 73524) {
                                  if (73475 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (73524 <= code4 && code4 <= 73525) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 78896) {
                            if (code4 < 73536) {
                              if (code4 < 73534) {
                                if (73526 <= code4 && code4 <= 73530) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (73534 <= code4 && code4 <= 73535) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 73537) {
                                if (73536 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (73537 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                                if (73538 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            }
                          } else {
                            if (code4 < 92912) {
                              if (code4 < 78912) {
                                if (78896 <= code4 && code4 <= 78911) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code4 < 78919) {
                                  if (78912 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (78919 <= code4 && code4 <= 78933) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 92976) {
                                if (92912 <= code4 && code4 <= 92916) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 94031) {
                                  if (92976 <= code4 && code4 <= 92982) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (94031 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code4 < 121476) {
                        if (code4 < 119143) {
                          if (code4 < 113824) {
                            if (code4 < 94180) {
                              if (code4 < 94095) {
                                if (94033 <= code4 && code4 <= 94087) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              } else {
                                if (94095 <= code4 && code4 <= 94098) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 94192) {
                                if (94180 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 113821) {
                                  if (94192 <= code4 && code4 <= 94193) {
                                    return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                  }
                                } else {
                                  if (113821 <= code4 && code4 <= 113822) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 118576) {
                              if (code4 < 118528) {
                                if (113824 <= code4 && code4 <= 113827) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (118528 <= code4 && code4 <= 118573) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 119141) {
                                if (118576 <= code4 && code4 <= 118598) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (119141 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                                if (119142 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 119173) {
                            if (code4 < 119150) {
                              if (code4 < 119149) {
                                if (119143 <= code4 && code4 <= 119145) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (119149 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                                }
                              }
                            } else {
                              if (code4 < 119155) {
                                if (119150 <= code4 && code4 <= 119154) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 119163) {
                                  if (119155 <= code4 && code4 <= 119162) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (119163 <= code4 && code4 <= 119170) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 121344) {
                              if (code4 < 119210) {
                                if (119173 <= code4 && code4 <= 119179) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 119362) {
                                  if (119210 <= code4 && code4 <= 119213) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (119362 <= code4 && code4 <= 119364) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 121403) {
                                if (121344 <= code4 && code4 <= 121398) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 121461) {
                                  if (121403 <= code4 && code4 <= 121452) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (121461 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        if (code4 < 123628) {
                          if (code4 < 122907) {
                            if (code4 < 121505) {
                              if (code4 < 121499) {
                                if (121476 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (121499 <= code4 && code4 <= 121503) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 122880) {
                                if (121505 <= code4 && code4 <= 121519) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 122888) {
                                  if (122880 <= code4 && code4 <= 122886) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (122888 <= code4 && code4 <= 122904) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 123023) {
                              if (code4 < 122915) {
                                if (122907 <= code4 && code4 <= 122913) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 122918) {
                                  if (122915 <= code4 && code4 <= 122916) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (122918 <= code4 && code4 <= 122922) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 123184) {
                                if (123023 === code4) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 123566) {
                                  if (123184 <= code4 && code4 <= 123190) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (123566 === code4) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          if (code4 < 127995) {
                            if (code4 < 125136) {
                              if (code4 < 124140) {
                                if (123628 <= code4 && code4 <= 123631) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (124140 <= code4 && code4 <= 124143) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              }
                            } else {
                              if (code4 < 125252) {
                                if (125136 <= code4 && code4 <= 125142) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 127462) {
                                  if (125252 <= code4 && code4 <= 125258) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (127462 <= code4 && code4 <= 127487) {
                                    return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                                  }
                                }
                              }
                            }
                          } else {
                            if (code4 < 917632) {
                              if (code4 < 917504) {
                                if (127995 <= code4 && code4 <= 127999) {
                                  return boundaries_1.CLUSTER_BREAK.EXTEND;
                                }
                              } else {
                                if (code4 < 917536) {
                                  if (917504 <= code4 && code4 <= 917535) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                } else {
                                  if (917536 <= code4 && code4 <= 917631) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                }
                              }
                            } else {
                              if (code4 < 917760) {
                                if (917632 <= code4 && code4 <= 917759) {
                                  return boundaries_1.CLUSTER_BREAK.CONTROL;
                                }
                              } else {
                                if (code4 < 918e3) {
                                  if (917760 <= code4 && code4 <= 917999) {
                                    return boundaries_1.CLUSTER_BREAK.EXTEND;
                                  }
                                } else {
                                  if (918e3 <= code4 && code4 <= 921599) {
                                    return boundaries_1.CLUSTER_BREAK.CONTROL;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return boundaries_1.CLUSTER_BREAK.OTHER;
          }
          static getEmojiProperty(code4) {
            if (code4 < 10160) {
              if (code4 < 9728) {
                if (code4 < 9e3) {
                  if (code4 < 8482) {
                    if (code4 < 8252) {
                      if (169 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (174 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (8252 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (8265 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  } else {
                    if (code4 < 8596) {
                      if (8482 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (8505 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code4 < 8617) {
                        if (8596 <= code4 && code4 <= 8601) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 8986) {
                          if (8617 <= code4 && code4 <= 8618) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (8986 <= code4 && code4 <= 8987) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 9410) {
                    if (code4 < 9167) {
                      if (9e3 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (9096 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code4 < 9193) {
                        if (9167 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 9208) {
                          if (9193 <= code4 && code4 <= 9203) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9208 <= code4 && code4 <= 9210) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 9654) {
                      if (code4 < 9642) {
                        if (9410 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (9642 <= code4 && code4 <= 9643) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 9664) {
                        if (9654 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 9723) {
                          if (9664 === code4) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9723 <= code4 && code4 <= 9726) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 10035) {
                  if (code4 < 10004) {
                    if (code4 < 9748) {
                      if (code4 < 9735) {
                        if (9728 <= code4 && code4 <= 9733) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (9735 <= code4 && code4 <= 9746) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 9872) {
                        if (9748 <= code4 && code4 <= 9861) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 9992) {
                          if (9872 <= code4 && code4 <= 9989) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (9992 <= code4 && code4 <= 10002) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 10013) {
                      if (10004 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (10006 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code4 < 10017) {
                        if (10013 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (10017 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (10024 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 10067) {
                    if (code4 < 10055) {
                      if (code4 < 10052) {
                        if (10035 <= code4 && code4 <= 10036) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (10052 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 10060) {
                        if (10055 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (10060 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (10062 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    }
                  } else {
                    if (code4 < 10083) {
                      if (code4 < 10071) {
                        if (10067 <= code4 && code4 <= 10069) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (10071 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 10133) {
                        if (10083 <= code4 && code4 <= 10087) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 10145) {
                          if (10133 <= code4 && code4 <= 10135) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (10145 === code4) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code4 < 127489) {
                if (code4 < 12951) {
                  if (code4 < 11035) {
                    if (code4 < 10548) {
                      if (10160 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (10175 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code4 < 11013) {
                        if (10548 <= code4 && code4 <= 10549) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (11013 <= code4 && code4 <= 11015) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    }
                  } else {
                    if (code4 < 11093) {
                      if (code4 < 11088) {
                        if (11035 <= code4 && code4 <= 11036) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (11088 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 12336) {
                        if (11093 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (12336 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                        if (12349 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 127340) {
                    if (code4 < 126976) {
                      if (12951 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                      if (12953 === code4) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (code4 < 127245) {
                        if (126976 <= code4 && code4 <= 127231) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 127279) {
                          if (127245 <= code4 && code4 <= 127247) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127279 === code4) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 127374) {
                      if (code4 < 127358) {
                        if (127340 <= code4 && code4 <= 127345) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (127358 <= code4 && code4 <= 127359) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 127377) {
                        if (127374 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 127405) {
                          if (127377 <= code4 && code4 <= 127386) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127405 <= code4 && code4 <= 127461) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code4 < 128981) {
                  if (code4 < 127561) {
                    if (code4 < 127535) {
                      if (code4 < 127514) {
                        if (127489 <= code4 && code4 <= 127503) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (127514 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 127538) {
                        if (127535 === code4) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 127548) {
                          if (127538 <= code4 && code4 <= 127546) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (127548 <= code4 && code4 <= 127551) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 128326) {
                      if (code4 < 128e3) {
                        if (127561 <= code4 && code4 <= 127994) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (128e3 <= code4 && code4 <= 128317) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 128640) {
                        if (128326 <= code4 && code4 <= 128591) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 128884) {
                          if (128640 <= code4 && code4 <= 128767) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (128884 <= code4 && code4 <= 128895) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code4 < 129198) {
                    if (code4 < 129096) {
                      if (code4 < 129036) {
                        if (128981 <= code4 && code4 <= 129023) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (129036 <= code4 && code4 <= 129039) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 129114) {
                        if (129096 <= code4 && code4 <= 129103) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 129160) {
                          if (129114 <= code4 && code4 <= 129119) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (129160 <= code4 && code4 <= 129167) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  } else {
                    if (code4 < 129340) {
                      if (code4 < 129292) {
                        if (129198 <= code4 && code4 <= 129279) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (129292 <= code4 && code4 <= 129338) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      }
                    } else {
                      if (code4 < 129351) {
                        if (129340 <= code4 && code4 <= 129349) {
                          return boundaries_1.EXTENDED_PICTOGRAPHIC;
                        }
                      } else {
                        if (code4 < 130048) {
                          if (129351 <= code4 && code4 <= 129791) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        } else {
                          if (130048 <= code4 && code4 <= 131069) {
                            return boundaries_1.EXTENDED_PICTOGRAPHIC;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return boundaries_1.CLUSTER_BREAK.OTHER;
          }
        };
        exports3.default = Graphemer2;
      }
    });
    var require_lib = __commonJS2({
      "../../node_modules/graphemer/lib/index.js"(exports3) {
        "use strict";
        var __importDefault = exports3 && exports3.__importDefault || function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        Object.defineProperty(exports3, "__esModule", { value: true });
        var Graphemer_1 = __importDefault(require_Graphemer());
        exports3.default = Graphemer_1.default;
      }
    });
    var require_node_gyp_build_optional_packages = __commonJS2({
      "../../node_modules/node-gyp-build-optional-packages/index.js"(exports3, module22) {
        var fs2 = require("fs");
        var path = require("path");
        var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
        var vars = process.config && process.config.variables || {};
        var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
        var abi = process.versions.modules;
        var runtime = isElectron() ? "electron" : "node";
        var arch = process.arch;
        var platform = process.platform;
        var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
        var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
        var uv = (process.versions.uv || "").split(".")[0];
        module22.exports = load;
        function load(dir) {
          return runtimeRequire(load.path(dir));
        }
        load.path = function(dir) {
          dir = path.resolve(dir || ".");
          var packageName;
          try {
            packageName = runtimeRequire(path.join(dir, "package.json")).name;
            var varName = packageName.toUpperCase().replace(/-/g, "_") + "_PREBUILD";
            if (process.env[varName])
              dir = process.env[varName];
          } catch (err) {
          }
          if (!prebuildsOnly) {
            var release = getFirst(path.join(dir, "build/Release"), matchBuild);
            if (release)
              return release;
            var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
            if (debug)
              return debug;
          }
          var prebuild = resolve(dir);
          if (prebuild)
            return prebuild;
          var nearby = resolve(path.dirname(process.execPath));
          if (nearby)
            return nearby;
          var platformPackage = (packageName[0] == "@" ? "" : "@" + packageName + "/") + packageName + "-" + platform + "-" + arch;
          try {
            var prebuildPackage = path.dirname(require("module").createRequire(path.join(dir, "package.json")).resolve(platformPackage));
            return resolveFile(prebuildPackage);
          } catch (error) {
          }
          var target2 = [
            "platform=" + platform,
            "arch=" + arch,
            "runtime=" + runtime,
            "abi=" + abi,
            "uv=" + uv,
            armv ? "armv=" + armv : "",
            "libc=" + libc,
            "node=" + process.versions.node,
            process.versions.electron ? "electron=" + process.versions.electron : "",
            typeof __webpack_require__ === "function" ? "webpack=true" : ""
          ].filter(Boolean).join(" ");
          throw new Error("No native build was found for " + target2 + "\n    loaded from: " + dir + " and package: " + platformPackage + "\n");
          function resolve(dir2) {
            var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
            var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
            if (!tuple)
              return;
            return resolveFile(path.join(dir2, "prebuilds", tuple.name));
          }
          function resolveFile(prebuilds) {
            var parsed = readdirSync(prebuilds).map(parseTags);
            var candidates = parsed.filter(matchTags(runtime, abi));
            var winner = candidates.sort(compareTags(runtime))[0];
            if (winner)
              return path.join(prebuilds, winner.file);
          }
        };
        function readdirSync(dir) {
          try {
            return fs2.readdirSync(dir);
          } catch (err) {
            return [];
          }
        }
        function getFirst(dir, filter2) {
          var files = readdirSync(dir).filter(filter2);
          return files[0] && path.join(dir, files[0]);
        }
        function matchBuild(name3) {
          return /\.node$/.test(name3);
        }
        function parseTuple(name3) {
          var arr = name3.split("-");
          if (arr.length !== 2)
            return;
          var platform2 = arr[0];
          var architectures = arr[1].split("+");
          if (!platform2)
            return;
          if (!architectures.length)
            return;
          if (!architectures.every(Boolean))
            return;
          return { name: name3, platform: platform2, architectures };
        }
        function matchTuple(platform2, arch2) {
          return function(tuple) {
            if (tuple == null)
              return false;
            if (tuple.platform !== platform2)
              return false;
            return tuple.architectures.includes(arch2);
          };
        }
        function compareTuples(a, b) {
          return a.architectures.length - b.architectures.length;
        }
        function parseTags(file) {
          var arr = file.split(".");
          var extension = arr.pop();
          var tags = { file, specificity: 0 };
          if (extension !== "node")
            return;
          for (var i = 0; i < arr.length; i++) {
            var tag = arr[i];
            if (tag === "node" || tag === "electron" || tag === "node-webkit") {
              tags.runtime = tag;
            } else if (tag === "napi") {
              tags.napi = true;
            } else if (tag.slice(0, 3) === "abi") {
              tags.abi = tag.slice(3);
            } else if (tag.slice(0, 2) === "uv") {
              tags.uv = tag.slice(2);
            } else if (tag.slice(0, 4) === "armv") {
              tags.armv = tag.slice(4);
            } else if (tag === "glibc" || tag === "musl") {
              tags.libc = tag;
            } else {
              continue;
            }
            tags.specificity++;
          }
          return tags;
        }
        function matchTags(runtime2, abi2) {
          return function(tags) {
            if (tags == null)
              return false;
            if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
              return false;
            if (tags.abi !== abi2 && !tags.napi)
              return false;
            if (tags.uv && tags.uv !== uv)
              return false;
            if (tags.armv && tags.armv !== armv)
              return false;
            if (tags.libc && tags.libc !== libc)
              return false;
            return true;
          };
        }
        function runtimeAgnostic(tags) {
          return tags.runtime === "node" && tags.napi;
        }
        function compareTags(runtime2) {
          return function(a, b) {
            if (a.runtime !== b.runtime) {
              return a.runtime === runtime2 ? -1 : 1;
            } else if (a.abi !== b.abi) {
              return a.abi ? -1 : 1;
            } else if (a.specificity !== b.specificity) {
              return a.specificity > b.specificity ? -1 : 1;
            } else {
              return 0;
            }
          };
        }
        function isElectron() {
          if (process.versions && process.versions.electron)
            return true;
          if (process.env.ELECTRON_RUN_AS_NODE)
            return true;
          return typeof window !== "undefined" && window.process && window.process.type === "renderer";
        }
        function isAlpine(platform2) {
          return platform2 === "linux" && fs2.existsSync("/etc/alpine-release");
        }
        load.parseTags = parseTags;
        load.matchTags = matchTags;
        load.compareTags = compareTags;
        load.parseTuple = parseTuple;
        load.matchTuple = matchTuple;
        load.compareTuples = compareTuples;
      }
    });
    var require_cbor_extract = __commonJS2({
      "../../node_modules/cbor-extract/index.js"(exports3, module22) {
        module22.exports = require_node_gyp_build_optional_packages()(__dirname);
      }
    });
    var require_err_helpers = __commonJS2({
      "../../node_modules/pino-std-serializers/lib/err-helpers.js"(exports3, module22) {
        "use strict";
        var getErrorCause = (err) => {
          if (!err)
            return;
          const cause = err.cause;
          if (typeof cause === "function") {
            const causeResult = err.cause();
            return causeResult instanceof Error ? causeResult : void 0;
          } else {
            return cause instanceof Error ? cause : void 0;
          }
        };
        var _stackWithCauses = (err, seen) => {
          if (!(err instanceof Error))
            return "";
          const stack = err.stack || "";
          if (seen.has(err)) {
            return stack + "\ncauses have become circular...";
          }
          const cause = getErrorCause(err);
          if (cause) {
            seen.add(err);
            return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
          } else {
            return stack;
          }
        };
        var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
        var _messageWithCauses = (err, seen, skip) => {
          if (!(err instanceof Error))
            return "";
          const message = skip ? "" : err.message || "";
          if (seen.has(err)) {
            return message + ": ...";
          }
          const cause = getErrorCause(err);
          if (cause) {
            seen.add(err);
            const skipIfVErrorStyleCause = typeof err.cause === "function";
            return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
          } else {
            return message;
          }
        };
        var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
        module22.exports = {
          getErrorCause,
          stackWithCauses,
          messageWithCauses
        };
      }
    });
    var require_err = __commonJS2({
      "../../node_modules/pino-std-serializers/lib/err.js"(exports3, module22) {
        "use strict";
        module22.exports = errSerializer;
        var { messageWithCauses, stackWithCauses } = require_err_helpers();
        var { toString: toString42 } = Object.prototype;
        var seen = Symbol("circular-ref-tag");
        var rawSymbol = Symbol("pino-raw-err-ref");
        var pinoErrProto = Object.create({}, {
          type: {
            enumerable: true,
            writable: true,
            value: void 0
          },
          message: {
            enumerable: true,
            writable: true,
            value: void 0
          },
          stack: {
            enumerable: true,
            writable: true,
            value: void 0
          },
          aggregateErrors: {
            enumerable: true,
            writable: true,
            value: void 0
          },
          raw: {
            enumerable: false,
            get: function() {
              return this[rawSymbol];
            },
            set: function(val) {
              this[rawSymbol] = val;
            }
          }
        });
        Object.defineProperty(pinoErrProto, rawSymbol, {
          writable: true,
          value: {}
        });
        function errSerializer(err) {
          if (!(err instanceof Error)) {
            return err;
          }
          err[seen] = void 0;
          const _err = Object.create(pinoErrProto);
          _err.type = toString42.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
          _err.message = messageWithCauses(err);
          _err.stack = stackWithCauses(err);
          if (global.AggregateError !== void 0 && err instanceof global.AggregateError && Array.isArray(err.errors)) {
            _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
          }
          for (const key in err) {
            if (_err[key] === void 0) {
              const val = err[key];
              if (val instanceof Error) {
                if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
                  _err[key] = errSerializer(val);
                }
              } else {
                _err[key] = val;
              }
            }
          }
          delete err[seen];
          _err.raw = err;
          return _err;
        }
      }
    });
    var require_req = __commonJS2({
      "../../node_modules/pino-std-serializers/lib/req.js"(exports3, module22) {
        "use strict";
        module22.exports = {
          mapHttpRequest,
          reqSerializer
        };
        var rawSymbol = Symbol("pino-raw-req-ref");
        var pinoReqProto = Object.create({}, {
          id: {
            enumerable: true,
            writable: true,
            value: ""
          },
          method: {
            enumerable: true,
            writable: true,
            value: ""
          },
          url: {
            enumerable: true,
            writable: true,
            value: ""
          },
          query: {
            enumerable: true,
            writable: true,
            value: ""
          },
          params: {
            enumerable: true,
            writable: true,
            value: ""
          },
          headers: {
            enumerable: true,
            writable: true,
            value: {}
          },
          remoteAddress: {
            enumerable: true,
            writable: true,
            value: ""
          },
          remotePort: {
            enumerable: true,
            writable: true,
            value: ""
          },
          raw: {
            enumerable: false,
            get: function() {
              return this[rawSymbol];
            },
            set: function(val) {
              this[rawSymbol] = val;
            }
          }
        });
        Object.defineProperty(pinoReqProto, rawSymbol, {
          writable: true,
          value: {}
        });
        function reqSerializer(req) {
          const connection = req.info || req.socket;
          const _req = Object.create(pinoReqProto);
          _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
          _req.method = req.method;
          if (req.originalUrl) {
            _req.url = req.originalUrl;
          } else {
            const path = req.path;
            _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : void 0;
          }
          if (req.query) {
            _req.query = req.query;
          }
          if (req.params) {
            _req.params = req.params;
          }
          _req.headers = req.headers;
          _req.remoteAddress = connection && connection.remoteAddress;
          _req.remotePort = connection && connection.remotePort;
          _req.raw = req.raw || req;
          return _req;
        }
        function mapHttpRequest(req) {
          return {
            req: reqSerializer(req)
          };
        }
      }
    });
    var require_res = __commonJS2({
      "../../node_modules/pino-std-serializers/lib/res.js"(exports3, module22) {
        "use strict";
        module22.exports = {
          mapHttpResponse,
          resSerializer
        };
        var rawSymbol = Symbol("pino-raw-res-ref");
        var pinoResProto = Object.create({}, {
          statusCode: {
            enumerable: true,
            writable: true,
            value: 0
          },
          headers: {
            enumerable: true,
            writable: true,
            value: ""
          },
          raw: {
            enumerable: false,
            get: function() {
              return this[rawSymbol];
            },
            set: function(val) {
              this[rawSymbol] = val;
            }
          }
        });
        Object.defineProperty(pinoResProto, rawSymbol, {
          writable: true,
          value: {}
        });
        function resSerializer(res) {
          const _res = Object.create(pinoResProto);
          _res.statusCode = res.headersSent ? res.statusCode : null;
          _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
          _res.raw = res;
          return _res;
        }
        function mapHttpResponse(res) {
          return {
            res: resSerializer(res)
          };
        }
      }
    });
    var require_pino_std_serializers = __commonJS2({
      "../../node_modules/pino-std-serializers/index.js"(exports3, module22) {
        "use strict";
        var errSerializer = require_err();
        var reqSerializers = require_req();
        var resSerializers = require_res();
        module22.exports = {
          err: errSerializer,
          mapHttpRequest: reqSerializers.mapHttpRequest,
          mapHttpResponse: resSerializers.mapHttpResponse,
          req: reqSerializers.reqSerializer,
          res: resSerializers.resSerializer,
          wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
            if (customSerializer === errSerializer)
              return customSerializer;
            return function wrapErrSerializer(err) {
              return customSerializer(errSerializer(err));
            };
          },
          wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
            if (customSerializer === reqSerializers.reqSerializer)
              return customSerializer;
            return function wrappedReqSerializer(req) {
              return customSerializer(reqSerializers.reqSerializer(req));
            };
          },
          wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
            if (customSerializer === resSerializers.resSerializer)
              return customSerializer;
            return function wrappedResSerializer(res) {
              return customSerializer(resSerializers.resSerializer(res));
            };
          }
        };
      }
    });
    var require_caller = __commonJS2({
      "../../node_modules/pino/lib/caller.js"(exports3, module22) {
        "use strict";
        function noOpPrepareStackTrace(_, stack) {
          return stack;
        }
        module22.exports = function getCallers() {
          const originalPrepare = Error.prepareStackTrace;
          Error.prepareStackTrace = noOpPrepareStackTrace;
          const stack = new Error().stack;
          Error.prepareStackTrace = originalPrepare;
          if (!Array.isArray(stack)) {
            return void 0;
          }
          const entries = stack.slice(2);
          const fileNames = [];
          for (const entry of entries) {
            if (!entry) {
              continue;
            }
            fileNames.push(entry.getFileName());
          }
          return fileNames;
        };
      }
    });
    var require_validator = __commonJS2({
      "../../node_modules/fast-redact/lib/validator.js"(exports3, module22) {
        "use strict";
        var { createContext, runInContext } = require("vm");
        module22.exports = validator;
        function validator(opts = {}) {
          const {
            ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
            ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
          } = opts;
          return function validate({ paths }) {
            paths.forEach((s) => {
              if (typeof s !== "string") {
                throw Error(ERR_PATHS_MUST_BE_STRINGS());
              }
              try {
                if (//.test(s))
                  throw Error();
                const proxy = new Proxy({}, { get: () => proxy, set: () => {
                  throw Error();
                } });
                const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
                if (/\n|\r|;/.test(expr))
                  throw Error();
                if (/\/\*/.test(expr))
                  throw Error();
                runInContext(`
          (function () {
            'use strict'
            o${expr}
            if ([o${expr}].length !== 1) throw Error()
          })()
        `, createContext({ o: proxy, "\u3007": null }), {
                  codeGeneration: { strings: false, wasm: false }
                });
              } catch (e) {
                throw Error(ERR_INVALID_PATH(s));
              }
            });
          };
        }
      }
    });
    var require_rx = __commonJS2({
      "../../node_modules/fast-redact/lib/rx.js"(exports3, module22) {
        "use strict";
        module22.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
      }
    });
    var require_parse = __commonJS2({
      "../../node_modules/fast-redact/lib/parse.js"(exports3, module22) {
        "use strict";
        var rx = require_rx();
        module22.exports = parse;
        function parse({ paths }) {
          const wildcards = [];
          var wcLen = 0;
          const secret = paths.reduce(function(o, strPath, ix) {
            var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
            const leadingBracket = strPath[0] === "[";
            path = path.map((p) => {
              if (p[0] === "[")
                return p.substr(1, p.length - 2);
              else
                return p;
            });
            const star = path.indexOf("*");
            if (star > -1) {
              const before = path.slice(0, star);
              const beforeStr = before.join(".");
              const after = path.slice(star + 1, path.length);
              const nested = after.length > 0;
              wcLen++;
              wildcards.push({
                before,
                beforeStr,
                after,
                nested
              });
            } else {
              o[strPath] = {
                path,
                val: void 0,
                precensored: false,
                circle: "",
                escPath: JSON.stringify(strPath),
                leadingBracket
              };
            }
            return o;
          }, {});
          return { wildcards, wcLen, secret };
        }
      }
    });
    var require_redactor = __commonJS2({
      "../../node_modules/fast-redact/lib/redactor.js"(exports3, module22) {
        "use strict";
        var rx = require_rx();
        module22.exports = redactor;
        function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
          const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    ${resultTmpl(serialize)}
  `).bind(state);
          if (serialize === false) {
            redact.restore = (o) => state.restore(o);
          }
          return redact;
        }
        function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
          return Object.keys(secret).map((path) => {
            const { escPath, leadingBracket, path: arrPath } = secret[path];
            const skip = leadingBracket ? 1 : 0;
            const delim = leadingBracket ? "" : ".";
            const hops = [];
            var match;
            while ((match = rx.exec(path)) !== null) {
              const [, ix] = match;
              const { index, input } = match;
              if (index > skip)
                hops.push(input.substring(0, index - (ix ? 0 : 1)));
            }
            var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
            if (existence.length === 0)
              existence += `o${delim}${path} != null`;
            else
              existence += ` && o${delim}${path} != null`;
            const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
            const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
            return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
          }).join("\n");
        }
        function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
          return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
        }
        function resultTmpl(serialize) {
          return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
        }
        function strictImpl(strict, serialize) {
          return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
        }
      }
    });
    var require_modifiers = __commonJS2({
      "../../node_modules/fast-redact/lib/modifiers.js"(exports3, module22) {
        "use strict";
        module22.exports = {
          groupRedact,
          groupRestore,
          nestedRedact,
          nestedRestore
        };
        function groupRestore({ keys, values, target: target2 }) {
          if (target2 == null)
            return;
          const length22 = keys.length;
          for (var i = 0; i < length22; i++) {
            const k = keys[i];
            target2[k] = values[i];
          }
        }
        function groupRedact(o, path, censor, isCensorFct, censorFctTakesPath) {
          const target2 = get2(o, path);
          if (target2 == null)
            return { keys: null, values: null, target: null, flat: true };
          const keys = Object.keys(target2);
          const keysLength = keys.length;
          const pathLength = path.length;
          const pathWithKey = censorFctTakesPath ? [...path] : void 0;
          const values = new Array(keysLength);
          for (var i = 0; i < keysLength; i++) {
            const key = keys[i];
            values[i] = target2[key];
            if (censorFctTakesPath) {
              pathWithKey[pathLength] = key;
              target2[key] = censor(target2[key], pathWithKey);
            } else if (isCensorFct) {
              target2[key] = censor(target2[key]);
            } else {
              target2[key] = censor;
            }
          }
          return { keys, values, target: target2, flat: true };
        }
        function nestedRestore(arr) {
          const length22 = arr.length;
          for (var i = 0; i < length22; i++) {
            const { key, target: target2, value } = arr[i];
            if (has(target2, key)) {
              target2[key] = value;
            }
            if (typeof target2 === "object") {
              const targetKeys = Object.keys(target2);
              for (var j = 0; j < targetKeys.length; j++) {
                const tKey = targetKeys[j];
                const subTarget = target2[tKey];
                if (has(subTarget, key)) {
                  subTarget[key] = value;
                }
              }
            }
          }
        }
        function nestedRedact(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
          const target2 = get2(o, path);
          if (target2 == null)
            return;
          const keys = Object.keys(target2);
          const keysLength = keys.length;
          for (var i = 0; i < keysLength; i++) {
            const key = keys[i];
            const { value, parent, exists } = specialSet(target2, key, path, ns, censor, isCensorFct, censorFctTakesPath);
            if (exists === true && parent !== null) {
              store.push({ key: ns[ns.length - 1], target: parent, value });
            }
          }
          return store;
        }
        function has(obj, prop) {
          return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
        }
        function specialSet(o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
          const afterPathLen = afterPath.length;
          const lastPathIndex = afterPathLen - 1;
          const originalKey = k;
          var i = -1;
          var n;
          var nv;
          var ov;
          var oov = null;
          var exists = true;
          var wc = null;
          ov = n = o[k];
          if (typeof n !== "object")
            return { value: null, parent: null, exists };
          while (n != null && ++i < afterPathLen) {
            k = afterPath[i];
            oov = ov;
            if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
              exists = false;
              break;
            }
            if (k === "*") {
              wc = k;
              if (i !== lastPathIndex) {
                continue;
              }
            }
            if (wc) {
              const wcKeys = Object.keys(n);
              for (var j = 0; j < wcKeys.length; j++) {
                const wck = wcKeys[j];
                const wcov = n[wck];
                const kIsWc = k === "*";
                if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                  if (kIsWc) {
                    ov = wcov;
                  } else {
                    ov = wcov[k];
                  }
                  nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                  if (kIsWc) {
                    n[wck] = nv;
                  } else {
                    if (wcov[k] === nv) {
                      exists = false;
                    } else {
                      wcov[k] = nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov ? wcov[k] : nv;
                    }
                  }
                }
              }
              wc = null;
            } else {
              ov = n[k];
              nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
              n[k] = has(n, k) && nv === ov || nv === void 0 && censor !== void 0 ? n[k] : nv;
              n = n[k];
            }
            if (typeof n !== "object")
              break;
            if (ov === oov) {
              exists = false;
            }
          }
          return { value: ov, parent: oov, exists };
        }
        function get2(o, p) {
          var i = -1;
          var l = p.length;
          var n = o;
          while (n != null && ++i < l) {
            n = n[p[i]];
          }
          return n;
        }
      }
    });
    var require_restorer = __commonJS2({
      "../../node_modules/fast-redact/lib/restorer.js"(exports3, module22) {
        "use strict";
        var { groupRestore, nestedRestore } = require_modifiers();
        module22.exports = restorer;
        function restorer({ secret, wcLen }) {
          return function compileRestore() {
            if (this.restore)
              return;
            const paths = Object.keys(secret);
            const resetters = resetTmpl(secret, paths);
            const hasWildcards = wcLen > 0;
            const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
            this.restore = Function(
              "o",
              restoreTmpl(resetters, paths, hasWildcards)
            ).bind(state);
          };
        }
        function resetTmpl(secret, paths) {
          return paths.map((path) => {
            const { circle, escPath, leadingBracket } = secret[path];
            const delim = leadingBracket ? "" : ".";
            const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
            const clear = `secret[${escPath}].val = undefined`;
            return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
          }).join("");
        }
        function restoreTmpl(resetters, paths, hasWildcards) {
          const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : "";
          return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
        }
      }
    });
    var require_state2 = __commonJS2({
      "../../node_modules/fast-redact/lib/state.js"(exports3, module22) {
        "use strict";
        module22.exports = state;
        function state(o) {
          const {
            secret,
            censor,
            compileRestore,
            serialize,
            groupRedact,
            nestedRedact,
            wildcards,
            wcLen
          } = o;
          const builder = [{ secret, censor, compileRestore }];
          if (serialize !== false)
            builder.push({ serialize });
          if (wcLen > 0)
            builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
          return Object.assign(...builder);
        }
      }
    });
    var require_fast_redact = __commonJS2({
      "../../node_modules/fast-redact/index.js"(exports3, module22) {
        "use strict";
        var validator = require_validator();
        var parse = require_parse();
        var redactor = require_redactor();
        var restorer = require_restorer();
        var { groupRedact, nestedRedact } = require_modifiers();
        var state = require_state2();
        var rx = require_rx();
        var validate = validator();
        var noop2 = (o) => o;
        noop2.restore = noop2;
        var DEFAULT_CENSOR = "[REDACTED]";
        fastRedact.rx = rx;
        fastRedact.validator = validator;
        module22.exports = fastRedact;
        function fastRedact(opts = {}) {
          const paths = Array.from(new Set(opts.paths || []));
          const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
          const remove = opts.remove;
          if (remove === true && serialize !== JSON.stringify) {
            throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
          }
          const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
          const isCensorFct = typeof censor === "function";
          const censorFctTakesPath = isCensorFct && censor.length > 1;
          if (paths.length === 0)
            return serialize || noop2;
          validate({ paths, serialize, censor });
          const { wildcards, wcLen, secret } = parse({ paths, censor });
          const compileRestore = restorer({ secret, wcLen });
          const strict = "strict" in opts ? opts.strict : true;
          return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
            secret,
            censor,
            compileRestore,
            serialize,
            groupRedact,
            nestedRedact,
            wildcards,
            wcLen
          }));
        }
      }
    });
    var require_symbols = __commonJS2({
      "../../node_modules/pino/lib/symbols.js"(exports3, module22) {
        "use strict";
        var setLevelSym = Symbol("pino.setLevel");
        var getLevelSym = Symbol("pino.getLevel");
        var levelValSym = Symbol("pino.levelVal");
        var useLevelLabelsSym = Symbol("pino.useLevelLabels");
        var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
        var mixinSym = Symbol("pino.mixin");
        var lsCacheSym = Symbol("pino.lsCache");
        var chindingsSym = Symbol("pino.chindings");
        var asJsonSym = Symbol("pino.asJson");
        var writeSym = Symbol("pino.write");
        var redactFmtSym = Symbol("pino.redactFmt");
        var timeSym = Symbol("pino.time");
        var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
        var streamSym = Symbol("pino.stream");
        var stringifySym = Symbol("pino.stringify");
        var stringifySafeSym = Symbol("pino.stringifySafe");
        var stringifiersSym = Symbol("pino.stringifiers");
        var endSym = Symbol("pino.end");
        var formatOptsSym = Symbol("pino.formatOpts");
        var messageKeySym = Symbol("pino.messageKey");
        var errorKeySym = Symbol("pino.errorKey");
        var nestedKeySym = Symbol("pino.nestedKey");
        var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
        var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
        var wildcardFirstSym = Symbol("pino.wildcardFirst");
        var serializersSym = Symbol.for("pino.serializers");
        var formattersSym = Symbol.for("pino.formatters");
        var hooksSym = Symbol.for("pino.hooks");
        var needsMetadataGsym = Symbol.for("pino.metadata");
        module22.exports = {
          setLevelSym,
          getLevelSym,
          levelValSym,
          useLevelLabelsSym,
          mixinSym,
          lsCacheSym,
          chindingsSym,
          asJsonSym,
          writeSym,
          serializersSym,
          redactFmtSym,
          timeSym,
          timeSliceIndexSym,
          streamSym,
          stringifySym,
          stringifySafeSym,
          stringifiersSym,
          endSym,
          formatOptsSym,
          messageKeySym,
          errorKeySym,
          nestedKeySym,
          wildcardFirstSym,
          needsMetadataGsym,
          useOnlyCustomLevelsSym,
          formattersSym,
          hooksSym,
          nestedKeyStrSym,
          mixinMergeStrategySym
        };
      }
    });
    var require_redaction = __commonJS2({
      "../../node_modules/pino/lib/redaction.js"(exports3, module22) {
        "use strict";
        var fastRedact = require_fast_redact();
        var { redactFmtSym, wildcardFirstSym } = require_symbols();
        var { rx, validator } = fastRedact;
        var validate = validator({
          ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
          ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
        });
        var CENSOR = "[Redacted]";
        var strict = false;
        function redaction(opts, serialize) {
          const { paths, censor } = handle(opts);
          const shape = paths.reduce((o, str) => {
            rx.lastIndex = 0;
            const first = rx.exec(str);
            const next = rx.exec(str);
            let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
            if (ns === "*") {
              ns = wildcardFirstSym;
            }
            if (next === null) {
              o[ns] = null;
              return o;
            }
            if (o[ns] === null) {
              return o;
            }
            const { index } = next;
            const nextPath = `${str.substr(index, str.length - 1)}`;
            o[ns] = o[ns] || [];
            if (ns !== wildcardFirstSym && o[ns].length === 0) {
              o[ns].push(...o[wildcardFirstSym] || []);
            }
            if (ns === wildcardFirstSym) {
              Object.keys(o).forEach(function(k) {
                if (o[k]) {
                  o[k].push(nextPath);
                }
              });
            }
            o[ns].push(nextPath);
            return o;
          }, {});
          const result = {
            [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
          };
          const topCensor = (...args) => {
            return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
          };
          return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
            if (shape[k] === null) {
              o[k] = (value) => topCensor(value, [k]);
            } else {
              const wrappedCensor = typeof censor === "function" ? (value, path) => {
                return censor(value, [k, ...path]);
              } : censor;
              o[k] = fastRedact({
                paths: shape[k],
                censor: wrappedCensor,
                serialize,
                strict
              });
            }
            return o;
          }, result);
        }
        function handle(opts) {
          if (Array.isArray(opts)) {
            opts = { paths: opts, censor: CENSOR };
            validate(opts);
            return opts;
          }
          let { paths, censor = CENSOR, remove } = opts;
          if (Array.isArray(paths) === false) {
            throw Error("pino \u2013 redact must contain an array of strings");
          }
          if (remove === true)
            censor = void 0;
          validate({ paths, censor });
          return { paths, censor };
        }
        module22.exports = redaction;
      }
    });
    var require_time = __commonJS2({
      "../../node_modules/pino/lib/time.js"(exports3, module22) {
        "use strict";
        var nullTime = () => "";
        var epochTime = () => `,"time":${Date.now()}`;
        var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
        var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
        module22.exports = { nullTime, epochTime, unixTime, isoTime };
      }
    });
    var require_quick_format_unescaped = __commonJS2({
      "../../node_modules/quick-format-unescaped/index.js"(exports3, module22) {
        "use strict";
        function tryStringify(o) {
          try {
            return JSON.stringify(o);
          } catch (e) {
            return '"[Circular]"';
          }
        }
        module22.exports = format;
        function format(f, args, opts) {
          var ss = opts && opts.stringify || tryStringify;
          var offset = 1;
          if (typeof f === "object" && f !== null) {
            var len = args.length + offset;
            if (len === 1)
              return f;
            var objects = new Array(len);
            objects[0] = ss(f);
            for (var index = 1; index < len; index++) {
              objects[index] = ss(args[index]);
            }
            return objects.join(" ");
          }
          if (typeof f !== "string") {
            return f;
          }
          var argLen = args.length;
          if (argLen === 0)
            return f;
          var str = "";
          var a = 1 - offset;
          var lastPos = -1;
          var flen = f && f.length || 0;
          for (var i = 0; i < flen; ) {
            if (f.charCodeAt(i) === 37 && i + 1 < flen) {
              lastPos = lastPos > -1 ? lastPos : 0;
              switch (f.charCodeAt(i + 1)) {
                case 100:
                case 102:
                  if (a >= argLen)
                    break;
                  if (args[a] == null)
                    break;
                  if (lastPos < i)
                    str += f.slice(lastPos, i);
                  str += Number(args[a]);
                  lastPos = i + 2;
                  i++;
                  break;
                case 105:
                  if (a >= argLen)
                    break;
                  if (args[a] == null)
                    break;
                  if (lastPos < i)
                    str += f.slice(lastPos, i);
                  str += Math.floor(Number(args[a]));
                  lastPos = i + 2;
                  i++;
                  break;
                case 79:
                case 111:
                case 106:
                  if (a >= argLen)
                    break;
                  if (args[a] === void 0)
                    break;
                  if (lastPos < i)
                    str += f.slice(lastPos, i);
                  var type = typeof args[a];
                  if (type === "string") {
                    str += "'" + args[a] + "'";
                    lastPos = i + 2;
                    i++;
                    break;
                  }
                  if (type === "function") {
                    str += args[a].name || "<anonymous>";
                    lastPos = i + 2;
                    i++;
                    break;
                  }
                  str += ss(args[a]);
                  lastPos = i + 2;
                  i++;
                  break;
                case 115:
                  if (a >= argLen)
                    break;
                  if (lastPos < i)
                    str += f.slice(lastPos, i);
                  str += String(args[a]);
                  lastPos = i + 2;
                  i++;
                  break;
                case 37:
                  if (lastPos < i)
                    str += f.slice(lastPos, i);
                  str += "%";
                  lastPos = i + 2;
                  i++;
                  a--;
                  break;
              }
              ++a;
            }
            ++i;
          }
          if (lastPos === -1)
            return f;
          else if (lastPos < flen) {
            str += f.slice(lastPos);
          }
          return str;
        }
      }
    });
    var require_atomic_sleep = __commonJS2({
      "../../node_modules/atomic-sleep/index.js"(exports3, module22) {
        "use strict";
        if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
          let sleep = function(ms) {
            const valid = ms > 0 && ms < Infinity;
            if (valid === false) {
              if (typeof ms !== "number" && typeof ms !== "bigint") {
                throw TypeError("sleep: ms must be a number");
              }
              throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
            }
            Atomics.wait(nil, 0, 0, Number(ms));
          };
          const nil = new Int32Array(new SharedArrayBuffer(4));
          module22.exports = sleep;
        } else {
          let sleep = function(ms) {
            const valid = ms > 0 && ms < Infinity;
            if (valid === false) {
              if (typeof ms !== "number" && typeof ms !== "bigint") {
                throw TypeError("sleep: ms must be a number");
              }
              throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
            }
            const target2 = Date.now() + Number(ms);
            while (target2 > Date.now()) {
            }
          };
          module22.exports = sleep;
        }
      }
    });
    var require_sonic_boom = __commonJS2({
      "../../node_modules/sonic-boom/index.js"(exports3, module22) {
        "use strict";
        var fs2 = require("fs");
        var EventEmitter2 = require("events");
        var inherits2 = require("util").inherits;
        var path = require("path");
        var sleep = require_atomic_sleep();
        var BUSY_WRITE_TIMEOUT = 100;
        var MAX_WRITE = 16 * 1024;
        function openFile(file, sonic) {
          sonic._opening = true;
          sonic._writing = true;
          sonic._asyncDrainScheduled = false;
          function fileOpened(err, fd) {
            if (err) {
              sonic._reopening = false;
              sonic._writing = false;
              sonic._opening = false;
              if (sonic.sync) {
                process.nextTick(() => {
                  if (sonic.listenerCount("error") > 0) {
                    sonic.emit("error", err);
                  }
                });
              } else {
                sonic.emit("error", err);
              }
              return;
            }
            sonic.fd = fd;
            sonic.file = file;
            sonic._reopening = false;
            sonic._opening = false;
            sonic._writing = false;
            if (sonic.sync) {
              process.nextTick(() => sonic.emit("ready"));
            } else {
              sonic.emit("ready");
            }
            if (sonic._reopening) {
              return;
            }
            if (!sonic._writing && sonic._len > sonic.minLength && !sonic.destroyed) {
              actualWrite(sonic);
            }
          }
          const flags = sonic.append ? "a" : "w";
          const mode = sonic.mode;
          if (sonic.sync) {
            try {
              if (sonic.mkdir)
                fs2.mkdirSync(path.dirname(file), { recursive: true });
              const fd = fs2.openSync(file, flags, mode);
              fileOpened(null, fd);
            } catch (err) {
              fileOpened(err);
              throw err;
            }
          } else if (sonic.mkdir) {
            fs2.mkdir(path.dirname(file), { recursive: true }, (err) => {
              if (err)
                return fileOpened(err);
              fs2.open(file, flags, mode, fileOpened);
            });
          } else {
            fs2.open(file, flags, mode, fileOpened);
          }
        }
        function SonicBoom(opts) {
          if (!(this instanceof SonicBoom)) {
            return new SonicBoom(opts);
          }
          let { fd, dest, minLength, maxLength, maxWrite, sync, append: append2 = true, mode, mkdir, retryEAGAIN, fsync } = opts || {};
          fd = fd || dest;
          this._bufs = [];
          this._len = 0;
          this.fd = -1;
          this._writing = false;
          this._writingBuf = "";
          this._ending = false;
          this._reopening = false;
          this._asyncDrainScheduled = false;
          this._hwm = Math.max(minLength || 0, 16387);
          this.file = null;
          this.destroyed = false;
          this.minLength = minLength || 0;
          this.maxLength = maxLength || 0;
          this.maxWrite = maxWrite || MAX_WRITE;
          this.sync = sync || false;
          this._fsync = fsync || false;
          this.append = append2 || false;
          this.mode = mode;
          this.retryEAGAIN = retryEAGAIN || (() => true);
          this.mkdir = mkdir || false;
          if (typeof fd === "number") {
            this.fd = fd;
            process.nextTick(() => this.emit("ready"));
          } else if (typeof fd === "string") {
            openFile(fd, this);
          } else {
            throw new Error("SonicBoom supports only file descriptors and files");
          }
          if (this.minLength >= this.maxWrite) {
            throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
          }
          this.release = (err, n) => {
            if (err) {
              if (err.code === "EAGAIN" && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
                if (this.sync) {
                  try {
                    sleep(BUSY_WRITE_TIMEOUT);
                    this.release(void 0, 0);
                  } catch (err2) {
                    this.release(err2);
                  }
                } else {
                  setTimeout(() => {
                    fs2.write(this.fd, this._writingBuf, "utf8", this.release);
                  }, BUSY_WRITE_TIMEOUT);
                }
              } else {
                this._writing = false;
                this.emit("error", err);
              }
              return;
            }
            this.emit("write", n);
            this._len -= n;
            if (this._len < 0) {
              this._len = 0;
            }
            this._writingBuf = this._writingBuf.slice(n);
            if (this._writingBuf.length) {
              if (!this.sync) {
                fs2.write(this.fd, this._writingBuf, "utf8", this.release);
                return;
              }
              try {
                do {
                  const n2 = fs2.writeSync(this.fd, this._writingBuf, "utf8");
                  this._len -= n2;
                  this._writingBuf = this._writingBuf.slice(n2);
                } while (this._writingBuf);
              } catch (err2) {
                this.release(err2);
                return;
              }
            }
            if (this._fsync) {
              fs2.fsyncSync(this.fd);
            }
            const len = this._len;
            if (this._reopening) {
              this._writing = false;
              this._reopening = false;
              this.reopen();
            } else if (len > this.minLength) {
              actualWrite(this);
            } else if (this._ending) {
              if (len > 0) {
                actualWrite(this);
              } else {
                this._writing = false;
                actualClose(this);
              }
            } else {
              this._writing = false;
              if (this.sync) {
                if (!this._asyncDrainScheduled) {
                  this._asyncDrainScheduled = true;
                  process.nextTick(emitDrain, this);
                }
              } else {
                this.emit("drain");
              }
            }
          };
          this.on("newListener", function(name3) {
            if (name3 === "drain") {
              this._asyncDrainScheduled = false;
            }
          });
        }
        function emitDrain(sonic) {
          const hasListeners = sonic.listenerCount("drain") > 0;
          if (!hasListeners)
            return;
          sonic._asyncDrainScheduled = false;
          sonic.emit("drain");
        }
        inherits2(SonicBoom, EventEmitter2);
        SonicBoom.prototype.write = function(data) {
          if (this.destroyed) {
            throw new Error("SonicBoom destroyed");
          }
          const len = this._len + data.length;
          const bufs = this._bufs;
          if (this.maxLength && len > this.maxLength) {
            this.emit("drop", data);
            return this._len < this._hwm;
          }
          if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
            bufs.push("" + data);
          } else {
            bufs[bufs.length - 1] += data;
          }
          this._len = len;
          if (!this._writing && this._len >= this.minLength) {
            actualWrite(this);
          }
          return this._len < this._hwm;
        };
        SonicBoom.prototype.flush = function() {
          if (this.destroyed) {
            throw new Error("SonicBoom destroyed");
          }
          if (this._writing || this.minLength <= 0) {
            return;
          }
          if (this._bufs.length === 0) {
            this._bufs.push("");
          }
          actualWrite(this);
        };
        SonicBoom.prototype.reopen = function(file) {
          if (this.destroyed) {
            throw new Error("SonicBoom destroyed");
          }
          if (this._opening) {
            this.once("ready", () => {
              this.reopen(file);
            });
            return;
          }
          if (this._ending) {
            return;
          }
          if (!this.file) {
            throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
          }
          this._reopening = true;
          if (this._writing) {
            return;
          }
          const fd = this.fd;
          this.once("ready", () => {
            if (fd !== this.fd) {
              fs2.close(fd, (err) => {
                if (err) {
                  return this.emit("error", err);
                }
              });
            }
          });
          openFile(file || this.file, this);
        };
        SonicBoom.prototype.end = function() {
          if (this.destroyed) {
            throw new Error("SonicBoom destroyed");
          }
          if (this._opening) {
            this.once("ready", () => {
              this.end();
            });
            return;
          }
          if (this._ending) {
            return;
          }
          this._ending = true;
          if (this._writing) {
            return;
          }
          if (this._len > 0 && this.fd >= 0) {
            actualWrite(this);
          } else {
            actualClose(this);
          }
        };
        SonicBoom.prototype.flushSync = function() {
          if (this.destroyed) {
            throw new Error("SonicBoom destroyed");
          }
          if (this.fd < 0) {
            throw new Error("sonic boom is not ready yet");
          }
          if (!this._writing && this._writingBuf.length > 0) {
            this._bufs.unshift(this._writingBuf);
            this._writingBuf = "";
          }
          while (this._bufs.length) {
            const buf22 = this._bufs[0];
            try {
              this._len -= fs2.writeSync(this.fd, buf22, "utf8");
              this._bufs.shift();
            } catch (err) {
              if (err.code !== "EAGAIN" || !this.retryEAGAIN(err, buf22.length, this._len - buf22.length)) {
                throw err;
              }
              sleep(BUSY_WRITE_TIMEOUT);
            }
          }
        };
        SonicBoom.prototype.destroy = function() {
          if (this.destroyed) {
            return;
          }
          actualClose(this);
        };
        function actualWrite(sonic) {
          const release = sonic.release;
          sonic._writing = true;
          sonic._writingBuf = sonic._writingBuf || sonic._bufs.shift() || "";
          if (sonic.sync) {
            try {
              const written = fs2.writeSync(sonic.fd, sonic._writingBuf, "utf8");
              release(null, written);
            } catch (err) {
              release(err);
            }
          } else {
            fs2.write(sonic.fd, sonic._writingBuf, "utf8", release);
          }
        }
        function actualClose(sonic) {
          if (sonic.fd === -1) {
            sonic.once("ready", actualClose.bind(null, sonic));
            return;
          }
          sonic.destroyed = true;
          sonic._bufs = [];
          if (sonic.fd !== 1 && sonic.fd !== 2) {
            fs2.close(sonic.fd, done);
          } else {
            setImmediate(done);
          }
          function done(err) {
            if (err) {
              sonic.emit("error", err);
              return;
            }
            if (sonic._ending && !sonic._writing) {
              sonic.emit("finish");
            }
            sonic.emit("close");
          }
        }
        SonicBoom.SonicBoom = SonicBoom;
        SonicBoom.default = SonicBoom;
        module22.exports = SonicBoom;
      }
    });
    var require_on_exit_leak_free = __commonJS2({
      "../../node_modules/on-exit-leak-free/index.js"(exports3, module22) {
        "use strict";
        var refs = {
          exit: [],
          beforeExit: []
        };
        var functions = {
          exit: onExit,
          beforeExit: onBeforeExit
        };
        var registry = new FinalizationRegistry(clear);
        function install(event) {
          if (refs[event].length > 0) {
            return;
          }
          process.on(event, functions[event]);
        }
        function uninstall(event) {
          if (refs[event].length > 0) {
            return;
          }
          process.removeListener(event, functions[event]);
        }
        function onExit() {
          callRefs("exit");
        }
        function onBeforeExit() {
          callRefs("beforeExit");
        }
        function callRefs(event) {
          for (const ref of refs[event]) {
            const obj = ref.deref();
            const fn = ref.fn;
            if (obj !== void 0) {
              fn(obj, event);
            }
          }
        }
        function clear(ref) {
          for (const event of ["exit", "beforeExit"]) {
            const index = refs[event].indexOf(ref);
            refs[event].splice(index, index + 1);
            uninstall(event);
          }
        }
        function _register(event, obj, fn) {
          if (obj === void 0) {
            throw new Error("the object can't be undefined");
          }
          install(event);
          const ref = new WeakRef(obj);
          ref.fn = fn;
          registry.register(obj, ref);
          refs[event].push(ref);
        }
        function register(obj, fn) {
          _register("exit", obj, fn);
        }
        function registerBeforeExit(obj, fn) {
          _register("beforeExit", obj, fn);
        }
        function unregister(obj) {
          registry.unregister(obj);
          for (const event of ["exit", "beforeExit"]) {
            refs[event] = refs[event].filter((ref) => {
              const _obj = ref.deref();
              return _obj && _obj !== obj;
            });
            uninstall(event);
          }
        }
        module22.exports = {
          register,
          registerBeforeExit,
          unregister
        };
      }
    });
    var require_package = __commonJS2({
      "../../node_modules/thread-stream/package.json"(exports3, module22) {
        module22.exports = {
          name: "thread-stream",
          version: "2.2.0",
          description: "A streaming way to send data to a Node.js Worker Thread",
          main: "index.js",
          types: "index.d.ts",
          dependencies: {
            "real-require": "^0.2.0"
          },
          devDependencies: {
            "@types/node": "^18.0.0",
            "@types/tap": "^15.0.0",
            desm: "^1.3.0",
            fastbench: "^1.0.1",
            husky: "^8.0.1",
            "sonic-boom": "^3.0.0",
            standard: "^17.0.0",
            tap: "^16.2.0",
            "ts-node": "^10.8.0",
            typescript: "^4.7.2",
            "why-is-node-running": "^2.2.2"
          },
          scripts: {
            test: "standard && npm run transpile && tap test/*.test.*js && tap --ts test/*.test.*ts",
            "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
            "test:ci:js": 'tap --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*js"',
            "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
            "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
            transpile: "sh ./test/ts/transpile.sh",
            prepare: "husky install"
          },
          standard: { ignore: ["test/ts/**/*"] },
          repository: {
            type: "git",
            url: "git+https://github.com/mcollina/thread-stream.git"
          },
          keywords: [
            "worker",
            "thread",
            "threads",
            "stream"
          ],
          author: "Matteo Collina <hello@matteocollina.com>",
          license: "MIT",
          bugs: {
            url: "https://github.com/mcollina/thread-stream/issues"
          },
          homepage: "https://github.com/mcollina/thread-stream#readme"
        };
      }
    });
    var require_wait = __commonJS2({
      "../../node_modules/thread-stream/lib/wait.js"(exports3, module22) {
        "use strict";
        var MAX_TIMEOUT = 1e3;
        function wait2(state, index, expected, timeout, done) {
          const max = Date.now() + timeout;
          let current = Atomics.load(state, index);
          if (current === expected) {
            done(null, "ok");
            return;
          }
          let prior = current;
          const check5 = (backoff) => {
            if (Date.now() > max) {
              done(null, "timed-out");
            } else {
              setTimeout(() => {
                prior = current;
                current = Atomics.load(state, index);
                if (current === prior) {
                  check5(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
                } else {
                  if (current === expected)
                    done(null, "ok");
                  else
                    done(null, "not-equal");
                }
              }, backoff);
            }
          };
          check5(1);
        }
        function waitDiff(state, index, expected, timeout, done) {
          const max = Date.now() + timeout;
          let current = Atomics.load(state, index);
          if (current !== expected) {
            done(null, "ok");
            return;
          }
          const check5 = (backoff) => {
            if (Date.now() > max) {
              done(null, "timed-out");
            } else {
              setTimeout(() => {
                current = Atomics.load(state, index);
                if (current !== expected) {
                  done(null, "ok");
                } else {
                  check5(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
                }
              }, backoff);
            }
          };
          check5(1);
        }
        module22.exports = { wait: wait2, waitDiff };
      }
    });
    var require_indexes = __commonJS2({
      "../../node_modules/thread-stream/lib/indexes.js"(exports3, module22) {
        "use strict";
        var WRITE_INDEX = 4;
        var READ_INDEX = 8;
        module22.exports = {
          WRITE_INDEX,
          READ_INDEX
        };
      }
    });
    var require_thread_stream = __commonJS2({
      "../../node_modules/thread-stream/index.js"(exports3, module22) {
        "use strict";
        var { version: version22 } = require_package();
        var { EventEmitter: EventEmitter2 } = require("events");
        var { Worker } = require("worker_threads");
        var { join } = require("path");
        var { pathToFileURL } = require("url");
        var { wait: wait2 } = require_wait();
        var {
          WRITE_INDEX,
          READ_INDEX
        } = require_indexes();
        var buffer22 = require("buffer");
        var assert = require("assert");
        var kImpl = Symbol("kImpl");
        var MAX_STRING = buffer22.constants.MAX_STRING_LENGTH;
        var FakeWeakRef = class {
          constructor(value) {
            this._value = value;
          }
          deref() {
            return this._value;
          }
        };
        var FinalizationRegistry2 = global.FinalizationRegistry || class FakeFinalizationRegistry {
          register() {
          }
          unregister() {
          }
        };
        var WeakRef2 = global.WeakRef || FakeWeakRef;
        var registry = new FinalizationRegistry2((worker) => {
          if (worker.exited) {
            return;
          }
          worker.terminate();
        });
        function createWorker(stream4, opts) {
          const { filename, workerData } = opts;
          const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
          const toExecute = bundlerOverrides["thread-stream-worker"] || join(__dirname, "lib", "worker.js");
          const worker = new Worker(toExecute, {
            ...opts.workerOpts,
            workerData: {
              filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
              dataBuf: stream4[kImpl].dataBuf,
              stateBuf: stream4[kImpl].stateBuf,
              workerData: {
                $context: {
                  threadStreamVersion: version22
                },
                ...workerData
              }
            }
          });
          worker.stream = new FakeWeakRef(stream4);
          worker.on("message", onWorkerMessage);
          worker.on("exit", onWorkerExit);
          registry.register(stream4, worker);
          return worker;
        }
        function drain(stream4) {
          assert(!stream4[kImpl].sync);
          if (stream4[kImpl].needDrain) {
            stream4[kImpl].needDrain = false;
            stream4.emit("drain");
          }
        }
        function nextFlush(stream4) {
          const writeIndex = Atomics.load(stream4[kImpl].state, WRITE_INDEX);
          let leftover = stream4[kImpl].data.length - writeIndex;
          if (leftover > 0) {
            if (stream4[kImpl].buf.length === 0) {
              stream4[kImpl].flushing = false;
              if (stream4[kImpl].ending) {
                end(stream4);
              } else if (stream4[kImpl].needDrain) {
                process.nextTick(drain, stream4);
              }
              return;
            }
            let toWrite = stream4[kImpl].buf.slice(0, leftover);
            let toWriteBytes = Buffer.byteLength(toWrite);
            if (toWriteBytes <= leftover) {
              stream4[kImpl].buf = stream4[kImpl].buf.slice(leftover);
              write(stream4, toWrite, nextFlush.bind(null, stream4));
            } else {
              stream4.flush(() => {
                if (stream4.destroyed) {
                  return;
                }
                Atomics.store(stream4[kImpl].state, READ_INDEX, 0);
                Atomics.store(stream4[kImpl].state, WRITE_INDEX, 0);
                while (toWriteBytes > stream4[kImpl].data.length) {
                  leftover = leftover / 2;
                  toWrite = stream4[kImpl].buf.slice(0, leftover);
                  toWriteBytes = Buffer.byteLength(toWrite);
                }
                stream4[kImpl].buf = stream4[kImpl].buf.slice(leftover);
                write(stream4, toWrite, nextFlush.bind(null, stream4));
              });
            }
          } else if (leftover === 0) {
            if (writeIndex === 0 && stream4[kImpl].buf.length === 0) {
              return;
            }
            stream4.flush(() => {
              Atomics.store(stream4[kImpl].state, READ_INDEX, 0);
              Atomics.store(stream4[kImpl].state, WRITE_INDEX, 0);
              nextFlush(stream4);
            });
          } else {
            destroy(stream4, new Error("overwritten"));
          }
        }
        function onWorkerMessage(msg) {
          const stream4 = this.stream.deref();
          if (stream4 === void 0) {
            this.exited = true;
            this.terminate();
            return;
          }
          switch (msg.code) {
            case "READY":
              this.stream = new WeakRef2(stream4);
              stream4.flush(() => {
                stream4[kImpl].ready = true;
                stream4.emit("ready");
              });
              break;
            case "ERROR":
              destroy(stream4, msg.err);
              break;
            case "EVENT":
              if (Array.isArray(msg.args)) {
                stream4.emit(msg.name, ...msg.args);
              } else {
                stream4.emit(msg.name, msg.args);
              }
              break;
            default:
              destroy(stream4, new Error("this should not happen: " + msg.code));
          }
        }
        function onWorkerExit(code4) {
          const stream4 = this.stream.deref();
          if (stream4 === void 0) {
            return;
          }
          registry.unregister(stream4);
          stream4.worker.exited = true;
          stream4.worker.off("exit", onWorkerExit);
          destroy(stream4, code4 !== 0 ? new Error("the worker thread exited") : null);
        }
        var ThreadStream = class extends EventEmitter2 {
          constructor(opts = {}) {
            super();
            if (opts.bufferSize < 4) {
              throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
            }
            this[kImpl] = {};
            this[kImpl].stateBuf = new SharedArrayBuffer(128);
            this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
            this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
            this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
            this[kImpl].sync = opts.sync || false;
            this[kImpl].ending = false;
            this[kImpl].ended = false;
            this[kImpl].needDrain = false;
            this[kImpl].destroyed = false;
            this[kImpl].flushing = false;
            this[kImpl].ready = false;
            this[kImpl].finished = false;
            this[kImpl].errored = null;
            this[kImpl].closed = false;
            this[kImpl].buf = "";
            this.worker = createWorker(this, opts);
          }
          write(data) {
            if (this[kImpl].destroyed) {
              error(this, new Error("the worker has exited"));
              return false;
            }
            if (this[kImpl].ending) {
              error(this, new Error("the worker is ending"));
              return false;
            }
            if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
              try {
                writeSync(this);
                this[kImpl].flushing = true;
              } catch (err) {
                destroy(this, err);
                return false;
              }
            }
            this[kImpl].buf += data;
            if (this[kImpl].sync) {
              try {
                writeSync(this);
                return true;
              } catch (err) {
                destroy(this, err);
                return false;
              }
            }
            if (!this[kImpl].flushing) {
              this[kImpl].flushing = true;
              setImmediate(nextFlush, this);
            }
            this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
            return !this[kImpl].needDrain;
          }
          end() {
            if (this[kImpl].destroyed) {
              return;
            }
            this[kImpl].ending = true;
            end(this);
          }
          flush(cb) {
            if (this[kImpl].destroyed) {
              if (typeof cb === "function") {
                process.nextTick(cb, new Error("the worker has exited"));
              }
              return;
            }
            const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
            wait2(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
              if (err) {
                destroy(this, err);
                process.nextTick(cb, err);
                return;
              }
              if (res === "not-equal") {
                this.flush(cb);
                return;
              }
              process.nextTick(cb);
            });
          }
          flushSync() {
            if (this[kImpl].destroyed) {
              return;
            }
            writeSync(this);
            flushSync(this);
          }
          unref() {
            this.worker.unref();
          }
          ref() {
            this.worker.ref();
          }
          get ready() {
            return this[kImpl].ready;
          }
          get destroyed() {
            return this[kImpl].destroyed;
          }
          get closed() {
            return this[kImpl].closed;
          }
          get writable() {
            return !this[kImpl].destroyed && !this[kImpl].ending;
          }
          get writableEnded() {
            return this[kImpl].ending;
          }
          get writableFinished() {
            return this[kImpl].finished;
          }
          get writableNeedDrain() {
            return this[kImpl].needDrain;
          }
          get writableObjectMode() {
            return false;
          }
          get writableErrored() {
            return this[kImpl].errored;
          }
        };
        function error(stream4, err) {
          setImmediate(() => {
            stream4.emit("error", err);
          });
        }
        function destroy(stream4, err) {
          if (stream4[kImpl].destroyed) {
            return;
          }
          stream4[kImpl].destroyed = true;
          if (err) {
            stream4[kImpl].errored = err;
            error(stream4, err);
          }
          if (!stream4.worker.exited) {
            stream4.worker.terminate().catch(() => {
            }).then(() => {
              stream4[kImpl].closed = true;
              stream4.emit("close");
            });
          } else {
            setImmediate(() => {
              stream4[kImpl].closed = true;
              stream4.emit("close");
            });
          }
        }
        function write(stream4, data, cb) {
          const current = Atomics.load(stream4[kImpl].state, WRITE_INDEX);
          const length22 = Buffer.byteLength(data);
          stream4[kImpl].data.write(data, current);
          Atomics.store(stream4[kImpl].state, WRITE_INDEX, current + length22);
          Atomics.notify(stream4[kImpl].state, WRITE_INDEX);
          cb();
          return true;
        }
        function end(stream4) {
          if (stream4[kImpl].ended || !stream4[kImpl].ending || stream4[kImpl].flushing) {
            return;
          }
          stream4[kImpl].ended = true;
          try {
            stream4.flushSync();
            let readIndex = Atomics.load(stream4[kImpl].state, READ_INDEX);
            Atomics.store(stream4[kImpl].state, WRITE_INDEX, -1);
            Atomics.notify(stream4[kImpl].state, WRITE_INDEX);
            let spins = 0;
            while (readIndex !== -1) {
              Atomics.wait(stream4[kImpl].state, READ_INDEX, readIndex, 1e3);
              readIndex = Atomics.load(stream4[kImpl].state, READ_INDEX);
              if (readIndex === -2) {
                destroy(stream4, new Error("end() failed"));
                return;
              }
              if (++spins === 10) {
                destroy(stream4, new Error("end() took too long (10s)"));
                return;
              }
            }
            process.nextTick(() => {
              stream4[kImpl].finished = true;
              stream4.emit("finish");
            });
          } catch (err) {
            destroy(stream4, err);
          }
        }
        function writeSync(stream4) {
          const cb = () => {
            if (stream4[kImpl].ending) {
              end(stream4);
            } else if (stream4[kImpl].needDrain) {
              process.nextTick(drain, stream4);
            }
          };
          stream4[kImpl].flushing = false;
          while (stream4[kImpl].buf.length !== 0) {
            const writeIndex = Atomics.load(stream4[kImpl].state, WRITE_INDEX);
            let leftover = stream4[kImpl].data.length - writeIndex;
            if (leftover === 0) {
              flushSync(stream4);
              Atomics.store(stream4[kImpl].state, READ_INDEX, 0);
              Atomics.store(stream4[kImpl].state, WRITE_INDEX, 0);
              continue;
            } else if (leftover < 0) {
              throw new Error("overwritten");
            }
            let toWrite = stream4[kImpl].buf.slice(0, leftover);
            let toWriteBytes = Buffer.byteLength(toWrite);
            if (toWriteBytes <= leftover) {
              stream4[kImpl].buf = stream4[kImpl].buf.slice(leftover);
              write(stream4, toWrite, cb);
            } else {
              flushSync(stream4);
              Atomics.store(stream4[kImpl].state, READ_INDEX, 0);
              Atomics.store(stream4[kImpl].state, WRITE_INDEX, 0);
              while (toWriteBytes > stream4[kImpl].buf.length) {
                leftover = leftover / 2;
                toWrite = stream4[kImpl].buf.slice(0, leftover);
                toWriteBytes = Buffer.byteLength(toWrite);
              }
              stream4[kImpl].buf = stream4[kImpl].buf.slice(leftover);
              write(stream4, toWrite, cb);
            }
          }
        }
        function flushSync(stream4) {
          if (stream4[kImpl].flushing) {
            throw new Error("unable to flush while flushing");
          }
          const writeIndex = Atomics.load(stream4[kImpl].state, WRITE_INDEX);
          let spins = 0;
          while (true) {
            const readIndex = Atomics.load(stream4[kImpl].state, READ_INDEX);
            if (readIndex === -2) {
              throw Error("_flushSync failed");
            }
            if (readIndex !== writeIndex) {
              Atomics.wait(stream4[kImpl].state, READ_INDEX, readIndex, 1e3);
            } else {
              break;
            }
            if (++spins === 10) {
              throw new Error("_flushSync took too long (10s)");
            }
          }
        }
        module22.exports = ThreadStream;
      }
    });
    var require_transport = __commonJS2({
      "../../node_modules/pino/lib/transport.js"(exports3, module22) {
        "use strict";
        var { createRequire: createRequire2 } = require("module");
        var getCallers = require_caller();
        var { join, isAbsolute } = require("path");
        var sleep = require_atomic_sleep();
        var onExit = require_on_exit_leak_free();
        var ThreadStream = require_thread_stream();
        function setupOnExit(stream4) {
          onExit.register(stream4, autoEnd);
          onExit.registerBeforeExit(stream4, flush);
          stream4.on("close", function() {
            onExit.unregister(stream4);
          });
        }
        function buildStream(filename, workerData, workerOpts) {
          const stream4 = new ThreadStream({
            filename,
            workerData,
            workerOpts
          });
          stream4.on("ready", onReady);
          stream4.on("close", function() {
            process.removeListener("exit", onExit2);
          });
          process.on("exit", onExit2);
          function onReady() {
            process.removeListener("exit", onExit2);
            stream4.unref();
            if (workerOpts.autoEnd !== false) {
              setupOnExit(stream4);
            }
          }
          function onExit2() {
            if (stream4.closed) {
              return;
            }
            stream4.flushSync();
            sleep(100);
            stream4.end();
          }
          return stream4;
        }
        function autoEnd(stream4) {
          stream4.ref();
          stream4.flushSync();
          stream4.end();
          stream4.once("close", function() {
            stream4.unref();
          });
        }
        function flush(stream4) {
          stream4.flushSync();
        }
        function transport(fullOptions) {
          const { pipeline, targets, levels, options = {}, worker = {}, caller = getCallers() } = fullOptions;
          const callers = typeof caller === "string" ? [caller] : caller;
          const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
          let target2 = fullOptions.target;
          if (target2 && targets) {
            throw new Error("only one of target or targets can be specified");
          }
          if (targets) {
            target2 = bundlerOverrides["pino-worker"] || join(__dirname, "worker.js");
            options.targets = targets.map((dest) => {
              return {
                ...dest,
                target: fixTarget(dest.target)
              };
            });
          } else if (pipeline) {
            target2 = bundlerOverrides["pino-pipeline-worker"] || join(__dirname, "worker-pipeline.js");
            options.targets = pipeline.map((dest) => {
              return {
                ...dest,
                target: fixTarget(dest.target)
              };
            });
          }
          if (levels) {
            options.levels = levels;
          }
          return buildStream(fixTarget(target2), options, worker);
          function fixTarget(origin) {
            origin = bundlerOverrides[origin] || origin;
            if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
              return origin;
            }
            if (origin === "pino/file") {
              return join(__dirname, "..", "file.js");
            }
            let fixTarget2;
            for (const filePath of callers) {
              try {
                fixTarget2 = createRequire2(filePath).resolve(origin);
                break;
              } catch (err) {
                continue;
              }
            }
            if (!fixTarget2) {
              throw new Error(`unable to determine transport target for "${origin}"`);
            }
            return fixTarget2;
          }
        }
        module22.exports = transport;
      }
    });
    var require_tools = __commonJS2({
      "../../node_modules/pino/lib/tools.js"(exports3, module22) {
        "use strict";
        var format = require_quick_format_unescaped();
        var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
        var SonicBoom = require_sonic_boom();
        var onExit = require_on_exit_leak_free();
        var {
          lsCacheSym,
          chindingsSym,
          writeSym,
          serializersSym,
          formatOptsSym,
          endSym,
          stringifiersSym,
          stringifySym,
          stringifySafeSym,
          wildcardFirstSym,
          nestedKeySym,
          formattersSym,
          messageKeySym,
          nestedKeyStrSym
        } = require_symbols();
        var { isMainThread } = require("worker_threads");
        var transport = require_transport();
        function noop2() {
        }
        function genLog(level2, hook) {
          if (!hook)
            return LOG;
          return function hookWrappedLog(...args) {
            hook.call(this, args, LOG, level2);
          };
          function LOG(o, ...n) {
            if (typeof o === "object") {
              let msg = o;
              if (o !== null) {
                if (o.method && o.headers && o.socket) {
                  o = mapHttpRequest(o);
                } else if (typeof o.setHeader === "function") {
                  o = mapHttpResponse(o);
                }
              }
              let formatParams;
              if (msg === null && n.length === 0) {
                formatParams = [null];
              } else {
                msg = n.shift();
                formatParams = n;
              }
              this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level2);
            } else {
              this[writeSym](null, format(o === void 0 ? n.shift() : o, n, this[formatOptsSym]), level2);
            }
          }
        }
        function asString(str) {
          let result = "";
          let last = 0;
          let found = false;
          let point = 255;
          const l = str.length;
          if (l > 100) {
            return JSON.stringify(str);
          }
          for (var i = 0; i < l && point >= 32; i++) {
            point = str.charCodeAt(i);
            if (point === 34 || point === 92) {
              result += str.slice(last, i) + "\\";
              last = i;
              found = true;
            }
          }
          if (!found) {
            result = str;
          } else {
            result += str.slice(last);
          }
          return point < 32 ? JSON.stringify(str) : '"' + result + '"';
        }
        function asJson(obj, msg, num, time) {
          const stringify2 = this[stringifySym];
          const stringifySafe = this[stringifySafeSym];
          const stringifiers = this[stringifiersSym];
          const end = this[endSym];
          const chindings = this[chindingsSym];
          const serializers = this[serializersSym];
          const formatters = this[formattersSym];
          const messageKey = this[messageKeySym];
          let data = this[lsCacheSym][num] + time;
          data = data + chindings;
          let value;
          if (formatters.log) {
            obj = formatters.log(obj);
          }
          const wildcardStringifier = stringifiers[wildcardFirstSym];
          let propStr = "";
          for (const key in obj) {
            value = obj[key];
            if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
              value = serializers[key] ? serializers[key](value) : value;
              const stringifier = stringifiers[key] || wildcardStringifier;
              switch (typeof value) {
                case "undefined":
                case "function":
                  continue;
                case "number":
                  if (Number.isFinite(value) === false) {
                    value = null;
                  }
                case "boolean":
                  if (stringifier)
                    value = stringifier(value);
                  break;
                case "string":
                  value = (stringifier || asString)(value);
                  break;
                default:
                  value = (stringifier || stringify2)(value, stringifySafe);
              }
              if (value === void 0)
                continue;
              propStr += ',"' + key + '":' + value;
            }
          }
          let msgStr = "";
          if (msg !== void 0) {
            value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
            const stringifier = stringifiers[messageKey] || wildcardStringifier;
            switch (typeof value) {
              case "function":
                break;
              case "number":
                if (Number.isFinite(value) === false) {
                  value = null;
                }
              case "boolean":
                if (stringifier)
                  value = stringifier(value);
                msgStr = ',"' + messageKey + '":' + value;
                break;
              case "string":
                value = (stringifier || asString)(value);
                msgStr = ',"' + messageKey + '":' + value;
                break;
              default:
                value = (stringifier || stringify2)(value, stringifySafe);
                msgStr = ',"' + messageKey + '":' + value;
            }
          }
          if (this[nestedKeySym] && propStr) {
            return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
          } else {
            return data + propStr + msgStr + end;
          }
        }
        function asChindings(instance, bindings) {
          let value;
          let data = instance[chindingsSym];
          const stringify2 = instance[stringifySym];
          const stringifySafe = instance[stringifySafeSym];
          const stringifiers = instance[stringifiersSym];
          const wildcardStringifier = stringifiers[wildcardFirstSym];
          const serializers = instance[serializersSym];
          const formatter = instance[formattersSym].bindings;
          bindings = formatter(bindings);
          for (const key in bindings) {
            value = bindings[key];
            const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
            if (valid === true) {
              value = serializers[key] ? serializers[key](value) : value;
              value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
              if (value === void 0)
                continue;
              data += ',"' + key + '":' + value;
            }
          }
          return data;
        }
        function hasBeenTampered(stream4) {
          return stream4.write !== stream4.constructor.prototype.write;
        }
        function buildSafeSonicBoom(opts) {
          const stream4 = new SonicBoom(opts);
          stream4.on("error", filterBrokenPipe);
          if (!opts.sync && isMainThread) {
            onExit.register(stream4, autoEnd);
            stream4.on("close", function() {
              onExit.unregister(stream4);
            });
          }
          return stream4;
          function filterBrokenPipe(err) {
            if (err.code === "EPIPE") {
              stream4.write = noop2;
              stream4.end = noop2;
              stream4.flushSync = noop2;
              stream4.destroy = noop2;
              return;
            }
            stream4.removeListener("error", filterBrokenPipe);
            stream4.emit("error", err);
          }
        }
        function autoEnd(stream4, eventName) {
          if (stream4.destroyed) {
            return;
          }
          if (eventName === "beforeExit") {
            stream4.flush();
            stream4.on("drain", function() {
              stream4.end();
            });
          } else {
            stream4.flushSync();
          }
        }
        function createArgsNormalizer(defaultOptions2) {
          return function normalizeArgs(instance, caller, opts = {}, stream4) {
            if (typeof opts === "string") {
              stream4 = buildSafeSonicBoom({ dest: opts });
              opts = {};
            } else if (typeof stream4 === "string") {
              if (opts && opts.transport) {
                throw Error("only one of option.transport or stream can be specified");
              }
              stream4 = buildSafeSonicBoom({ dest: stream4 });
            } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
              stream4 = opts;
              opts = {};
            } else if (opts.transport) {
              if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
                throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
              }
              if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
                throw Error("option.transport.targets do not allow custom level formatters");
              }
              let customLevels;
              if (opts.customLevels) {
                customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
              }
              stream4 = transport({ caller, ...opts.transport, levels: customLevels });
            }
            opts = Object.assign({}, defaultOptions2, opts);
            opts.serializers = Object.assign({}, defaultOptions2.serializers, opts.serializers);
            opts.formatters = Object.assign({}, defaultOptions2.formatters, opts.formatters);
            if (opts.prettyPrint) {
              throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
            }
            const { enabled: enabled2, onChild } = opts;
            if (enabled2 === false)
              opts.level = "silent";
            if (!onChild)
              opts.onChild = noop2;
            if (!stream4) {
              if (!hasBeenTampered(process.stdout)) {
                stream4 = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
              } else {
                stream4 = process.stdout;
              }
            }
            return { opts, stream: stream4 };
          };
        }
        function stringify(obj, stringifySafeFn) {
          try {
            return JSON.stringify(obj);
          } catch (_) {
            try {
              const stringify2 = stringifySafeFn || this[stringifySafeSym];
              return stringify2(obj);
            } catch (_2) {
              return '"[unable to serialize, circular reference is too complex to analyze]"';
            }
          }
        }
        function buildFormatters(level2, bindings, log) {
          return {
            level: level2,
            bindings,
            log
          };
        }
        function normalizeDestFileDescriptor(destination) {
          const fd = Number(destination);
          if (typeof destination === "string" && Number.isFinite(fd)) {
            return fd;
          }
          if (destination === void 0) {
            return 1;
          }
          return destination;
        }
        module22.exports = {
          noop: noop2,
          buildSafeSonicBoom,
          asChindings,
          asJson,
          genLog,
          createArgsNormalizer,
          stringify,
          buildFormatters,
          normalizeDestFileDescriptor
        };
      }
    });
    var require_levels = __commonJS2({
      "../../node_modules/pino/lib/levels.js"(exports3, module22) {
        "use strict";
        var {
          lsCacheSym,
          levelValSym,
          useOnlyCustomLevelsSym,
          streamSym,
          formattersSym,
          hooksSym
        } = require_symbols();
        var { noop: noop2, genLog } = require_tools();
        var levels = {
          trace: 10,
          debug: 20,
          info: 30,
          warn: 40,
          error: 50,
          fatal: 60
        };
        var levelMethods = {
          fatal: (hook) => {
            const logFatal = genLog(levels.fatal, hook);
            return function(...args) {
              const stream4 = this[streamSym];
              logFatal.call(this, ...args);
              if (typeof stream4.flushSync === "function") {
                try {
                  stream4.flushSync();
                } catch (e) {
                }
              }
            };
          },
          error: (hook) => genLog(levels.error, hook),
          warn: (hook) => genLog(levels.warn, hook),
          info: (hook) => genLog(levels.info, hook),
          debug: (hook) => genLog(levels.debug, hook),
          trace: (hook) => genLog(levels.trace, hook)
        };
        var nums = Object.keys(levels).reduce((o, k) => {
          o[levels[k]] = k;
          return o;
        }, {});
        var initialLsCache = Object.keys(nums).reduce((o, k) => {
          o[k] = '{"level":' + Number(k);
          return o;
        }, {});
        function genLsCache(instance) {
          const formatter = instance[formattersSym].level;
          const { labels } = instance.levels;
          const cache = {};
          for (const label in labels) {
            const level2 = formatter(labels[label], Number(label));
            cache[label] = JSON.stringify(level2).slice(0, -1);
          }
          instance[lsCacheSym] = cache;
          return instance;
        }
        function isStandardLevel(level2, useOnlyCustomLevels) {
          if (useOnlyCustomLevels) {
            return false;
          }
          switch (level2) {
            case "fatal":
            case "error":
            case "warn":
            case "info":
            case "debug":
            case "trace":
              return true;
            default:
              return false;
          }
        }
        function setLevel(level2) {
          const { labels, values } = this.levels;
          if (typeof level2 === "number") {
            if (labels[level2] === void 0)
              throw Error("unknown level value" + level2);
            level2 = labels[level2];
          }
          if (values[level2] === void 0)
            throw Error("unknown level " + level2);
          const preLevelVal = this[levelValSym];
          const levelVal = this[levelValSym] = values[level2];
          const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
          const hook = this[hooksSym].logMethod;
          for (const key in values) {
            if (levelVal > values[key]) {
              this[key] = noop2;
              continue;
            }
            this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
          }
          this.emit(
            "level-change",
            level2,
            levelVal,
            labels[preLevelVal],
            preLevelVal
          );
        }
        function getLevel(level2) {
          const { levels: levels2, levelVal } = this;
          return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
        }
        function isLevelEnabled(logLevel) {
          const { values } = this.levels;
          const logLevelVal = values[logLevel];
          return logLevelVal !== void 0 && logLevelVal >= this[levelValSym];
        }
        function mappings(customLevels = null, useOnlyCustomLevels = false) {
          const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
            o[customLevels[k]] = k;
            return o;
          }, {}) : null;
          const labels = Object.assign(
            Object.create(Object.prototype, { Infinity: { value: "silent" } }),
            useOnlyCustomLevels ? null : nums,
            customNums
          );
          const values = Object.assign(
            Object.create(Object.prototype, { silent: { value: Infinity } }),
            useOnlyCustomLevels ? null : levels,
            customLevels
          );
          return { labels, values };
        }
        function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
          if (typeof defaultLevel === "number") {
            const values = [].concat(
              Object.keys(customLevels || {}).map((key) => customLevels[key]),
              useOnlyCustomLevels ? [] : Object.keys(nums).map((level2) => +level2),
              Infinity
            );
            if (!values.includes(defaultLevel)) {
              throw Error(`default level:${defaultLevel} must be included in custom levels`);
            }
            return;
          }
          const labels = Object.assign(
            Object.create(Object.prototype, { silent: { value: Infinity } }),
            useOnlyCustomLevels ? null : levels,
            customLevels
          );
          if (!(defaultLevel in labels)) {
            throw Error(`default level:${defaultLevel} must be included in custom levels`);
          }
        }
        function assertNoLevelCollisions(levels2, customLevels) {
          const { labels, values } = levels2;
          for (const k in customLevels) {
            if (k in values) {
              throw Error("levels cannot be overridden");
            }
            if (customLevels[k] in labels) {
              throw Error("pre-existing level values cannot be used for new levels");
            }
          }
        }
        module22.exports = {
          initialLsCache,
          genLsCache,
          levelMethods,
          getLevel,
          setLevel,
          isLevelEnabled,
          mappings,
          levels,
          assertNoLevelCollisions,
          assertDefaultLevelFound
        };
      }
    });
    var require_meta = __commonJS2({
      "../../node_modules/pino/lib/meta.js"(exports3, module22) {
        "use strict";
        module22.exports = { version: "8.6.1" };
      }
    });
    var require_proto = __commonJS2({
      "../../node_modules/pino/lib/proto.js"(exports3, module22) {
        "use strict";
        var { EventEmitter: EventEmitter2 } = require("events");
        var {
          lsCacheSym,
          levelValSym,
          setLevelSym,
          getLevelSym,
          chindingsSym,
          parsedChindingsSym,
          mixinSym,
          asJsonSym,
          writeSym,
          mixinMergeStrategySym,
          timeSym,
          timeSliceIndexSym,
          streamSym,
          serializersSym,
          formattersSym,
          errorKeySym,
          useOnlyCustomLevelsSym,
          needsMetadataGsym,
          redactFmtSym,
          stringifySym,
          formatOptsSym,
          stringifiersSym
        } = require_symbols();
        var {
          getLevel,
          setLevel,
          isLevelEnabled,
          mappings,
          initialLsCache,
          genLsCache,
          assertNoLevelCollisions
        } = require_levels();
        var {
          asChindings,
          asJson,
          buildFormatters,
          stringify
        } = require_tools();
        var {
          version: version22
        } = require_meta();
        var redaction = require_redaction();
        var constructor = class Pino {
        };
        var prototype3 = {
          constructor,
          child,
          bindings,
          setBindings,
          flush,
          isLevelEnabled,
          version: version22,
          get level() {
            return this[getLevelSym]();
          },
          set level(lvl) {
            this[setLevelSym](lvl);
          },
          get levelVal() {
            return this[levelValSym];
          },
          set levelVal(n) {
            throw Error("levelVal is read-only");
          },
          [lsCacheSym]: initialLsCache,
          [writeSym]: write,
          [asJsonSym]: asJson,
          [getLevelSym]: getLevel,
          [setLevelSym]: setLevel
        };
        Object.setPrototypeOf(prototype3, EventEmitter2.prototype);
        module22.exports = function() {
          return Object.create(prototype3);
        };
        var resetChildingsFormatter = (bindings2) => bindings2;
        function child(bindings2, options) {
          if (!bindings2) {
            throw Error("missing bindings for child Pino");
          }
          options = options || {};
          const serializers = this[serializersSym];
          const formatters = this[formattersSym];
          const instance = Object.create(this);
          if (options.hasOwnProperty("serializers") === true) {
            instance[serializersSym] = /* @__PURE__ */ Object.create(null);
            for (const k in serializers) {
              instance[serializersSym][k] = serializers[k];
            }
            const parentSymbols = Object.getOwnPropertySymbols(serializers);
            for (var i = 0; i < parentSymbols.length; i++) {
              const ks = parentSymbols[i];
              instance[serializersSym][ks] = serializers[ks];
            }
            for (const bk in options.serializers) {
              instance[serializersSym][bk] = options.serializers[bk];
            }
            const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
            for (var bi = 0; bi < bindingsSymbols.length; bi++) {
              const bks = bindingsSymbols[bi];
              instance[serializersSym][bks] = options.serializers[bks];
            }
          } else
            instance[serializersSym] = serializers;
          if (options.hasOwnProperty("formatters")) {
            const { level: level2, bindings: chindings, log } = options.formatters;
            instance[formattersSym] = buildFormatters(
              level2 || formatters.level,
              chindings || resetChildingsFormatter,
              log || formatters.log
            );
          } else {
            instance[formattersSym] = buildFormatters(
              formatters.level,
              resetChildingsFormatter,
              formatters.log
            );
          }
          if (options.hasOwnProperty("customLevels") === true) {
            assertNoLevelCollisions(this.levels, options.customLevels);
            instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
            genLsCache(instance);
          }
          if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
            instance.redact = options.redact;
            const stringifiers = redaction(instance.redact, stringify);
            const formatOpts = { stringify: stringifiers[redactFmtSym] };
            instance[stringifySym] = stringify;
            instance[stringifiersSym] = stringifiers;
            instance[formatOptsSym] = formatOpts;
          }
          instance[chindingsSym] = asChindings(instance, bindings2);
          const childLevel = options.level || this.level;
          instance[setLevelSym](childLevel);
          this.onChild(instance);
          return instance;
        }
        function bindings() {
          const chindings = this[chindingsSym];
          const chindingsJson = `{${chindings.substr(1)}}`;
          const bindingsFromJson = JSON.parse(chindingsJson);
          delete bindingsFromJson.pid;
          delete bindingsFromJson.hostname;
          return bindingsFromJson;
        }
        function setBindings(newBindings) {
          const chindings = asChindings(this, newBindings);
          this[chindingsSym] = chindings;
          delete this[parsedChindingsSym];
        }
        function defaultMixinMergeStrategy(mergeObject, mixinObject) {
          return Object.assign(mixinObject, mergeObject);
        }
        function write(_obj, msg, num) {
          const t = this[timeSym]();
          const mixin = this[mixinSym];
          const errorKey = this[errorKeySym];
          const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
          let obj;
          if (_obj === void 0 || _obj === null) {
            obj = {};
          } else if (_obj instanceof Error) {
            obj = { [errorKey]: _obj };
            if (msg === void 0) {
              msg = _obj.message;
            }
          } else {
            obj = _obj;
            if (msg === void 0 && _obj[errorKey]) {
              msg = _obj[errorKey].message;
            }
          }
          if (mixin) {
            obj = mixinMergeStrategy(obj, mixin(obj, num));
          }
          const s = this[asJsonSym](obj, msg, num, t);
          const stream4 = this[streamSym];
          if (stream4[needsMetadataGsym] === true) {
            stream4.lastLevel = num;
            stream4.lastObj = obj;
            stream4.lastMsg = msg;
            stream4.lastTime = t.slice(this[timeSliceIndexSym]);
            stream4.lastLogger = this;
          }
          stream4.write(s);
        }
        function noop2() {
        }
        function flush() {
          const stream4 = this[streamSym];
          if ("flush" in stream4)
            stream4.flush(noop2);
        }
      }
    });
    var require_safe_stable_stringify = __commonJS2({
      "../../node_modules/safe-stable-stringify/index.js"(exports3, module22) {
        "use strict";
        var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
        var stringify = configure();
        stringify.configure = configure;
        stringify.stringify = stringify;
        stringify.default = stringify;
        exports3.stringify = stringify;
        exports3.configure = configure;
        module22.exports = stringify;
        var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
        var strEscapeSequencesReplacer = new RegExp(strEscapeSequencesRegExp, "g");
        var meta = [
          "\\u0000",
          "\\u0001",
          "\\u0002",
          "\\u0003",
          "\\u0004",
          "\\u0005",
          "\\u0006",
          "\\u0007",
          "\\b",
          "\\t",
          "\\n",
          "\\u000b",
          "\\f",
          "\\r",
          "\\u000e",
          "\\u000f",
          "\\u0010",
          "\\u0011",
          "\\u0012",
          "\\u0013",
          "\\u0014",
          "\\u0015",
          "\\u0016",
          "\\u0017",
          "\\u0018",
          "\\u0019",
          "\\u001a",
          "\\u001b",
          "\\u001c",
          "\\u001d",
          "\\u001e",
          "\\u001f",
          "",
          "",
          '\\"',
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "\\\\"
        ];
        function escapeFn(str) {
          if (str.length === 2) {
            const charCode2 = str.charCodeAt(1);
            return `${str[0]}\\u${charCode2.toString(16)}`;
          }
          const charCode = str.charCodeAt(0);
          return meta.length > charCode ? meta[charCode] : `\\u${charCode.toString(16)}`;
        }
        function strEscape(str) {
          if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
            return str;
          }
          if (str.length > 100) {
            return str.replace(strEscapeSequencesReplacer, escapeFn);
          }
          let result = "";
          let last = 0;
          for (let i = 0; i < str.length; i++) {
            const point = str.charCodeAt(i);
            if (point === 34 || point === 92 || point < 32) {
              result += `${str.slice(last, i)}${meta[point]}`;
              last = i + 1;
            } else if (point >= 55296 && point <= 57343) {
              if (point <= 56319 && i + 1 < str.length) {
                const nextPoint = str.charCodeAt(i + 1);
                if (nextPoint >= 56320 && nextPoint <= 57343) {
                  i++;
                  continue;
                }
              }
              result += `${str.slice(last, i)}\\u${point.toString(16)}`;
              last = i + 1;
            }
          }
          result += str.slice(last);
          return result;
        }
        function insertSort(array) {
          if (array.length > 200) {
            return array.sort();
          }
          for (let i = 1; i < array.length; i++) {
            const currentValue = array[i];
            let position3 = i;
            while (position3 !== 0 && array[position3 - 1] > currentValue) {
              array[position3] = array[position3 - 1];
              position3--;
            }
            array[position3] = currentValue;
          }
          return array;
        }
        var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
          Object.getPrototypeOf(
            Object.getPrototypeOf(
              new Int8Array()
            )
          ),
          Symbol.toStringTag
        ).get;
        function isTypedArrayWithEntries(value) {
          return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
        }
        function stringifyTypedArray(array, separator, maximumBreadth) {
          if (array.length < maximumBreadth) {
            maximumBreadth = array.length;
          }
          const whitespace = separator === "," ? "" : " ";
          let res = `"0":${whitespace}${array[0]}`;
          for (let i = 1; i < maximumBreadth; i++) {
            res += `${separator}"${i}":${whitespace}${array[i]}`;
          }
          return res;
        }
        function getCircularValueOption(options) {
          if (options && hasOwnProperty2.call(options, "circularValue")) {
            const circularValue = options.circularValue;
            if (typeof circularValue === "string") {
              return `"${circularValue}"`;
            }
            if (circularValue == null) {
              return circularValue;
            }
            if (circularValue === Error || circularValue === TypeError) {
              return {
                toString() {
                  throw new TypeError("Converting circular structure to JSON");
                }
              };
            }
            throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
          }
          return '"[Circular]"';
        }
        function getBooleanOption(options, key) {
          let value;
          if (options && hasOwnProperty2.call(options, key)) {
            value = options[key];
            if (typeof value !== "boolean") {
              throw new TypeError(`The "${key}" argument must be of type boolean`);
            }
          }
          return value === void 0 ? true : value;
        }
        function getPositiveIntegerOption(options, key) {
          let value;
          if (options && hasOwnProperty2.call(options, key)) {
            value = options[key];
            if (typeof value !== "number") {
              throw new TypeError(`The "${key}" argument must be of type number`);
            }
            if (!Number.isInteger(value)) {
              throw new TypeError(`The "${key}" argument must be an integer`);
            }
            if (value < 1) {
              throw new RangeError(`The "${key}" argument must be >= 1`);
            }
          }
          return value === void 0 ? Infinity : value;
        }
        function getItemCount(number) {
          if (number === 1) {
            return "1 item";
          }
          return `${number} items`;
        }
        function getUniqueReplacerSet(replacerArray) {
          const replacerSet = /* @__PURE__ */ new Set();
          for (const value of replacerArray) {
            if (typeof value === "string" || typeof value === "number") {
              replacerSet.add(String(value));
            }
          }
          return replacerSet;
        }
        function getStrictOption(options) {
          if (options && hasOwnProperty2.call(options, "strict")) {
            const value = options.strict;
            if (typeof value !== "boolean") {
              throw new TypeError('The "strict" argument must be of type boolean');
            }
            if (value) {
              return (value2) => {
                let message = `Object can not safely be stringified. Received type ${typeof value2}`;
                if (typeof value2 !== "function")
                  message += ` (${value2.toString()})`;
                throw new Error(message);
              };
            }
          }
        }
        function configure(options) {
          options = { ...options };
          const fail = getStrictOption(options);
          if (fail) {
            if (options.bigint === void 0) {
              options.bigint = false;
            }
            if (!("circularValue" in options)) {
              options.circularValue = Error;
            }
          }
          const circularValue = getCircularValueOption(options);
          const bigint = getBooleanOption(options, "bigint");
          const deterministic = getBooleanOption(options, "deterministic");
          const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
          const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
          function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
            let value = parent[key];
            if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
              value = value.toJSON(key);
            }
            value = replacer.call(parent, key, value);
            switch (typeof value) {
              case "string":
                return `"${strEscape(value)}"`;
              case "object": {
                if (value === null) {
                  return "null";
                }
                if (stack.indexOf(value) !== -1) {
                  return circularValue;
                }
                let res = "";
                let join = ",";
                const originalIndentation = indentation;
                if (Array.isArray(value)) {
                  if (value.length === 0) {
                    return "[]";
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Array]"';
                  }
                  stack.push(value);
                  if (spacer !== "") {
                    indentation += spacer;
                    res += `
${indentation}`;
                    join = `,
${indentation}`;
                  }
                  const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                  let i = 0;
                  for (; i < maximumValuesToStringify - 1; i++) {
                    const tmp2 = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                    res += tmp2 !== void 0 ? tmp2 : "null";
                    res += join;
                  }
                  const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                  res += tmp !== void 0 ? tmp : "null";
                  if (value.length - 1 > maximumBreadth) {
                    const removedKeys = value.length - maximumBreadth - 1;
                    res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                  }
                  if (spacer !== "") {
                    res += `
${originalIndentation}`;
                  }
                  stack.pop();
                  return `[${res}]`;
                }
                let keys = Object.keys(value);
                const keyLength = keys.length;
                if (keyLength === 0) {
                  return "{}";
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Object]"';
                }
                let whitespace = "";
                let separator = "";
                if (spacer !== "") {
                  indentation += spacer;
                  join = `,
${indentation}`;
                  whitespace = " ";
                }
                let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                if (isTypedArrayWithEntries(value)) {
                  res += stringifyTypedArray(value, join, maximumBreadth);
                  keys = keys.slice(value.length);
                  maximumPropertiesToStringify -= value.length;
                  separator = join;
                }
                if (deterministic) {
                  keys = insertSort(keys);
                }
                stack.push(value);
                for (let i = 0; i < maximumPropertiesToStringify; i++) {
                  const key2 = keys[i];
                  const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
                  if (tmp !== void 0) {
                    res += `${separator}"${strEscape(key2)}":${whitespace}${tmp}`;
                    separator = join;
                  }
                }
                if (keyLength > maximumBreadth) {
                  const removedKeys = keyLength - maximumBreadth;
                  res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
                  separator = join;
                }
                if (spacer !== "" && separator.length > 1) {
                  res = `
${indentation}${res}
${originalIndentation}`;
                }
                stack.pop();
                return `{${res}}`;
              }
              case "number":
                return isFinite(value) ? String(value) : fail ? fail(value) : "null";
              case "boolean":
                return value === true ? "true" : "false";
              case "undefined":
                return void 0;
              case "bigint":
                if (bigint) {
                  return String(value);
                }
              default:
                return fail ? fail(value) : void 0;
            }
          }
          function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
            if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
              value = value.toJSON(key);
            }
            switch (typeof value) {
              case "string":
                return `"${strEscape(value)}"`;
              case "object": {
                if (value === null) {
                  return "null";
                }
                if (stack.indexOf(value) !== -1) {
                  return circularValue;
                }
                const originalIndentation = indentation;
                let res = "";
                let join = ",";
                if (Array.isArray(value)) {
                  if (value.length === 0) {
                    return "[]";
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Array]"';
                  }
                  stack.push(value);
                  if (spacer !== "") {
                    indentation += spacer;
                    res += `
${indentation}`;
                    join = `,
${indentation}`;
                  }
                  const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                  let i = 0;
                  for (; i < maximumValuesToStringify - 1; i++) {
                    const tmp2 = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                    res += tmp2 !== void 0 ? tmp2 : "null";
                    res += join;
                  }
                  const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                  res += tmp !== void 0 ? tmp : "null";
                  if (value.length - 1 > maximumBreadth) {
                    const removedKeys = value.length - maximumBreadth - 1;
                    res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
                  }
                  if (spacer !== "") {
                    res += `
${originalIndentation}`;
                  }
                  stack.pop();
                  return `[${res}]`;
                }
                if (replacer.size === 0) {
                  return "{}";
                }
                stack.push(value);
                let whitespace = "";
                if (spacer !== "") {
                  indentation += spacer;
                  join = `,
${indentation}`;
                  whitespace = " ";
                }
                let separator = "";
                for (const key2 of replacer) {
                  const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
                  if (tmp !== void 0) {
                    res += `${separator}"${strEscape(key2)}":${whitespace}${tmp}`;
                    separator = join;
                  }
                }
                if (spacer !== "" && separator.length > 1) {
                  res = `
${indentation}${res}
${originalIndentation}`;
                }
                stack.pop();
                return `{${res}}`;
              }
              case "number":
                return isFinite(value) ? String(value) : fail ? fail(value) : "null";
              case "boolean":
                return value === true ? "true" : "false";
              case "undefined":
                return void 0;
              case "bigint":
                if (bigint) {
                  return String(value);
                }
              default:
                return fail ? fail(value) : void 0;
            }
          }
          function stringifyIndent(key, value, stack, spacer, indentation) {
            switch (typeof value) {
              case "string":
                return `"${strEscape(value)}"`;
              case "object": {
                if (value === null) {
                  return "null";
                }
                if (typeof value.toJSON === "function") {
                  value = value.toJSON(key);
                  if (typeof value !== "object") {
                    return stringifyIndent(key, value, stack, spacer, indentation);
                  }
                  if (value === null) {
                    return "null";
                  }
                }
                if (stack.indexOf(value) !== -1) {
                  return circularValue;
                }
                const originalIndentation = indentation;
                if (Array.isArray(value)) {
                  if (value.length === 0) {
                    return "[]";
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Array]"';
                  }
                  stack.push(value);
                  indentation += spacer;
                  let res2 = `
${indentation}`;
                  const join2 = `,
${indentation}`;
                  const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                  let i = 0;
                  for (; i < maximumValuesToStringify - 1; i++) {
                    const tmp2 = stringifyIndent(i, value[i], stack, spacer, indentation);
                    res2 += tmp2 !== void 0 ? tmp2 : "null";
                    res2 += join2;
                  }
                  const tmp = stringifyIndent(i, value[i], stack, spacer, indentation);
                  res2 += tmp !== void 0 ? tmp : "null";
                  if (value.length - 1 > maximumBreadth) {
                    const removedKeys = value.length - maximumBreadth - 1;
                    res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
                  }
                  res2 += `
${originalIndentation}`;
                  stack.pop();
                  return `[${res2}]`;
                }
                let keys = Object.keys(value);
                const keyLength = keys.length;
                if (keyLength === 0) {
                  return "{}";
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Object]"';
                }
                indentation += spacer;
                const join = `,
${indentation}`;
                let res = "";
                let separator = "";
                let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                if (isTypedArrayWithEntries(value)) {
                  res += stringifyTypedArray(value, join, maximumBreadth);
                  keys = keys.slice(value.length);
                  maximumPropertiesToStringify -= value.length;
                  separator = join;
                }
                if (deterministic) {
                  keys = insertSort(keys);
                }
                stack.push(value);
                for (let i = 0; i < maximumPropertiesToStringify; i++) {
                  const key2 = keys[i];
                  const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
                  if (tmp !== void 0) {
                    res += `${separator}"${strEscape(key2)}": ${tmp}`;
                    separator = join;
                  }
                }
                if (keyLength > maximumBreadth) {
                  const removedKeys = keyLength - maximumBreadth;
                  res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
                  separator = join;
                }
                if (separator !== "") {
                  res = `
${indentation}${res}
${originalIndentation}`;
                }
                stack.pop();
                return `{${res}}`;
              }
              case "number":
                return isFinite(value) ? String(value) : fail ? fail(value) : "null";
              case "boolean":
                return value === true ? "true" : "false";
              case "undefined":
                return void 0;
              case "bigint":
                if (bigint) {
                  return String(value);
                }
              default:
                return fail ? fail(value) : void 0;
            }
          }
          function stringifySimple(key, value, stack) {
            switch (typeof value) {
              case "string":
                return `"${strEscape(value)}"`;
              case "object": {
                if (value === null) {
                  return "null";
                }
                if (typeof value.toJSON === "function") {
                  value = value.toJSON(key);
                  if (typeof value !== "object") {
                    return stringifySimple(key, value, stack);
                  }
                  if (value === null) {
                    return "null";
                  }
                }
                if (stack.indexOf(value) !== -1) {
                  return circularValue;
                }
                let res = "";
                if (Array.isArray(value)) {
                  if (value.length === 0) {
                    return "[]";
                  }
                  if (maximumDepth < stack.length + 1) {
                    return '"[Array]"';
                  }
                  stack.push(value);
                  const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
                  let i = 0;
                  for (; i < maximumValuesToStringify - 1; i++) {
                    const tmp2 = stringifySimple(i, value[i], stack);
                    res += tmp2 !== void 0 ? tmp2 : "null";
                    res += ",";
                  }
                  const tmp = stringifySimple(i, value[i], stack);
                  res += tmp !== void 0 ? tmp : "null";
                  if (value.length - 1 > maximumBreadth) {
                    const removedKeys = value.length - maximumBreadth - 1;
                    res += `,"... ${getItemCount(removedKeys)} not stringified"`;
                  }
                  stack.pop();
                  return `[${res}]`;
                }
                let keys = Object.keys(value);
                const keyLength = keys.length;
                if (keyLength === 0) {
                  return "{}";
                }
                if (maximumDepth < stack.length + 1) {
                  return '"[Object]"';
                }
                let separator = "";
                let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
                if (isTypedArrayWithEntries(value)) {
                  res += stringifyTypedArray(value, ",", maximumBreadth);
                  keys = keys.slice(value.length);
                  maximumPropertiesToStringify -= value.length;
                  separator = ",";
                }
                if (deterministic) {
                  keys = insertSort(keys);
                }
                stack.push(value);
                for (let i = 0; i < maximumPropertiesToStringify; i++) {
                  const key2 = keys[i];
                  const tmp = stringifySimple(key2, value[key2], stack);
                  if (tmp !== void 0) {
                    res += `${separator}"${strEscape(key2)}":${tmp}`;
                    separator = ",";
                  }
                }
                if (keyLength > maximumBreadth) {
                  const removedKeys = keyLength - maximumBreadth;
                  res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
                }
                stack.pop();
                return `{${res}}`;
              }
              case "number":
                return isFinite(value) ? String(value) : fail ? fail(value) : "null";
              case "boolean":
                return value === true ? "true" : "false";
              case "undefined":
                return void 0;
              case "bigint":
                if (bigint) {
                  return String(value);
                }
              default:
                return fail ? fail(value) : void 0;
            }
          }
          function stringify2(value, replacer, space) {
            if (arguments.length > 1) {
              let spacer = "";
              if (typeof space === "number") {
                spacer = " ".repeat(Math.min(space, 10));
              } else if (typeof space === "string") {
                spacer = space.slice(0, 10);
              }
              if (replacer != null) {
                if (typeof replacer === "function") {
                  return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
                }
                if (Array.isArray(replacer)) {
                  return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
                }
              }
              if (spacer.length !== 0) {
                return stringifyIndent("", value, [], spacer, "");
              }
            }
            return stringifySimple("", value, []);
          }
          return stringify2;
        }
      }
    });
    var require_multistream = __commonJS2({
      "../../node_modules/pino/lib/multistream.js"(exports3, module22) {
        "use strict";
        var metadata = Symbol.for("pino.metadata");
        var { levels } = require_levels();
        var defaultLevels = Object.create(levels);
        defaultLevels.silent = Infinity;
        var DEFAULT_INFO_LEVEL = levels.info;
        function multistream(streamsArray, opts) {
          let counter = 0;
          streamsArray = streamsArray || [];
          opts = opts || { dedupe: false };
          let levels2 = defaultLevels;
          if (opts.levels && typeof opts.levels === "object") {
            levels2 = opts.levels;
          }
          const res = {
            write,
            add,
            flushSync,
            end,
            minLevel: 0,
            streams: [],
            clone,
            [metadata]: true
          };
          if (Array.isArray(streamsArray)) {
            streamsArray.forEach(add, res);
          } else {
            add.call(res, streamsArray);
          }
          streamsArray = null;
          return res;
          function write(data) {
            let dest;
            const level2 = this.lastLevel;
            const { streams } = this;
            let recordedLevel = 0;
            let stream4;
            for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
              dest = streams[i];
              if (dest.level <= level2) {
                if (recordedLevel !== 0 && recordedLevel !== dest.level) {
                  break;
                }
                stream4 = dest.stream;
                if (stream4[metadata]) {
                  const { lastTime, lastMsg, lastObj, lastLogger } = this;
                  stream4.lastLevel = level2;
                  stream4.lastTime = lastTime;
                  stream4.lastMsg = lastMsg;
                  stream4.lastObj = lastObj;
                  stream4.lastLogger = lastLogger;
                }
                stream4.write(data);
                if (opts.dedupe) {
                  recordedLevel = dest.level;
                }
              } else if (!opts.dedupe) {
                break;
              }
            }
          }
          function flushSync() {
            for (const { stream: stream4 } of this.streams) {
              if (typeof stream4.flushSync === "function") {
                stream4.flushSync();
              }
            }
          }
          function add(dest) {
            if (!dest) {
              return res;
            }
            const isStream2 = typeof dest.write === "function" || dest.stream;
            const stream_ = dest.write ? dest : dest.stream;
            if (!isStream2) {
              throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
            }
            const { streams } = this;
            let level2;
            if (typeof dest.levelVal === "number") {
              level2 = dest.levelVal;
            } else if (typeof dest.level === "string") {
              level2 = levels2[dest.level];
            } else if (typeof dest.level === "number") {
              level2 = dest.level;
            } else {
              level2 = DEFAULT_INFO_LEVEL;
            }
            const dest_ = {
              stream: stream_,
              level: level2,
              levelVal: void 0,
              id: counter++
            };
            streams.unshift(dest_);
            streams.sort(compareByLevel);
            this.minLevel = streams[0].level;
            return res;
          }
          function end() {
            for (const { stream: stream4 } of this.streams) {
              if (typeof stream4.flushSync === "function") {
                stream4.flushSync();
              }
              stream4.end();
            }
          }
          function clone(level2) {
            const streams = new Array(this.streams.length);
            for (let i = 0; i < streams.length; i++) {
              streams[i] = {
                level: level2,
                stream: this.streams[i].stream
              };
            }
            return {
              write,
              add,
              minLevel: level2,
              streams,
              clone,
              flushSync,
              [metadata]: true
            };
          }
        }
        function compareByLevel(a, b) {
          return a.level - b.level;
        }
        function initLoopVar(length22, dedupe) {
          return dedupe ? length22 - 1 : 0;
        }
        function adjustLoopVar(i, dedupe) {
          return dedupe ? i - 1 : i + 1;
        }
        function checkLoopVar(i, length22, dedupe) {
          return dedupe ? i >= 0 : i < length22;
        }
        module22.exports = multistream;
      }
    });
    var require_pino = __commonJS2({
      "../../node_modules/pino/pino.js"(exports3, module22) {
        "use strict";
        var os = require("os");
        var stdSerializers = require_pino_std_serializers();
        var caller = require_caller();
        var redaction = require_redaction();
        var time = require_time();
        var proto = require_proto();
        var symbols = require_symbols();
        var { configure } = require_safe_stable_stringify();
        var { assertDefaultLevelFound, mappings, genLsCache, levels } = require_levels();
        var {
          createArgsNormalizer,
          asChindings,
          buildSafeSonicBoom,
          buildFormatters,
          stringify,
          normalizeDestFileDescriptor,
          noop: noop2
        } = require_tools();
        var { version: version22 } = require_meta();
        var {
          chindingsSym,
          redactFmtSym,
          serializersSym,
          timeSym,
          timeSliceIndexSym,
          streamSym,
          stringifySym,
          stringifySafeSym,
          stringifiersSym,
          setLevelSym,
          endSym,
          formatOptsSym,
          messageKeySym,
          errorKeySym,
          nestedKeySym,
          mixinSym,
          useOnlyCustomLevelsSym,
          formattersSym,
          hooksSym,
          nestedKeyStrSym,
          mixinMergeStrategySym
        } = symbols;
        var { epochTime, nullTime } = time;
        var { pid } = process;
        var hostname = os.hostname();
        var defaultErrorSerializer = stdSerializers.err;
        var defaultOptions2 = {
          level: "info",
          levels,
          messageKey: "msg",
          errorKey: "err",
          nestedKey: null,
          enabled: true,
          base: { pid, hostname },
          serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
            err: defaultErrorSerializer
          }),
          formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
            bindings(bindings) {
              return bindings;
            },
            level(label, number) {
              return { level: number };
            }
          }),
          hooks: {
            logMethod: void 0
          },
          timestamp: epochTime,
          name: void 0,
          redact: null,
          customLevels: null,
          useOnlyCustomLevels: false,
          depthLimit: 5,
          edgeLimit: 100
        };
        var normalize = createArgsNormalizer(defaultOptions2);
        var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
        function pino2(...args) {
          const instance = {};
          const { opts, stream: stream4 } = normalize(instance, caller(), ...args);
          const {
            redact,
            crlf,
            serializers: serializers2,
            timestamp,
            messageKey,
            errorKey,
            nestedKey,
            base: base33,
            name: name3,
            level: level2,
            customLevels,
            mixin,
            mixinMergeStrategy,
            useOnlyCustomLevels,
            formatters,
            hooks,
            depthLimit,
            edgeLimit,
            onChild
          } = opts;
          const stringifySafe = configure({
            maximumDepth: depthLimit,
            maximumBreadth: edgeLimit
          });
          const allFormatters = buildFormatters(
            formatters.level,
            formatters.bindings,
            formatters.log
          );
          const stringifiers = redact ? redaction(redact, stringify) : {};
          const stringifyFn = stringify.bind({
            [stringifySafeSym]: stringifySafe
          });
          const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
          const end = "}" + (crlf ? "\r\n" : "\n");
          const coreChindings = asChindings.bind(null, {
            [chindingsSym]: "",
            [serializersSym]: serializers2,
            [stringifiersSym]: stringifiers,
            [stringifySym]: stringify,
            [stringifySafeSym]: stringifySafe,
            [formattersSym]: allFormatters
          });
          let chindings = "";
          if (base33 !== null) {
            if (name3 === void 0) {
              chindings = coreChindings(base33);
            } else {
              chindings = coreChindings(Object.assign({}, base33, { name: name3 }));
            }
          }
          const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
          const timeSliceIndex = time2().indexOf(":") + 1;
          if (useOnlyCustomLevels && !customLevels)
            throw Error("customLevels is required if useOnlyCustomLevels is set true");
          if (mixin && typeof mixin !== "function")
            throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
          assertDefaultLevelFound(level2, customLevels, useOnlyCustomLevels);
          const levels2 = mappings(customLevels, useOnlyCustomLevels);
          Object.assign(instance, {
            levels: levels2,
            [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
            [streamSym]: stream4,
            [timeSym]: time2,
            [timeSliceIndexSym]: timeSliceIndex,
            [stringifySym]: stringify,
            [stringifySafeSym]: stringifySafe,
            [stringifiersSym]: stringifiers,
            [endSym]: end,
            [formatOptsSym]: formatOpts,
            [messageKeySym]: messageKey,
            [errorKeySym]: errorKey,
            [nestedKeySym]: nestedKey,
            [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
            [serializersSym]: serializers2,
            [mixinSym]: mixin,
            [mixinMergeStrategySym]: mixinMergeStrategy,
            [chindingsSym]: chindings,
            [formattersSym]: allFormatters,
            [hooksSym]: hooks,
            silent: noop2,
            onChild
          });
          Object.setPrototypeOf(instance, proto());
          genLsCache(instance);
          instance[setLevelSym](level2);
          return instance;
        }
        module22.exports = pino2;
        module22.exports.destination = (dest = process.stdout.fd) => {
          if (typeof dest === "object") {
            dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
            return buildSafeSonicBoom(dest);
          } else {
            return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
          }
        };
        module22.exports.transport = require_transport();
        module22.exports.multistream = require_multistream();
        module22.exports.levels = mappings();
        module22.exports.stdSerializers = serializers;
        module22.exports.stdTimeFunctions = Object.assign({}, time);
        module22.exports.symbols = symbols;
        module22.exports.version = version22;
        module22.exports.default = pino2;
        module22.exports.pino = pino2;
      }
    });
    var src_exports3 = {};
    __export2(src_exports3, {
      AsyncBuffer: () => AsyncBuffer,
      AsyncBufferFullError: () => AsyncBufferFullError,
      DAY: () => DAY,
      HOUR: () => HOUR2,
      MINUTE: () => MINUTE,
      MaxSizeChecker: () => MaxSizeChecker,
      SECOND: () => SECOND,
      TID: () => TID,
      VerifyCidError: () => VerifyCidError,
      VerifyCidTransform: () => VerifyCidTransform,
      allComplete: () => allComplete,
      asyncFilter: () => asyncFilter,
      b64UrlToUtf8: () => b64UrlToUtf8,
      bailableWait: () => bailableWait,
      byteIterableToStream: () => byteIterableToStream,
      bytesToStream: () => bytesToStream,
      cborBytesToRecord: () => cborBytesToRecord,
      cborDecode: () => cborDecode,
      cborDecodeMulti: () => cborDecodeMulti,
      cborEncode: () => cborEncode,
      check: () => check_exports,
      chunkArray: () => chunkArray,
      cidForCbor: () => cidForCbor4,
      cloneStream: () => cloneStream,
      createDeferrable: () => createDeferrable,
      createDeferrables: () => createDeferrables,
      dataToCborBlock: () => dataToCborBlock,
      dedupeStrs: () => dedupeStrs,
      def: () => def2,
      errHasMsg: () => errHasMsg,
      fileExists: () => fileExists,
      flattenUint8Arrays: () => flattenUint8Arrays,
      forwardStreamErrors: () => forwardStreamErrors,
      graphemeLen: () => graphemeLen,
      ipldEquals: () => ipldEquals,
      ipldToJson: () => ipldToJson,
      isErrnoException: () => isErrnoException,
      jitter: () => jitter,
      jsonToIpld: () => jsonToIpld,
      noUndefinedVals: () => noUndefinedVals,
      parseIntWithFallback: () => parseIntWithFallback,
      parseLanguage: () => parseLanguage,
      range: () => range,
      readFromGenerator: () => readFromGenerator,
      s32decode: () => s32decode,
      s32encode: () => s32encode,
      schema: () => schema,
      sha256RawToCid: () => sha256RawToCid,
      sha256ToCid: () => sha256ToCid,
      streamSize: () => streamSize,
      streamToBuffer: () => streamToBuffer,
      streamToBytes: () => streamToBytes,
      subsystemLogger: () => subsystemLogger,
      utf8Len: () => utf8Len,
      utf8ToB64Url: () => utf8ToB64Url,
      util: () => util_exports,
      validateLanguage: () => validateLanguage,
      verifyCidForBytes: () => verifyCidForBytes,
      wait: () => wait
    });
    module2.exports = __toCommonJS2(src_exports3);
    var check_exports = {};
    __export2(check_exports, {
      assure: () => assure,
      is: () => is2,
      isObject: () => isObject2
    });
    var is2 = (obj, def22) => {
      return def22.safeParse(obj).success;
    };
    var assure = (def22, obj) => {
      return def22.parse(obj);
    };
    var isObject2 = (obj) => {
      return typeof obj === "object" && obj !== null;
    };
    var util_exports = {};
    __export2(util_exports, {
      asyncFilter: () => asyncFilter,
      bailableWait: () => bailableWait,
      chunkArray: () => chunkArray,
      dedupeStrs: () => dedupeStrs,
      errHasMsg: () => errHasMsg,
      flattenUint8Arrays: () => flattenUint8Arrays,
      isErrnoException: () => isErrnoException,
      jitter: () => jitter,
      noUndefinedVals: () => noUndefinedVals,
      parseIntWithFallback: () => parseIntWithFallback,
      range: () => range,
      s32decode: () => s32decode,
      s32encode: () => s32encode,
      streamToBuffer: () => streamToBuffer,
      wait: () => wait
    });
    var noUndefinedVals = (obj) => {
      Object.keys(obj).forEach((k) => {
        if (obj[k] === void 0) {
          delete obj[k];
        }
      });
      return obj;
    };
    var jitter = (maxMs) => {
      return Math.round((Math.random() - 0.5) * maxMs * 2);
    };
    var wait = (ms) => {
      return new Promise((res) => setTimeout(res, ms));
    };
    var bailableWait = (ms) => {
      let bail;
      const waitPromise = new Promise((res) => {
        const timeout = setTimeout(res, ms);
        bail = () => {
          clearTimeout(timeout);
          res();
        };
      });
      return { bail, wait: () => waitPromise };
    };
    var flattenUint8Arrays = (arrs) => {
      const length22 = arrs.reduce((acc, cur) => {
        return acc + cur.length;
      }, 0);
      const flattened = new Uint8Array(length22);
      let offset = 0;
      arrs.forEach((arr) => {
        flattened.set(arr, offset);
        offset += arr.length;
      });
      return flattened;
    };
    var streamToBuffer = async (stream4) => {
      const arrays = [];
      for await (const chunk of stream4) {
        arrays.push(chunk);
      }
      return flattenUint8Arrays(arrays);
    };
    var S32_CHAR = "234567abcdefghijklmnopqrstuvwxyz";
    var s32encode = (i) => {
      let s = "";
      while (i) {
        const c = i % 32;
        i = Math.floor(i / 32);
        s = S32_CHAR.charAt(c) + s;
      }
      return s;
    };
    var s32decode = (s) => {
      let i = 0;
      for (const c of s) {
        i = i * 32 + S32_CHAR.indexOf(c);
      }
      return i;
    };
    var asyncFilter = async (arr, fn) => {
      const results = await Promise.all(arr.map((t) => fn(t)));
      return arr.filter((_, i) => results[i]);
    };
    var isErrnoException = (err) => {
      return !!err && err["code"];
    };
    var errHasMsg = (err, msg) => {
      return !!err && typeof err === "object" && err["message"] === msg;
    };
    var chunkArray = (arr, chunkSize) => {
      return arr.reduce((acc, cur, i) => {
        const chunkI = Math.floor(i / chunkSize);
        if (!acc[chunkI]) {
          acc[chunkI] = [];
        }
        acc[chunkI].push(cur);
        return acc;
      }, []);
    };
    var range = (num) => {
      const nums = [];
      for (let i = 0; i < num; i++) {
        nums.push(i);
      }
      return nums;
    };
    var dedupeStrs = (strs) => {
      return [...new Set(strs)];
    };
    var parseIntWithFallback = (value, fallback) => {
      const parsed = parseInt(value || "", 10);
      return isNaN(parsed) ? fallback : parsed;
    };
    var readFromGenerator = async (gen, isDone, waitFor = Promise.resolve(), maxLength = Number.MAX_SAFE_INTEGER) => {
      const evts = [];
      let bail;
      let hasBroke = false;
      const awaitDone = async () => {
        if (await isDone(evts.at(-1))) {
          return true;
        }
        const bailable = bailableWait(20);
        await bailable.wait();
        bail = bailable.bail;
        if (hasBroke)
          return false;
        return await awaitDone();
      };
      const breakOn = new Promise((resolve) => {
        waitFor.then(() => {
          awaitDone().then(() => resolve());
        });
      });
      try {
        while (evts.length < maxLength) {
          const maybeEvt = await Promise.race([gen.next(), breakOn]);
          if (!maybeEvt)
            break;
          const evt = maybeEvt;
          if (evt.done)
            break;
          evts.push(evt.value);
        }
      } finally {
        hasBroke = true;
        bail && bail();
      }
      return evts;
    };
    var createDeferrable = () => {
      let resolve;
      const promise = new Promise((res) => {
        resolve = () => res();
      });
      return { resolve, complete: promise };
    };
    var createDeferrables = (count) => {
      const list = [];
      for (let i = 0; i < count; i++) {
        list.push(createDeferrable());
      }
      return list;
    };
    var allComplete = async (deferrables) => {
      await Promise.all(deferrables.map((d) => d.complete));
    };
    var AsyncBuffer = class {
      constructor(maxSize) {
        this.maxSize = maxSize;
        this.buffer = [];
        this.promise = Promise.resolve();
        this.resolve = () => null;
        this.resetPromise();
      }
      get curr() {
        return this.buffer;
      }
      get size() {
        return this.buffer.length;
      }
      resetPromise() {
        this.promise = new Promise((r) => this.resolve = r);
      }
      push(item) {
        this.buffer.push(item);
        this.resolve();
      }
      pushMany(items) {
        items.forEach((i) => this.buffer.push(i));
        this.resolve();
      }
      async *events() {
        while (true) {
          await this.promise;
          if (this.maxSize && this.size > this.maxSize) {
            throw new AsyncBufferFullError(this.maxSize);
          }
          const [first, ...rest] = this.buffer;
          if (first) {
            this.buffer = rest;
            yield first;
          } else {
            this.resetPromise();
          }
        }
      }
    };
    var AsyncBufferFullError = class extends Error {
      constructor(maxSize) {
        super(`ReachedMaxBufferSize: ${maxSize}`);
      }
    };
    var TID_LEN = 13;
    var lastTimestamp = 0;
    var timestampCount = 0;
    var clockid = null;
    function dedash(str) {
      return str.replaceAll("-", "");
    }
    var TID = class {
      constructor(str) {
        const noDashes = dedash(str);
        if (noDashes.length !== TID_LEN) {
          throw new Error(`Poorly formatted TID: ${noDashes.length} length`);
        }
        this.str = noDashes;
      }
      static next() {
        const time = Math.max(Date.now(), lastTimestamp);
        if (time === lastTimestamp) {
          timestampCount++;
        }
        lastTimestamp = time;
        const timestamp = time * 1e3 + timestampCount;
        if (clockid === null) {
          clockid = Math.floor(Math.random() * 32);
        }
        return TID.fromTime(timestamp, clockid);
      }
      static nextStr() {
        return TID.next().toString();
      }
      static fromTime(timestamp, clockid2) {
        const str = `${s32encode(timestamp)}${s32encode(clockid2).padStart(2, "2")}`;
        return new TID(str);
      }
      static fromStr(str) {
        return new TID(str);
      }
      static oldestFirst(a, b) {
        return a.compareTo(b);
      }
      static newestFirst(a, b) {
        return b.compareTo(a);
      }
      static is(str) {
        return dedash(str).length === TID_LEN;
      }
      timestamp() {
        return s32decode(this.str.slice(0, 11));
      }
      clockid() {
        return s32decode(this.str.slice(11, 13));
      }
      formatted() {
        const str = this.toString();
        return `${str.slice(0, 4)}-${str.slice(4, 7)}-${str.slice(
          7,
          11
        )}-${str.slice(11, 13)}`;
      }
      toString() {
        return this.str;
      }
      compareTo(other) {
        if (this.str > other.str)
          return 1;
        if (this.str < other.str)
          return -1;
        return 0;
      }
      equals(other) {
        return this.str === other.str;
      }
      newerThan(other) {
        return this.compareTo(other) > 0;
      }
      olderThan(other) {
        return this.compareTo(other) < 0;
      }
    };
    var encode_12 = encode9;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode9(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode9.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode7 = read2;
    var MSB$12 = 128;
    var REST$12 = 127;
    function read2(buf22, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf22.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf22[counter++];
        res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$12);
      read2.bytes = counter - offset;
      return res;
    }
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    var length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    var varint2 = {
      encode: encode_12,
      decode: decode7,
      encodingLength: length2
    };
    var _brrp_varint2 = varint2;
    var varint_default2 = _brrp_varint2;
    var decode22 = (data, offset = 0) => {
      const code4 = varint_default2.decode(data, offset);
      return [
        code4,
        varint_default2.decode.bytes
      ];
    };
    var encodeTo2 = (int, target2, offset = 0) => {
      varint_default2.encode(int, target2, offset);
      return target2;
    };
    var encodingLength2 = (int) => {
      return varint_default2.encodingLength(int);
    };
    var digest_exports2 = {};
    __export2(digest_exports2, {
      Digest: () => Digest2,
      create: () => create2,
      decode: () => decode32,
      equals: () => equals22
    });
    var empty2 = new Uint8Array(0);
    var equals4 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce2 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var fromString4 = (str) => new TextEncoder().encode(str);
    var toString6 = (b) => new TextDecoder().decode(b);
    var create2 = (code4, digest22) => {
      const size = digest22.byteLength;
      const sizeOffset = encodingLength2(code4);
      const digestOffset = sizeOffset + encodingLength2(size);
      const bytes = new Uint8Array(digestOffset + size);
      encodeTo2(code4, bytes, 0);
      encodeTo2(size, bytes, sizeOffset);
      bytes.set(digest22, digestOffset);
      return new Digest2(code4, size, digest22, bytes);
    };
    var decode32 = (multihash) => {
      const bytes = coerce2(multihash);
      const [code4, sizeOffset] = decode22(bytes);
      const [size, digestOffset] = decode22(bytes.subarray(sizeOffset));
      const digest22 = bytes.subarray(sizeOffset + digestOffset);
      if (digest22.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest2(code4, size, digest22, bytes);
    };
    var equals22 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals4(a.bytes, b.bytes);
      }
    };
    var Digest2 = class {
      constructor(code4, size, digest22, bytes) {
        this.code = code4;
        this.size = size;
        this.digest = digest22;
        this.bytes = bytes;
      }
    };
    var base58_exports2 = {};
    __export2(base58_exports2, {
      base58btc: () => base58btc2,
      base58flickr: () => base58flickr2
    });
    function base3(ALPHABET2, name3) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET2.length; i++) {
        var x = ALPHABET2.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET2.length;
      var LEADER = ALPHABET2.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode92(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length22 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length22) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length22 = i2;
          pbegin++;
        }
        var it2 = size - length22;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET2.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length22 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length22) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length22 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length22;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode9(string22) {
        var buffer22 = decodeUnsafe(string22);
        if (buffer22) {
          return buffer22;
        }
        throw new Error(`Non-${name3} character`);
      }
      return {
        encode: encode92,
        decodeUnsafe,
        decode: decode9
      };
    }
    var src2 = base3;
    var _brrp__multiformats_scope_baseX2 = src2;
    var base_x_default2 = _brrp__multiformats_scope_baseX2;
    var Encoder2 = class {
      constructor(name3, prefix, baseEncode) {
        this.name = name3;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder2 = class {
      constructor(name3, prefix, baseDecode) {
        this.name = name3;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder2) {
        return or2(this, decoder2);
      }
    };
    var ComposedDecoder2 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder2) {
        return or2(this, decoder2);
      }
      decode(input) {
        const prefix = input[0];
        const decoder2 = this.decoders[prefix];
        if (decoder2) {
          return decoder2.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or2 = (left, right) => new ComposedDecoder2({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    var Codec2 = class {
      constructor(name3, prefix, baseEncode, baseDecode) {
        this.name = name3;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder2(name3, prefix, baseEncode);
        this.decoder = new Decoder2(name3, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from3 = ({ name: name3, prefix, encode: encode92, decode: decode9 }) => new Codec2(name3, prefix, encode92, decode9);
    var baseX2 = ({ prefix, name: name3, alphabet: alphabet22 }) => {
      const { encode: encode92, decode: decode9 } = base_x_default2(alphabet22, name3);
      return from3({
        prefix,
        name: name3,
        encode: encode92,
        decode: (text) => coerce2(decode9(text))
      });
    };
    var decode42 = (string22, alphabet22, bitsPerChar, name3) => {
      const codes = {};
      for (let i = 0; i < alphabet22.length; ++i) {
        codes[alphabet22[i]] = i;
      }
      let end = string22.length;
      while (string22[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer22 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string22[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name3} character`);
        }
        buffer22 = buffer22 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer22 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer22 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode22 = (data, alphabet22, bitsPerChar) => {
      const pad = alphabet22[alphabet22.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer22 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer22 = buffer22 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet22[mask & buffer22 >> bits];
        }
      }
      if (bits) {
        out += alphabet22[mask & buffer22 << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46482 = ({ name: name3, prefix, bitsPerChar, alphabet: alphabet22 }) => {
      return from3({
        prefix,
        name: name3,
        encode(input) {
          return encode22(input, alphabet22, bitsPerChar);
        },
        decode(input) {
          return decode42(input, alphabet22, bitsPerChar, name3);
        }
      });
    };
    var base58btc2 = baseX2({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr2 = baseX2({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    var base32_exports2 = {};
    __export2(base32_exports2, {
      base32: () => base322,
      base32hex: () => base32hex2,
      base32hexpad: () => base32hexpad2,
      base32hexpadupper: () => base32hexpadupper2,
      base32hexupper: () => base32hexupper2,
      base32pad: () => base32pad2,
      base32padupper: () => base32padupper2,
      base32upper: () => base32upper2,
      base32z: () => base32z2
    });
    var base322 = rfc46482({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper2 = rfc46482({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad2 = rfc46482({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper2 = rfc46482({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex2 = rfc46482({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper2 = rfc46482({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad2 = rfc46482({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper2 = rfc46482({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z2 = rfc46482({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    var CID2 = class {
      constructor(version22, code4, multihash, bytes) {
        this.code = code4;
        this.version = version22;
        this.multihash = multihash;
        this.bytes = bytes;
        this.byteOffset = bytes.byteOffset;
        this.byteLength = bytes.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden2,
          byteLength: hidden2,
          code: readonly2,
          version: readonly2,
          multihash: readonly2,
          bytes: readonly2,
          _baseCache: hidden2,
          asCID: hidden2
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code4, multihash } = this;
            if (code4 !== DAG_PB_CODE2) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE2) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID2.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code4, digest: digest22 } = this.multihash;
            const multihash = create2(code4, digest22);
            return CID2.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals22(this.multihash, other.multihash);
      }
      toString(base33) {
        const { bytes, version: version22, _baseCache } = this;
        switch (version22) {
          case 0:
            return toStringV02(bytes, _baseCache, base33 || base58btc2.encoder);
          default:
            return toStringV12(bytes, _baseCache, base33 || base322.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate2(/^0\.0/, IS_CID_DEPRECATION2);
        return !!(value && (value[cidSymbol2] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID2) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version22, code: code4, multihash, bytes } = value;
          return new CID2(version22, code4, multihash, bytes || encodeCID2(version22, code4, multihash.bytes));
        } else if (value != null && value[cidSymbol2] === true) {
          const { version: version22, multihash, code: code4 } = value;
          const digest22 = decode32(multihash);
          return CID2.create(version22, code4, digest22);
        } else {
          return null;
        }
      }
      static create(version22, code4, digest22) {
        if (typeof code4 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version22) {
          case 0: {
            if (code4 !== DAG_PB_CODE2) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
            } else {
              return new CID2(version22, code4, digest22, digest22.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID2(version22, code4, digest22.bytes);
            return new CID2(version22, code4, digest22, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest22) {
        return CID2.create(0, DAG_PB_CODE2, digest22);
      }
      static createV1(code4, digest22) {
        return CID2.create(1, code4, digest22);
      }
      static decode(bytes) {
        const [cid2, remainder] = CID2.decodeFirst(bytes);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid2;
      }
      static decodeFirst(bytes) {
        const specs = CID2.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce2(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest22 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid2 = specs.version === 0 ? CID2.createV0(digest22) : CID2.createV1(specs.codec, digest22);
        return [
          cid2,
          bytes.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length22] = decode22(initialBytes.subarray(offset));
          offset += length22;
          return i;
        };
        let version22 = next();
        let codec = DAG_PB_CODE2;
        if (version22 === 18) {
          version22 = 0;
          offset = 0;
        } else if (version22 === 1) {
          codec = next();
        }
        if (version22 !== 0 && version22 !== 1) {
          throw new RangeError(`Invalid CID version ${version22}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version22,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base33) {
        const [prefix, bytes] = parseCIDtoBytes2(source, base33);
        const cid2 = CID2.decode(bytes);
        cid2._baseCache.set(prefix, source);
        return cid2;
      }
    };
    var parseCIDtoBytes2 = (source, base33) => {
      switch (source[0]) {
        case "Q": {
          const decoder2 = base33 || base58btc2;
          return [
            base58btc2.prefix,
            decoder2.decode(`${base58btc2.prefix}${source}`)
          ];
        }
        case base58btc2.prefix: {
          const decoder2 = base33 || base58btc2;
          return [
            base58btc2.prefix,
            decoder2.decode(source)
          ];
        }
        case base322.prefix: {
          const decoder2 = base33 || base322;
          return [
            base322.prefix,
            decoder2.decode(source)
          ];
        }
        default: {
          if (base33 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base33.decode(source)
          ];
        }
      }
    };
    var toStringV02 = (bytes, cache, base33) => {
      const { prefix } = base33;
      if (prefix !== base58btc2.prefix) {
        throw Error(`Cannot string encode V0 in ${base33.name} encoding`);
      }
      const cid2 = cache.get(prefix);
      if (cid2 == null) {
        const cid22 = base33.encode(bytes).slice(1);
        cache.set(prefix, cid22);
        return cid22;
      } else {
        return cid2;
      }
    };
    var toStringV12 = (bytes, cache, base33) => {
      const { prefix } = base33;
      const cid2 = cache.get(prefix);
      if (cid2 == null) {
        const cid22 = base33.encode(bytes);
        cache.set(prefix, cid22);
        return cid22;
      } else {
        return cid2;
      }
    };
    var DAG_PB_CODE2 = 112;
    var SHA_256_CODE2 = 18;
    var encodeCID2 = (version22, code4, multihash) => {
      const codeOffset = encodingLength2(version22);
      const hashOffset = codeOffset + encodingLength2(code4);
      const bytes = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo2(version22, bytes, 0);
      encodeTo2(code4, bytes, codeOffset);
      bytes.set(multihash, hashOffset);
      return bytes;
    };
    var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
    var readonly2 = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden2 = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version2 = "0.0.0-dev";
    var deprecate2 = (range2, message) => {
      if (range2.test(version2)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    var IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    function equals32(a, b) {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    var identity_exports3 = {};
    __export2(identity_exports3, {
      identity: () => identity3
    });
    var identity3 = from3({
      prefix: "\0",
      name: "identity",
      encode: (buf22) => toString6(buf22),
      decode: (str) => fromString4(str)
    });
    var base2_exports2 = {};
    __export2(base2_exports2, {
      base2: () => base22
    });
    var base22 = rfc46482({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    var base8_exports2 = {};
    __export2(base8_exports2, {
      base8: () => base82
    });
    var base82 = rfc46482({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    var base10_exports2 = {};
    __export2(base10_exports2, {
      base10: () => base102
    });
    var base102 = baseX2({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    var base16_exports2 = {};
    __export2(base16_exports2, {
      base16: () => base162,
      base16upper: () => base16upper2
    });
    var base162 = rfc46482({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper2 = rfc46482({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    var base36_exports2 = {};
    __export2(base36_exports2, {
      base36: () => base362,
      base36upper: () => base36upper2
    });
    var base362 = baseX2({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper2 = baseX2({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    var base64_exports2 = {};
    __export2(base64_exports2, {
      base64: () => base642,
      base64pad: () => base64pad2,
      base64url: () => base64url2,
      base64urlpad: () => base64urlpad2
    });
    var base642 = rfc46482({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad2 = rfc46482({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url2 = rfc46482({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad2 = rfc46482({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    var base256emoji_exports2 = {};
    __export2(base256emoji_exports2, {
      base256emoji: () => base256emoji2
    });
    var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    var alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode32(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars2[c];
        return p;
      }, "");
    }
    function decode52(str) {
      const byts = [];
      for (const char of str) {
        const byt = alphabetCharsToBytes2[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji2 = from3({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode32,
      decode: decode52
    });
    var sha2_exports2 = {};
    __export2(sha2_exports2, {
      sha256: () => sha2563,
      sha512: () => sha5122
    });
    var import_crypto3 = __toESM2(require("crypto"), 1);
    var from22 = ({ name: name3, code: code4, encode: encode92 }) => new Hasher2(name3, code4, encode92);
    var Hasher2 = class {
      constructor(name3, code4, encode92) {
        this.name = name3;
        this.code = code4;
        this.encode = encode92;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest22) => create2(this.code, digest22));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var sha2563 = from22({
      name: "sha2-256",
      code: 18,
      encode: (input) => coerce2(import_crypto3.default.createHash("sha256").update(input).digest())
    });
    var sha5122 = from22({
      name: "sha2-512",
      code: 19,
      encode: (input) => coerce2(import_crypto3.default.createHash("sha512").update(input).digest())
    });
    var identity_exports22 = {};
    __export2(identity_exports22, {
      identity: () => identity22
    });
    var code2 = 0;
    var name2 = "identity";
    var encode42 = coerce2;
    var digest2 = (input) => create2(code2, encode42(input));
    var identity22 = {
      code: code2,
      name: name2,
      encode: encode42,
      digest: digest2
    };
    var code22 = 85;
    var textEncoder4 = new TextEncoder();
    var textDecoder3 = new TextDecoder();
    var bases2 = {
      ...identity_exports3,
      ...base2_exports2,
      ...base8_exports2,
      ...base10_exports2,
      ...base16_exports2,
      ...base32_exports2,
      ...base36_exports2,
      ...base58_exports2,
      ...base64_exports2,
      ...base256emoji_exports2
    };
    var hashes2 = {
      ...sha2_exports2,
      ...identity_exports22
    };
    function createCodec2(name3, prefix, encode92, decode9) {
      return {
        name: name3,
        prefix,
        encoder: {
          name: name3,
          prefix,
          encode: encode92
        },
        decoder: { decode: decode9 }
      };
    }
    var string2 = createCodec2("utf8", "u", (buf22) => {
      const decoder2 = new TextDecoder("utf8");
      return "u" + decoder2.decode(buf22);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii2 = createCodec2("ascii", "a", (buf22) => {
      let string22 = "a";
      for (let i = 0; i < buf22.length; i++) {
        string22 += String.fromCharCode(buf22[i]);
      }
      return string22;
    }, (str) => {
      str = str.substring(1);
      const buf22 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf22[i] = str.charCodeAt(i);
      }
      return buf22;
    });
    var BASES2 = {
      utf8: string2,
      "utf-8": string2,
      hex: bases2.base16,
      latin1: ascii2,
      ascii: ascii2,
      binary: ascii2,
      ...bases2
    };
    var bases_default2 = BASES2;
    function fromString22(string22, encoding = "utf8") {
      const base33 = bases_default2[encoding];
      if (!base33) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base33.decoder.decode(`${base33.prefix}${string22}`);
    }
    function toString22(array, encoding = "utf8") {
      const base33 = bases_default2[encoding];
      if (!base33) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base33.encoder.encode(array).substring(1);
    }
    var jsonToIpld = (val) => {
      if (Array.isArray(val)) {
        return val.map((item) => jsonToIpld(item));
      }
      if (val && typeof val === "object") {
        if (typeof val["$link"] === "string" && Object.keys(val).length === 1) {
          return CID2.parse(val["$link"]);
        }
        if (typeof val["$bytes"] === "string" && Object.keys(val).length === 1) {
          return fromString22(val["$bytes"], "base64");
        }
        const toReturn = {};
        for (const key of Object.keys(val)) {
          toReturn[key] = jsonToIpld(val[key]);
        }
        return toReturn;
      }
      return val;
    };
    var ipldToJson = (val) => {
      if (Array.isArray(val)) {
        return val.map((item) => ipldToJson(item));
      }
      if (val && typeof val === "object") {
        if (val instanceof Uint8Array) {
          return {
            $bytes: toString22(val, "base64")
          };
        }
        if (CID2.asCID(val)) {
          return {
            $link: val.toString()
          };
        }
        const toReturn = {};
        for (const key of Object.keys(val)) {
          toReturn[key] = ipldToJson(val[key]);
        }
        return toReturn;
      }
      return val;
    };
    var ipldEquals = (a, b) => {
      if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length)
          return false;
        for (let i = 0; i < a.length; i++) {
          if (!ipldEquals(a[i], b[i]))
            return false;
        }
        return true;
      }
      if (a && b && typeof a === "object" && typeof b === "object") {
        if (a instanceof Uint8Array && b instanceof Uint8Array) {
          return equals32(a, b);
        }
        if (CID2.asCID(a) && CID2.asCID(b)) {
          return CID2.asCID(a)?.equals(CID2.asCID(b));
        }
        if (Object.keys(a).length !== Object.keys(b).length)
          return false;
        for (const key of Object.keys(a)) {
          if (!ipldEquals(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a === b;
    };
    var util3;
    (function(util22) {
      util22.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util22.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util22.assertNever = assertNever;
      util22.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util22.getValidEnumValues = (obj) => {
        const validKeys = util22.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util22.objectValues(filtered);
      };
      util22.objectValues = (obj) => {
        return util22.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util22.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util22.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util22.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util22.joinValues = joinValues;
      util22.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util3 || (util3 = {}));
    var objectUtil2;
    (function(objectUtil22) {
      objectUtil22.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
        };
      };
    })(objectUtil2 || (objectUtil2 = {}));
    var ZodParsedType2 = util3.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType2 = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType2.undefined;
        case "string":
          return ZodParsedType2.string;
        case "number":
          return isNaN(data) ? ZodParsedType2.nan : ZodParsedType2.number;
        case "boolean":
          return ZodParsedType2.boolean;
        case "function":
          return ZodParsedType2.function;
        case "bigint":
          return ZodParsedType2.bigint;
        case "symbol":
          return ZodParsedType2.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType2.array;
          }
          if (data === null) {
            return ZodParsedType2.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType2.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType2.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType2.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType2.date;
          }
          return ZodParsedType2.object;
        default:
          return ZodParsedType2.unknown;
      }
    };
    var ZodIssueCode2 = util3.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    var ZodError2 = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util3.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError2.create = (issues) => {
      const error = new ZodError2(issues);
      return error;
    };
    var errorMap2 = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode2.invalid_type:
          if (issue.received === ZodParsedType2.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode2.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util3.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode2.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util3.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode2.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode2.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util3.joinValues(issue.options)}`;
          break;
        case ZodIssueCode2.invalid_enum_value:
          message = `Invalid enum value. Expected ${util3.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode2.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode2.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode2.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode2.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util3.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode2.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode2.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode2.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode2.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode2.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode2.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util3.assertNever(issue);
      }
      return { message };
    };
    var overrideErrorMap2 = errorMap2;
    function setErrorMap(map) {
      overrideErrorMap2 = map;
    }
    function getErrorMap2() {
      return overrideErrorMap2;
    }
    var makeIssue2 = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    var EMPTY_PATH = [];
    function addIssueToContext2(ctx, issueData) {
      const issue = makeIssue2({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap2(),
          errorMap2
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    var ParseStatus2 = class {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID2;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return ParseStatus2.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID2;
          if (value.status === "aborted")
            return INVALID2;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (typeof value.value !== "undefined" || pair.alwaysSet) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    var INVALID2 = Object.freeze({
      status: "aborted"
    });
    var DIRTY2 = (value) => ({ status: "dirty", value });
    var OK2 = (value) => ({ status: "valid", value });
    var isAborted2 = (x) => x.status === "aborted";
    var isDirty2 = (x) => x.status === "dirty";
    var isValid2 = (x) => x.status === "valid";
    var isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
    var errorUtil2;
    (function(errorUtil22) {
      errorUtil22.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil22.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil2 || (errorUtil2 = {}));
    var ParseInputLazyPath2 = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    var handleResult2 = (ctx, result) => {
      if (isValid2(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError2(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams2(params) {
      if (!params)
        return {};
      const { errorMap: errorMap22, invalid_type_error, required_error, description } = params;
      if (errorMap22 && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap22)
        return { errorMap: errorMap22, description };
      const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
          return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    var ZodType2 = class {
      constructor(def22) {
        this.spa = this.safeParseAsync;
        this._def = def22;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType2(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType2(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus2(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType2(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync2(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType2(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult2(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType2(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync2(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult2(ctx, result);
      }
      refine(check5, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check5(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode2.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check5, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check5(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects2({
          schema: this,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional2.create(this, this._def);
      }
      nullable() {
        return ZodNullable2.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray2.create(this, this._def);
      }
      promise() {
        return ZodPromise2.create(this, this._def);
      }
      or(option) {
        return ZodUnion2.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection2.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects2({
          ...processCreateParams2(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind2.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def22) {
        const defaultValueFunc = typeof def22 === "function" ? def22 : () => def22;
        return new ZodDefault2({
          ...processCreateParams2(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind2.ZodDefault
        });
      }
      brand() {
        return new ZodBranded2({
          typeName: ZodFirstPartyTypeKind2.ZodBranded,
          type: this,
          ...processCreateParams2(this._def)
        });
      }
      catch(def22) {
        const catchValueFunc = typeof def22 === "function" ? def22 : () => def22;
        return new ZodCatch2({
          ...processCreateParams2(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind2.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target2) {
        return ZodPipeline2.create(this, target2);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    var cuidRegex2 = /^c[^\s-]{8,}$/i;
    var cuid2Regex2 = /^[a-z][a-z0-9]*$/;
    var ulidRegex2 = /[0-9A-HJKMNP-TV-Z]{26}/;
    var uuidRegex2 = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
    var emailRegex2 = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
    var emojiRegex2 = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
    var ipv4Regex2 = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    var ipv6Regex2 = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    var datetimeRegex2 = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    function isValidIP2(ip, version22) {
      if ((version22 === "v4" || !version22) && ipv4Regex2.test(ip)) {
        return true;
      }
      if ((version22 === "v6" || !version22) && ipv6Regex2.test(ip)) {
        return true;
      }
      return false;
    }
    var ZodString2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode2.invalid_string,
          ...errorUtil2.errToObj(message)
        });
        this.nonempty = (message) => this.min(1, errorUtil2.errToObj(message));
        this.trim = () => new ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
        this.toLowerCase = () => new ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
        this.toUpperCase = () => new ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext2(
            ctx2,
            {
              code: ZodIssueCode2.invalid_type,
              expected: ZodParsedType2.string,
              received: ctx2.parsedType
            }
          );
          return INVALID2;
        }
        const status = new ParseStatus2();
        let ctx = void 0;
        for (const check5 of this._def.checks) {
          if (check5.kind === "min") {
            if (input.data.length < check5.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.too_small,
                minimum: check5.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "max") {
            if (input.data.length > check5.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.too_big,
                maximum: check5.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "length") {
            const tooBig = input.data.length > check5.value;
            const tooSmall = input.data.length < check5.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext2(ctx, {
                  code: ZodIssueCode2.too_big,
                  maximum: check5.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check5.message
                });
              } else if (tooSmall) {
                addIssueToContext2(ctx, {
                  code: ZodIssueCode2.too_small,
                  minimum: check5.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check5.message
                });
              }
              status.dirty();
            }
          } else if (check5.kind === "email") {
            if (!emailRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "email",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "emoji") {
            if (!emojiRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "emoji",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "uuid") {
            if (!uuidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "uuid",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "cuid") {
            if (!cuidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "cuid",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "cuid2") {
            if (!cuid2Regex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "cuid2",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "ulid") {
            if (!ulidRegex2.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "ulid",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "url",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "regex") {
            check5.regex.lastIndex = 0;
            const testResult = check5.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "regex",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "trim") {
            input.data = input.data.trim();
          } else if (check5.kind === "includes") {
            if (!input.data.includes(check5.value, check5.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { includes: check5.value, position: check5.position },
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check5.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check5.kind === "startsWith") {
            if (!input.data.startsWith(check5.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { startsWith: check5.value },
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "endsWith") {
            if (!input.data.endsWith(check5.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: { endsWith: check5.value },
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "datetime") {
            const regex = datetimeRegex2(check5);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.invalid_string,
                validation: "datetime",
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "ip") {
            if (!isValidIP2(input.data, check5.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                validation: "ip",
                code: ZodIssueCode2.invalid_string,
                message: check5.message
              });
              status.dirty();
            }
          } else {
            util3.assertNever(check5);
          }
        }
        return { status: status.value, value: input.data };
      }
      _addCheck(check5) {
        return new ZodString2({
          ...this._def,
          checks: [...this._def.checks, check5]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil2.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil2.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil2.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil2.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil2.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil2.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil2.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil2.errToObj(options) });
      }
      datetime(options) {
        var _a;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          ...errorUtil2.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil2.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil2.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil2.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil2.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil2.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil2.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil2.errToObj(message)
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString2.create = (params) => {
      var _a;
      return new ZodString2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams2(params)
      });
    };
    function floatSafeRemainder2(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    var ZodNumber2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext2(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.number,
            received: ctx2.parsedType
          });
          return INVALID2;
        }
        let ctx = void 0;
        const status = new ParseStatus2();
        for (const check5 of this._def.checks) {
          if (check5.kind === "int") {
            if (!util3.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.invalid_type,
                expected: "integer",
                received: "float",
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "min") {
            const tooSmall = check5.inclusive ? input.data < check5.value : input.data <= check5.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.too_small,
                minimum: check5.value,
                type: "number",
                inclusive: check5.inclusive,
                exact: false,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "max") {
            const tooBig = check5.inclusive ? input.data > check5.value : input.data >= check5.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.too_big,
                maximum: check5.value,
                type: "number",
                inclusive: check5.inclusive,
                exact: false,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "multipleOf") {
            if (floatSafeRemainder2(input.data, check5.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.not_multiple_of,
                multipleOf: check5.value,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.not_finite,
                message: check5.message
              });
              status.dirty();
            }
          } else {
            util3.assertNever(check5);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil2.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil2.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil2.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil2.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodNumber2({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil2.toString(message)
            }
          ]
        });
      }
      _addCheck(check5) {
        return new ZodNumber2({
          ...this._def,
          checks: [...this._def.checks, check5]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil2.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil2.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil2.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil2.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil2.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil2.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil2.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil2.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil2.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util3.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber2.create = (params) => {
      return new ZodNumber2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams2(params)
      });
    };
    var ZodBigInt2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext2(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.bigint,
            received: ctx2.parsedType
          });
          return INVALID2;
        }
        let ctx = void 0;
        const status = new ParseStatus2();
        for (const check5 of this._def.checks) {
          if (check5.kind === "min") {
            const tooSmall = check5.inclusive ? input.data < check5.value : input.data <= check5.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.too_small,
                type: "bigint",
                minimum: check5.value,
                inclusive: check5.inclusive,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "max") {
            const tooBig = check5.inclusive ? input.data > check5.value : input.data >= check5.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.too_big,
                type: "bigint",
                maximum: check5.value,
                inclusive: check5.inclusive,
                message: check5.message
              });
              status.dirty();
            }
          } else if (check5.kind === "multipleOf") {
            if (input.data % check5.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.not_multiple_of,
                multipleOf: check5.value,
                message: check5.message
              });
              status.dirty();
            }
          } else {
            util3.assertNever(check5);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil2.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil2.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil2.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil2.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodBigInt2({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil2.toString(message)
            }
          ]
        });
      }
      _addCheck(check5) {
        return new ZodBigInt2({
          ...this._def,
          checks: [...this._def.checks, check5]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil2.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil2.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil2.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil2.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil2.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt2.create = (params) => {
      var _a;
      return new ZodBigInt2({
        checks: [],
        typeName: ZodFirstPartyTypeKind2.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams2(params)
      });
    };
    var ZodBoolean2 = class extends ZodType2 {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.boolean,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        return OK2(input.data);
      }
    };
    ZodBoolean2.create = (params) => {
      return new ZodBoolean2({
        typeName: ZodFirstPartyTypeKind2.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams2(params)
      });
    };
    var ZodDate2 = class extends ZodType2 {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext2(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.date,
            received: ctx2.parsedType
          });
          return INVALID2;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext2(ctx2, {
            code: ZodIssueCode2.invalid_date
          });
          return INVALID2;
        }
        const status = new ParseStatus2();
        let ctx = void 0;
        for (const check5 of this._def.checks) {
          if (check5.kind === "min") {
            if (input.data.getTime() < check5.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.too_small,
                message: check5.message,
                inclusive: true,
                exact: false,
                minimum: check5.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check5.kind === "max") {
            if (input.data.getTime() > check5.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.too_big,
                message: check5.message,
                inclusive: true,
                exact: false,
                maximum: check5.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util3.assertNever(check5);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check5) {
        return new ZodDate2({
          ...this._def,
          checks: [...this._def.checks, check5]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil2.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil2.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate2.create = (params) => {
      return new ZodDate2({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind2.ZodDate,
        ...processCreateParams2(params)
      });
    };
    var ZodSymbol2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.symbol,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        return OK2(input.data);
      }
    };
    ZodSymbol2.create = (params) => {
      return new ZodSymbol2({
        typeName: ZodFirstPartyTypeKind2.ZodSymbol,
        ...processCreateParams2(params)
      });
    };
    var ZodUndefined2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.undefined,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        return OK2(input.data);
      }
    };
    ZodUndefined2.create = (params) => {
      return new ZodUndefined2({
        typeName: ZodFirstPartyTypeKind2.ZodUndefined,
        ...processCreateParams2(params)
      });
    };
    var ZodNull2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.null,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        return OK2(input.data);
      }
    };
    ZodNull2.create = (params) => {
      return new ZodNull2({
        typeName: ZodFirstPartyTypeKind2.ZodNull,
        ...processCreateParams2(params)
      });
    };
    var ZodAny2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK2(input.data);
      }
    };
    ZodAny2.create = (params) => {
      return new ZodAny2({
        typeName: ZodFirstPartyTypeKind2.ZodAny,
        ...processCreateParams2(params)
      });
    };
    var ZodUnknown2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK2(input.data);
      }
    };
    ZodUnknown2.create = (params) => {
      return new ZodUnknown2({
        typeName: ZodFirstPartyTypeKind2.ZodUnknown,
        ...processCreateParams2(params)
      });
    };
    var ZodNever2 = class extends ZodType2 {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext2(ctx, {
          code: ZodIssueCode2.invalid_type,
          expected: ZodParsedType2.never,
          received: ctx.parsedType
        });
        return INVALID2;
      }
    };
    ZodNever2.create = (params) => {
      return new ZodNever2({
        typeName: ZodFirstPartyTypeKind2.ZodNever,
        ...processCreateParams2(params)
      });
    };
    var ZodVoid2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.void,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        return OK2(input.data);
      }
    };
    ZodVoid2.create = (params) => {
      return new ZodVoid2({
        typeName: ZodFirstPartyTypeKind2.ZodVoid,
        ...processCreateParams2(params)
      });
    };
    var ZodArray2 = class extends ZodType2 {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def22 = this._def;
        if (ctx.parsedType !== ZodParsedType2.array) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.array,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        if (def22.exactLength !== null) {
          const tooBig = ctx.data.length > def22.exactLength.value;
          const tooSmall = ctx.data.length < def22.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext2(ctx, {
              code: tooBig ? ZodIssueCode2.too_big : ZodIssueCode2.too_small,
              minimum: tooSmall ? def22.exactLength.value : void 0,
              maximum: tooBig ? def22.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def22.exactLength.message
            });
            status.dirty();
          }
        }
        if (def22.minLength !== null) {
          if (ctx.data.length < def22.minLength.value) {
            addIssueToContext2(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: def22.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def22.minLength.message
            });
            status.dirty();
          }
        }
        if (def22.maxLength !== null) {
          if (ctx.data.length > def22.maxLength.value) {
            addIssueToContext2(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: def22.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def22.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def22.type._parseAsync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus2.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def22.type._parseSync(new ParseInputLazyPath2(ctx, item, ctx.path, i));
        });
        return ParseStatus2.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new ZodArray2({
          ...this._def,
          minLength: { value: minLength, message: errorUtil2.toString(message) }
        });
      }
      max(maxLength, message) {
        return new ZodArray2({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil2.toString(message) }
        });
      }
      length(len, message) {
        return new ZodArray2({
          ...this._def,
          exactLength: { value: len, message: errorUtil2.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray2.create = (schema2, params) => {
      return new ZodArray2({
        type: schema2,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind2.ZodArray,
        ...processCreateParams2(params)
      });
    };
    function deepPartialify2(schema2) {
      if (schema2 instanceof ZodObject2) {
        const newShape = {};
        for (const key in schema2.shape) {
          const fieldSchema = schema2.shape[key];
          newShape[key] = ZodOptional2.create(deepPartialify2(fieldSchema));
        }
        return new ZodObject2({
          ...schema2._def,
          shape: () => newShape
        });
      } else if (schema2 instanceof ZodArray2) {
        return new ZodArray2({
          ...schema2._def,
          type: deepPartialify2(schema2.element)
        });
      } else if (schema2 instanceof ZodOptional2) {
        return ZodOptional2.create(deepPartialify2(schema2.unwrap()));
      } else if (schema2 instanceof ZodNullable2) {
        return ZodNullable2.create(deepPartialify2(schema2.unwrap()));
      } else if (schema2 instanceof ZodTuple2) {
        return ZodTuple2.create(schema2.items.map((item) => deepPartialify2(item)));
      } else {
        return schema2;
      }
    }
    var ZodObject2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util3.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext2(ctx2, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.object,
            received: ctx2.parsedType
          });
          return INVALID2;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever2 && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath2(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever2) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext2(ctx, {
                code: ZodIssueCode2.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath2(ctx, value, ctx.path, key)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus2.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus2.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil2.errToObj;
        return new ZodObject2({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil2.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject2({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject2({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      extend(augmentation) {
        return new ZodObject2({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      merge(merging) {
        const merged = new ZodObject2({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind2.ZodObject
        });
        return merged;
      }
      setKey(key, schema2) {
        return this.augment({ [key]: schema2 });
      }
      catchall(index) {
        return new ZodObject2({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util3.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject2({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util3.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject2({
          ...this._def,
          shape: () => shape
        });
      }
      deepPartial() {
        return deepPartialify2(this);
      }
      partial(mask) {
        const newShape = {};
        util3.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new ZodObject2({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util3.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional2) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new ZodObject2({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum2(util3.objectKeys(this.shape));
      }
    };
    ZodObject2.create = (shape, params) => {
      return new ZodObject2({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    ZodObject2.strictCreate = (shape, params) => {
      return new ZodObject2({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    ZodObject2.lazycreate = (shape, params) => {
      return new ZodObject2({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever2.create(),
        typeName: ZodFirstPartyTypeKind2.ZodObject,
        ...processCreateParams2(params)
      });
    };
    var ZodUnion2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError2(result.ctx.common.issues));
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_union,
            unionErrors
          });
          return INVALID2;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError2(issues2));
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_union,
            unionErrors
          });
          return INVALID2;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion2.create = (types, params) => {
      return new ZodUnion2({
        options: types,
        typeName: ZodFirstPartyTypeKind2.ZodUnion,
        ...processCreateParams2(params)
      });
    };
    var getDiscriminator2 = (type) => {
      if (type instanceof ZodLazy2) {
        return getDiscriminator2(type.schema);
      } else if (type instanceof ZodEffects2) {
        return getDiscriminator2(type.innerType());
      } else if (type instanceof ZodLiteral2) {
        return [type.value];
      } else if (type instanceof ZodEnum2) {
        return type.options;
      } else if (type instanceof ZodNativeEnum2) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault2) {
        return getDiscriminator2(type._def.innerType);
      } else if (type instanceof ZodUndefined2) {
        return [void 0];
      } else if (type instanceof ZodNull2) {
        return [null];
      } else {
        return null;
      }
    };
    var ZodDiscriminatedUnion2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType2.object) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.object,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID2;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator2(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new ZodDiscriminatedUnion2({
          typeName: ZodFirstPartyTypeKind2.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams2(params)
        });
      }
    };
    function mergeValues2(a, b) {
      const aType = getParsedType2(a);
      const bType = getParsedType2(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === ZodParsedType2.object && bType === ZodParsedType2.object) {
        const bKeys = util3.objectKeys(b);
        const sharedKeys = util3.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues2(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === ZodParsedType2.array && bType === ZodParsedType2.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues2(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === ZodParsedType2.date && bType === ZodParsedType2.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    var ZodIntersection2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted2(parsedLeft) || isAborted2(parsedRight)) {
            return INVALID2;
          }
          const merged = mergeValues2(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext2(ctx, {
              code: ZodIssueCode2.invalid_intersection_types
            });
            return INVALID2;
          }
          if (isDirty2(parsedLeft) || isDirty2(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection2.create = (left, right, params) => {
      return new ZodIntersection2({
        left,
        right,
        typeName: ZodFirstPartyTypeKind2.ZodIntersection,
        ...processCreateParams2(params)
      });
    };
    var ZodTuple2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType2.array) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.array,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID2;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema2 = this._def.items[itemIndex] || this._def.rest;
          if (!schema2)
            return null;
          return schema2._parse(new ParseInputLazyPath2(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus2.mergeArray(status, results);
          });
        } else {
          return ParseStatus2.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple2({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple2.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple2({
        items: schemas,
        typeName: ZodFirstPartyTypeKind2.ZodTuple,
        rest: null,
        ...processCreateParams2(params)
      });
    };
    var ZodRecord2 = class extends ZodType2 {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType2.object) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.object,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath2(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return ParseStatus2.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus2.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType2) {
          return new ZodRecord2({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind2.ZodRecord,
            ...processCreateParams2(third)
          });
        }
        return new ZodRecord2({
          keyType: ZodString2.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind2.ZodRecord,
          ...processCreateParams2(second)
        });
      }
    };
    var ZodMap2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType2.map) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.map,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath2(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath2(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID2;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID2;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap2.create = (keyType, valueType, params) => {
      return new ZodMap2({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind2.ZodMap,
        ...processCreateParams2(params)
      });
    };
    var ZodSet2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType2.set) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.set,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        const def22 = this._def;
        if (def22.minSize !== null) {
          if (ctx.data.size < def22.minSize.value) {
            addIssueToContext2(ctx, {
              code: ZodIssueCode2.too_small,
              minimum: def22.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def22.minSize.message
            });
            status.dirty();
          }
        }
        if (def22.maxSize !== null) {
          if (ctx.data.size > def22.maxSize.value) {
            addIssueToContext2(ctx, {
              code: ZodIssueCode2.too_big,
              maximum: def22.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def22.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID2;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath2(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new ZodSet2({
          ...this._def,
          minSize: { value: minSize, message: errorUtil2.toString(message) }
        });
      }
      max(maxSize, message) {
        return new ZodSet2({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil2.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet2.create = (valueType, params) => {
      return new ZodSet2({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind2.ZodSet,
        ...processCreateParams2(params)
      });
    };
    var ZodFunction2 = class extends ZodType2 {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType2.function) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.function,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        function makeArgsIssue(args, error) {
          return makeIssue2({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap2(),
              errorMap2
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode2.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return makeIssue2({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap2(),
              errorMap2
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode2.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise2) {
          return OK2(async (...args) => {
            const error = new ZodError2([]);
            const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await fn(...parsedArgs);
            const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          return OK2((...args) => {
            const parsedArgs = this._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError2([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = fn(...parsedArgs.data);
            const parsedReturns = this._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError2([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction2({
          ...this._def,
          args: ZodTuple2.create(items).rest(ZodUnknown2.create())
        });
      }
      returns(returnType) {
        return new ZodFunction2({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new ZodFunction2({
          args: args ? args : ZodTuple2.create([]).rest(ZodUnknown2.create()),
          returns: returns || ZodUnknown2.create(),
          typeName: ZodFirstPartyTypeKind2.ZodFunction,
          ...processCreateParams2(params)
        });
      }
    };
    var ZodLazy2 = class extends ZodType2 {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy2.create = (getter, params) => {
      return new ZodLazy2({
        getter,
        typeName: ZodFirstPartyTypeKind2.ZodLazy,
        ...processCreateParams2(params)
      });
    };
    var ZodLiteral2 = class extends ZodType2 {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext2(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_literal,
            expected: this._def.value
          });
          return INVALID2;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral2.create = (value, params) => {
      return new ZodLiteral2({
        value,
        typeName: ZodFirstPartyTypeKind2.ZodLiteral,
        ...processCreateParams2(params)
      });
    };
    function createZodEnum2(values, params) {
      return new ZodEnum2({
        values,
        typeName: ZodFirstPartyTypeKind2.ZodEnum,
        ...processCreateParams2(params)
      });
    }
    var ZodEnum2 = class extends ZodType2 {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext2(ctx, {
            expected: util3.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode2.invalid_type
          });
          return INVALID2;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext2(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_enum_value,
            options: expectedValues
          });
          return INVALID2;
        }
        return OK2(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return ZodEnum2.create(values);
      }
      exclude(values) {
        return ZodEnum2.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    ZodEnum2.create = createZodEnum2;
    var ZodNativeEnum2 = class extends ZodType2 {
      _parse(input) {
        const nativeEnumValues = util3.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType2.string && ctx.parsedType !== ZodParsedType2.number) {
          const expectedValues = util3.objectValues(nativeEnumValues);
          addIssueToContext2(ctx, {
            expected: util3.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode2.invalid_type
          });
          return INVALID2;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util3.objectValues(nativeEnumValues);
          addIssueToContext2(ctx, {
            received: ctx.data,
            code: ZodIssueCode2.invalid_enum_value,
            options: expectedValues
          });
          return INVALID2;
        }
        return OK2(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum2.create = (values, params) => {
      return new ZodNativeEnum2({
        values,
        typeName: ZodFirstPartyTypeKind2.ZodNativeEnum,
        ...processCreateParams2(params)
      });
    };
    var ZodPromise2 = class extends ZodType2 {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType2.promise && ctx.common.async === false) {
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.promise,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        const promisified = ctx.parsedType === ZodParsedType2.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK2(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise2.create = (schema2, params) => {
      return new ZodPromise2({
        type: schema2,
        typeName: ZodFirstPartyTypeKind2.ZodPromise,
        ...processCreateParams2(params)
      });
    };
    var ZodEffects2 = class extends ZodType2 {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind2.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data);
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext2(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID2;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID2;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base33 = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid2(base33))
              return base33;
            const result = effect.transform(base33.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base33) => {
              if (!isValid2(base33))
                return base33;
              return Promise.resolve(effect.transform(base33.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util3.assertNever(effect);
      }
    };
    ZodEffects2.create = (schema2, effect, params) => {
      return new ZodEffects2({
        schema: schema2,
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        effect,
        ...processCreateParams2(params)
      });
    };
    ZodEffects2.createWithPreprocess = (preprocess, schema2, params) => {
      return new ZodEffects2({
        schema: schema2,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind2.ZodEffects,
        ...processCreateParams2(params)
      });
    };
    var ZodOptional2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType2.undefined) {
          return OK2(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional2.create = (type, params) => {
      return new ZodOptional2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodOptional,
        ...processCreateParams2(params)
      });
    };
    var ZodNullable2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType2.null) {
          return OK2(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable2.create = (type, params) => {
      return new ZodNullable2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodNullable,
        ...processCreateParams2(params)
      });
    };
    var ZodDefault2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType2.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault2.create = (type, params) => {
      return new ZodDefault2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams2(params)
      });
    };
    var ZodCatch2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync2(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError2(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError2(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch2.create = (type, params) => {
      return new ZodCatch2({
        innerType: type,
        typeName: ZodFirstPartyTypeKind2.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams2(params)
      });
    };
    var ZodNaN2 = class extends ZodType2 {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType2.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext2(ctx, {
            code: ZodIssueCode2.invalid_type,
            expected: ZodParsedType2.nan,
            received: ctx.parsedType
          });
          return INVALID2;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN2.create = (params) => {
      return new ZodNaN2({
        typeName: ZodFirstPartyTypeKind2.ZodNaN,
        ...processCreateParams2(params)
      });
    };
    var BRAND2 = Symbol("zod_brand");
    var ZodBranded2 = class extends ZodType2 {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    var ZodPipeline2 = class extends ZodType2 {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID2;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY2(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID2;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new ZodPipeline2({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind2.ZodPipeline
        });
      }
    };
    var custom = (check5, params = {}, fatal) => {
      if (check5)
        return ZodAny2.create().superRefine((data, ctx) => {
          var _a, _b;
          if (!check5(data)) {
            const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            const p2 = typeof p === "string" ? { message: p } : p;
            ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
          }
        });
      return ZodAny2.create();
    };
    var late2 = {
      object: ZodObject2.lazycreate
    };
    var ZodFirstPartyTypeKind2;
    (function(ZodFirstPartyTypeKind22) {
      ZodFirstPartyTypeKind22["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind22["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind22["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind22["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind22["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind22["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind22["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind22["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind22["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind22["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind22["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind22["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind22["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind22["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind22["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind22["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind22["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind22["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind22["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind22["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind22["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind22["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind22["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind22["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind22["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind22["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind22["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind22["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind22["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind22["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind22["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind22["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind22["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind22["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind22["ZodPipeline"] = "ZodPipeline";
    })(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));
    var instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    var stringType2 = ZodString2.create;
    var numberType2 = ZodNumber2.create;
    var nanType2 = ZodNaN2.create;
    var bigIntType2 = ZodBigInt2.create;
    var booleanType2 = ZodBoolean2.create;
    var dateType2 = ZodDate2.create;
    var symbolType2 = ZodSymbol2.create;
    var undefinedType2 = ZodUndefined2.create;
    var nullType2 = ZodNull2.create;
    var anyType2 = ZodAny2.create;
    var unknownType2 = ZodUnknown2.create;
    var neverType2 = ZodNever2.create;
    var voidType2 = ZodVoid2.create;
    var arrayType2 = ZodArray2.create;
    var objectType2 = ZodObject2.create;
    var strictObjectType2 = ZodObject2.strictCreate;
    var unionType2 = ZodUnion2.create;
    var discriminatedUnionType2 = ZodDiscriminatedUnion2.create;
    var intersectionType2 = ZodIntersection2.create;
    var tupleType2 = ZodTuple2.create;
    var recordType2 = ZodRecord2.create;
    var mapType2 = ZodMap2.create;
    var setType2 = ZodSet2.create;
    var functionType2 = ZodFunction2.create;
    var lazyType2 = ZodLazy2.create;
    var literalType2 = ZodLiteral2.create;
    var enumType2 = ZodEnum2.create;
    var nativeEnumType2 = ZodNativeEnum2.create;
    var promiseType2 = ZodPromise2.create;
    var effectsType2 = ZodEffects2.create;
    var optionalType2 = ZodOptional2.create;
    var nullableType2 = ZodNullable2.create;
    var preprocessType2 = ZodEffects2.createWithPreprocess;
    var pipelineType2 = ZodPipeline2.create;
    var ostring = () => stringType2().optional();
    var onumber = () => numberType2().optional();
    var oboolean = () => booleanType2().optional();
    var coerce22 = {
      string: (arg) => ZodString2.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber2.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean2.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt2.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate2.create({ ...arg, coerce: true })
    };
    var NEVER = INVALID2;
    var z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap2,
      setErrorMap,
      getErrorMap: getErrorMap2,
      makeIssue: makeIssue2,
      EMPTY_PATH,
      addIssueToContext: addIssueToContext2,
      ParseStatus: ParseStatus2,
      INVALID: INVALID2,
      DIRTY: DIRTY2,
      OK: OK2,
      isAborted: isAborted2,
      isDirty: isDirty2,
      isValid: isValid2,
      isAsync: isAsync2,
      get util() {
        return util3;
      },
      get objectUtil() {
        return objectUtil2;
      },
      ZodParsedType: ZodParsedType2,
      getParsedType: getParsedType2,
      ZodType: ZodType2,
      ZodString: ZodString2,
      ZodNumber: ZodNumber2,
      ZodBigInt: ZodBigInt2,
      ZodBoolean: ZodBoolean2,
      ZodDate: ZodDate2,
      ZodSymbol: ZodSymbol2,
      ZodUndefined: ZodUndefined2,
      ZodNull: ZodNull2,
      ZodAny: ZodAny2,
      ZodUnknown: ZodUnknown2,
      ZodNever: ZodNever2,
      ZodVoid: ZodVoid2,
      ZodArray: ZodArray2,
      ZodObject: ZodObject2,
      ZodUnion: ZodUnion2,
      ZodDiscriminatedUnion: ZodDiscriminatedUnion2,
      ZodIntersection: ZodIntersection2,
      ZodTuple: ZodTuple2,
      ZodRecord: ZodRecord2,
      ZodMap: ZodMap2,
      ZodSet: ZodSet2,
      ZodFunction: ZodFunction2,
      ZodLazy: ZodLazy2,
      ZodLiteral: ZodLiteral2,
      ZodEnum: ZodEnum2,
      ZodNativeEnum: ZodNativeEnum2,
      ZodPromise: ZodPromise2,
      ZodEffects: ZodEffects2,
      ZodTransformer: ZodEffects2,
      ZodOptional: ZodOptional2,
      ZodNullable: ZodNullable2,
      ZodDefault: ZodDefault2,
      ZodCatch: ZodCatch2,
      ZodNaN: ZodNaN2,
      BRAND: BRAND2,
      ZodBranded: ZodBranded2,
      ZodPipeline: ZodPipeline2,
      custom,
      Schema: ZodType2,
      ZodSchema: ZodType2,
      late: late2,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind2;
      },
      coerce: coerce22,
      any: anyType2,
      array: arrayType2,
      bigint: bigIntType2,
      boolean: booleanType2,
      date: dateType2,
      discriminatedUnion: discriminatedUnionType2,
      effect: effectsType2,
      "enum": enumType2,
      "function": functionType2,
      "instanceof": instanceOfType,
      intersection: intersectionType2,
      lazy: lazyType2,
      literal: literalType2,
      map: mapType2,
      nan: nanType2,
      nativeEnum: nativeEnumType2,
      never: neverType2,
      "null": nullType2,
      nullable: nullableType2,
      number: numberType2,
      object: objectType2,
      oboolean,
      onumber,
      optional: optionalType2,
      ostring,
      pipeline: pipelineType2,
      preprocess: preprocessType2,
      promise: promiseType2,
      record: recordType2,
      set: setType2,
      strictObject: strictObjectType2,
      string: stringType2,
      symbol: symbolType2,
      transformer: effectsType2,
      tuple: tupleType2,
      "undefined": undefinedType2,
      union: unionType2,
      unknown: unknownType2,
      "void": voidType2,
      NEVER,
      ZodIssueCode: ZodIssueCode2,
      quotelessJson,
      ZodError: ZodError2
    });
    var cidSchema = z.any().refine((obj) => CID2.asCID(obj) !== null, {
      message: "Not a CID"
    }).transform((obj) => CID2.asCID(obj));
    var schema = {
      cid: cidSchema,
      bytes: z.instanceof(Uint8Array),
      string: z.string(),
      array: z.array(z.unknown()),
      map: z.record(z.string(), z.unknown()),
      unknown: z.unknown()
    };
    var def2 = {
      cid: {
        name: "cid",
        schema: schema.cid
      },
      bytes: {
        name: "bytes",
        schema: schema.bytes
      },
      string: {
        name: "string",
        schema: schema.string
      },
      map: {
        name: "map",
        schema: schema.map
      },
      unknown: {
        name: "unknown",
        schema: schema.unknown
      }
    };
    var SECOND = 1e3;
    var MINUTE = SECOND * 60;
    var HOUR2 = MINUTE * 60;
    var DAY = HOUR2 * 24;
    var import_graphemer = __toESM2(require_lib());
    var utf8Len = (str) => {
      return new TextEncoder().encode(str).byteLength;
    };
    var graphemeLen = (str) => {
      const splitter = new import_graphemer.default();
      return splitter.countGraphemes(str);
    };
    var utf8ToB64Url = (utf8) => {
      return toString22(fromString22(utf8, "utf8"), "base64url");
    };
    var b64UrlToUtf8 = (b64) => {
      return toString22(fromString22(b64, "base64url"), "utf8");
    };
    var parseLanguage = (langTag) => {
      const parsed = langTag.match(bcp47Regexp);
      if (!parsed?.groups)
        return null;
      const parts = parsed.groups;
      return {
        grandfathered: parts.grandfathered,
        language: parts.language,
        extlang: parts.extlang,
        script: parts.script,
        region: parts.region,
        variant: parts.variant,
        extension: parts.extension,
        privateUse: parts.privateUseA || parts.privateUseB
      };
    };
    var validateLanguage = (langTag) => {
      return bcp47Regexp.test(langTag);
    };
    var bcp47Regexp = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
    var import_promises = __toESM2(require("fs/promises"));
    var fileExists = async (location) => {
      try {
        await import_promises.default.access(location, import_promises.default.constants.F_OK);
        return true;
      } catch (err) {
        if (isErrnoException(err) && err.code === "ENOENT") {
          return false;
        }
        throw err;
      }
    };
    var import_crypto22 = __toESM2(require("crypto"));
    var import_stream5 = require("stream");
    var readonly22 = ({ enumerable = true, configurable = false } = {}) => ({
      enumerable,
      configurable,
      writable: false
    });
    var links = function* (source, base33) {
      if (source == null)
        return;
      if (source instanceof Uint8Array)
        return;
      for (const [key, value] of Object.entries(source)) {
        const path = [
          ...base33,
          key
        ];
        if (value != null && typeof value === "object") {
          if (Array.isArray(value)) {
            for (const [index, element] of value.entries()) {
              const elementPath = [
                ...path,
                index
              ];
              const cid2 = CID2.asCID(element);
              if (cid2) {
                yield [
                  elementPath.join("/"),
                  cid2
                ];
              } else if (typeof element === "object") {
                yield* links(element, elementPath);
              }
            }
          } else {
            const cid2 = CID2.asCID(value);
            if (cid2) {
              yield [
                path.join("/"),
                cid2
              ];
            } else {
              yield* links(value, path);
            }
          }
        }
      }
    };
    var tree = function* (source, base33) {
      if (source == null)
        return;
      for (const [key, value] of Object.entries(source)) {
        const path = [
          ...base33,
          key
        ];
        yield path.join("/");
        if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID2.asCID(value)) {
          if (Array.isArray(value)) {
            for (const [index, element] of value.entries()) {
              const elementPath = [
                ...path,
                index
              ];
              yield elementPath.join("/");
              if (typeof element === "object" && !CID2.asCID(element)) {
                yield* tree(element, elementPath);
              }
            }
          } else {
            yield* tree(value, path);
          }
        }
      }
    };
    var get = (source, path) => {
      let node = source;
      for (const [index, key] of path.entries()) {
        node = node[key];
        if (node == null) {
          throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
        }
        const cid2 = CID2.asCID(node);
        if (cid2) {
          return {
            value: cid2,
            remaining: path.slice(index + 1).join("/")
          };
        }
      }
      return { value: node };
    };
    var Block = class {
      constructor({ cid: cid2, bytes, value }) {
        if (!cid2 || !bytes || typeof value === "undefined")
          throw new Error("Missing required argument");
        this.cid = cid2;
        this.bytes = bytes;
        this.value = value;
        this.asBlock = this;
        Object.defineProperties(this, {
          cid: readonly22(),
          bytes: readonly22(),
          value: readonly22(),
          asBlock: readonly22()
        });
      }
      links() {
        return links(this.value, []);
      }
      tree() {
        return tree(this.value, []);
      }
      get(path = "/") {
        return get(this.value, path.split("/").filter(Boolean));
      }
    };
    var encode52 = async ({ value, codec, hasher }) => {
      if (typeof value === "undefined")
        throw new Error('Missing required argument "value"');
      if (!codec || !hasher)
        throw new Error("Missing required argument: codec or hasher");
      const bytes = codec.encode(value);
      const hash = await hasher.digest(bytes);
      const cid2 = CID2.create(1, codec.code, hash);
      return new Block({
        value,
        bytes,
        cid: cid2
      });
    };
    var esm_exports2 = {};
    __export2(esm_exports2, {
      code: () => code3,
      decode: () => decode72,
      encode: () => encode72,
      name: () => name22
    });
    var typeofs2 = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    var objectTypeNames2 = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
    function is22(value) {
      if (value === null) {
        return "null";
      }
      if (value === void 0) {
        return "undefined";
      }
      if (value === true || value === false) {
        return "boolean";
      }
      const typeOf = typeof value;
      if (typeofs2.includes(typeOf)) {
        return typeOf;
      }
      if (typeOf === "function") {
        return "Function";
      }
      if (Array.isArray(value)) {
        return "Array";
      }
      if (isBuffer4(value)) {
        return "Buffer";
      }
      const objectType22 = getObjectType2(value);
      if (objectType22) {
        return objectType22;
      }
      return "Object";
    }
    function isBuffer4(value) {
      return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
    }
    function getObjectType2(value) {
      const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
      if (objectTypeNames2.includes(objectTypeName)) {
        return objectTypeName;
      }
      return void 0;
    }
    var Type2 = class {
      constructor(major, name3, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name3;
        this.terminal = terminal;
      }
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type2.uint = new Type2(0, "uint", true);
    Type2.negint = new Type2(1, "negint", true);
    Type2.bytes = new Type2(2, "bytes", true);
    Type2.string = new Type2(3, "string", true);
    Type2.array = new Type2(4, "array", false);
    Type2.map = new Type2(5, "map", false);
    Type2.tag = new Type2(6, "tag", false);
    Type2.float = new Type2(7, "float", true);
    Type2.false = new Type2(7, "false", true);
    Type2.true = new Type2(7, "true", true);
    Type2.null = new Type2(7, "null", true);
    Type2.undefined = new Type2(7, "undefined", true);
    Type2.break = new Type2(7, "break", true);
    var Token2 = class {
      constructor(type, value, encodedLength) {
        this.type = type;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
    var useBuffer2 = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
    var textDecoder22 = new TextDecoder();
    var textEncoder22 = new TextEncoder();
    function isBuffer22(buf22) {
      return useBuffer2 && globalThis.Buffer.isBuffer(buf22);
    }
    function asU8A2(buf22) {
      if (!(buf22 instanceof Uint8Array)) {
        return Uint8Array.from(buf22);
      }
      return isBuffer22(buf22) ? new Uint8Array(buf22.buffer, buf22.byteOffset, buf22.byteLength) : buf22;
    }
    var toString32 = useBuffer2 ? (bytes, start, end) => {
      return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice2(bytes, start, end);
    } : (bytes, start, end) => {
      return end - start > 64 ? textDecoder22.decode(bytes.subarray(start, end)) : utf8Slice2(bytes, start, end);
    };
    var fromString32 = useBuffer2 ? (string22) => {
      return string22.length > 64 ? globalThis.Buffer.from(string22) : utf8ToBytes2(string22);
    } : (string22) => {
      return string22.length > 64 ? textEncoder22.encode(string22) : utf8ToBytes2(string22);
    };
    var fromArray2 = (arr) => {
      return Uint8Array.from(arr);
    };
    var slice2 = useBuffer2 ? (bytes, start, end) => {
      if (isBuffer22(bytes)) {
        return new Uint8Array(bytes.subarray(start, end));
      }
      return bytes.slice(start, end);
    } : (bytes, start, end) => {
      return bytes.slice(start, end);
    };
    var concat22 = useBuffer2 ? (chunks, length22) => {
      chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
      return asU8A2(globalThis.Buffer.concat(chunks, length22));
    } : (chunks, length22) => {
      const out = new Uint8Array(length22);
      let off = 0;
      for (let b of chunks) {
        if (off + b.length > out.length) {
          b = b.subarray(0, out.length - off);
        }
        out.set(b, off);
        off += b.length;
      }
      return out;
    };
    var alloc2 = useBuffer2 ? (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    } : (size) => {
      return new Uint8Array(size);
    };
    function compare22(b1, b2) {
      if (isBuffer22(b1) && isBuffer22(b2)) {
        return b1.compare(b2);
      }
      for (let i = 0; i < b1.length; i++) {
        if (b1[i] === b2[i]) {
          continue;
        }
        return b1[i] < b2[i] ? -1 : 1;
      }
      return 0;
    }
    function utf8ToBytes2(string22, units = Infinity) {
      let codePoint;
      const length22 = string22.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length22; ++i) {
        codePoint = string22.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length22) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function utf8Slice2(buf22, offset, end) {
      const res = [];
      while (offset < end) {
        const firstByte = buf22[offset];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (offset + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf22[offset + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf22[offset + 1];
              thirdByte = buf22[offset + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf22[offset + 1];
              thirdByte = buf22[offset + 2];
              fourthByte = buf22[offset + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        offset += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2));
      }
      return res;
    }
    var defaultChunkSize2 = 256;
    var Bl2 = class {
      constructor(chunkSize = defaultChunkSize2) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      push(bytes) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes.length < 64 && bytes.length < this.chunkSize) {
            topChunk = alloc2(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes, 0);
          } else {
            this.chunks.push(bytes);
            this.maxCursor += bytes.length;
          }
        }
        this.cursor += bytes.length;
      }
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice2(chunk, 0, this.cursor);
          }
        } else {
          byts = concat22(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
    var decodeErrPrefix2 = "CBOR decode error:";
    var encodeErrPrefix2 = "CBOR encode error:";
    var uintMinorPrefixBytes2 = [];
    uintMinorPrefixBytes2[23] = 1;
    uintMinorPrefixBytes2[24] = 2;
    uintMinorPrefixBytes2[25] = 3;
    uintMinorPrefixBytes2[26] = 5;
    uintMinorPrefixBytes2[27] = 9;
    function assertEnoughData2(data, pos, need) {
      if (data.length - pos < need) {
        throw new Error(`${decodeErrPrefix2} not enough data for type`);
      }
    }
    var uintBoundaries2 = [
      24,
      256,
      65536,
      4294967296,
      BigInt("18446744073709551616")
    ];
    function readUint82(data, offset, options) {
      assertEnoughData2(data, offset, 1);
      const value = data[offset];
      if (options.strict === true && value < uintBoundaries2[0]) {
        throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint162(data, offset, options) {
      assertEnoughData2(data, offset, 2);
      const value = data[offset] << 8 | data[offset + 1];
      if (options.strict === true && value < uintBoundaries2[1]) {
        throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint322(data, offset, options) {
      assertEnoughData2(data, offset, 4);
      const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
      if (options.strict === true && value < uintBoundaries2[2]) {
        throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
      }
      return value;
    }
    function readUint642(data, offset, options) {
      assertEnoughData2(data, offset, 8);
      const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
      const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
      const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
      if (options.strict === true && value < uintBoundaries2[3]) {
        throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
      }
      if (value <= Number.MAX_SAFE_INTEGER) {
        return Number(value);
      }
      if (options.allowBigInt === true) {
        return value;
      }
      throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
    }
    function decodeUint82(data, pos, _minor, options) {
      return new Token2(Type2.uint, readUint82(data, pos + 1, options), 2);
    }
    function decodeUint162(data, pos, _minor, options) {
      return new Token2(Type2.uint, readUint162(data, pos + 1, options), 3);
    }
    function decodeUint322(data, pos, _minor, options) {
      return new Token2(Type2.uint, readUint322(data, pos + 1, options), 5);
    }
    function decodeUint642(data, pos, _minor, options) {
      return new Token2(Type2.uint, readUint642(data, pos + 1, options), 9);
    }
    function encodeUint2(buf22, token) {
      return encodeUintValue2(buf22, 0, token.value);
    }
    function encodeUintValue2(buf22, major, uint) {
      if (uint < uintBoundaries2[0]) {
        const nuint = Number(uint);
        buf22.push([major | nuint]);
      } else if (uint < uintBoundaries2[1]) {
        const nuint = Number(uint);
        buf22.push([
          major | 24,
          nuint
        ]);
      } else if (uint < uintBoundaries2[2]) {
        const nuint = Number(uint);
        buf22.push([
          major | 25,
          nuint >>> 8,
          nuint & 255
        ]);
      } else if (uint < uintBoundaries2[3]) {
        const nuint = Number(uint);
        buf22.push([
          major | 26,
          nuint >>> 24 & 255,
          nuint >>> 16 & 255,
          nuint >>> 8 & 255,
          nuint & 255
        ]);
      } else {
        const buint = BigInt(uint);
        if (buint < uintBoundaries2[4]) {
          const set = [
            major | 27,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          let lo = Number(buint & BigInt(4294967295));
          let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
          set[8] = lo & 255;
          lo = lo >> 8;
          set[7] = lo & 255;
          lo = lo >> 8;
          set[6] = lo & 255;
          lo = lo >> 8;
          set[5] = lo & 255;
          set[4] = hi & 255;
          hi = hi >> 8;
          set[3] = hi & 255;
          hi = hi >> 8;
          set[2] = hi & 255;
          hi = hi >> 8;
          set[1] = hi & 255;
          buf22.push(set);
        } else {
          throw new Error(`${decodeErrPrefix2} encountered BigInt larger than allowable range`);
        }
      }
    }
    encodeUint2.encodedSize = function encodedSize9(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
    encodeUintValue2.encodedSize = function encodedSize22(uint) {
      if (uint < uintBoundaries2[0]) {
        return 1;
      }
      if (uint < uintBoundaries2[1]) {
        return 2;
      }
      if (uint < uintBoundaries2[2]) {
        return 3;
      }
      if (uint < uintBoundaries2[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint2.compareTokens = function compareTokens4(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
    };
    function decodeNegint82(data, pos, _minor, options) {
      return new Token2(Type2.negint, -1 - readUint82(data, pos + 1, options), 2);
    }
    function decodeNegint162(data, pos, _minor, options) {
      return new Token2(Type2.negint, -1 - readUint162(data, pos + 1, options), 3);
    }
    function decodeNegint322(data, pos, _minor, options) {
      return new Token2(Type2.negint, -1 - readUint322(data, pos + 1, options), 5);
    }
    var neg1b2 = BigInt(-1);
    var pos1b2 = BigInt(1);
    function decodeNegint642(data, pos, _minor, options) {
      const int = readUint642(data, pos + 1, options);
      if (typeof int !== "bigint") {
        const value = -1 - int;
        if (value >= Number.MIN_SAFE_INTEGER) {
          return new Token2(Type2.negint, value, 9);
        }
      }
      if (options.allowBigInt !== true) {
        throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
      }
      return new Token2(Type2.negint, neg1b2 - BigInt(int), 9);
    }
    function encodeNegint2(buf22, token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
      encodeUintValue2(buf22, token.type.majorEncoded, unsigned);
    }
    encodeNegint2.encodedSize = function encodedSize32(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
      if (unsigned < uintBoundaries2[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries2[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries2[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries2[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint2.compareTokens = function compareTokens22(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
    };
    function toToken5(data, pos, prefix, length22) {
      assertEnoughData2(data, pos, prefix + length22);
      const buf22 = slice2(data, pos + prefix, pos + prefix + length22);
      return new Token2(Type2.bytes, buf22, prefix + length22);
    }
    function decodeBytesCompact2(data, pos, minor, _options) {
      return toToken5(data, pos, 1, minor);
    }
    function decodeBytes82(data, pos, _minor, options) {
      return toToken5(data, pos, 2, readUint82(data, pos + 1, options));
    }
    function decodeBytes162(data, pos, _minor, options) {
      return toToken5(data, pos, 3, readUint162(data, pos + 1, options));
    }
    function decodeBytes322(data, pos, _minor, options) {
      return toToken5(data, pos, 5, readUint322(data, pos + 1, options));
    }
    function decodeBytes642(data, pos, _minor, options) {
      const l = readUint642(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${decodeErrPrefix2} 64-bit integer bytes lengths not supported`);
      }
      return toToken5(data, pos, 9, l);
    }
    function tokenBytes2(token) {
      if (token.encodedBytes === void 0) {
        token.encodedBytes = token.type === Type2.string ? fromString32(token.value) : token.value;
      }
      return token.encodedBytes;
    }
    function encodeBytes2(buf22, token) {
      const bytes = tokenBytes2(token);
      encodeUintValue2(buf22, token.type.majorEncoded, bytes.length);
      buf22.push(bytes);
    }
    encodeBytes2.encodedSize = function encodedSize42(token) {
      const bytes = tokenBytes2(token);
      return encodeUintValue2.encodedSize(bytes.length) + bytes.length;
    };
    encodeBytes2.compareTokens = function compareTokens32(tok1, tok2) {
      return compareBytes2(tokenBytes2(tok1), tokenBytes2(tok2));
    };
    function compareBytes2(b1, b2) {
      return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare22(b1, b2);
    }
    function toToken22(data, pos, prefix, length22, options) {
      const totLength = prefix + length22;
      assertEnoughData2(data, pos, totLength);
      const tok = new Token2(Type2.string, toString32(data, pos + prefix, pos + totLength), totLength);
      if (options.retainStringBytes === true) {
        tok.byteValue = slice2(data, pos + prefix, pos + totLength);
      }
      return tok;
    }
    function decodeStringCompact2(data, pos, minor, options) {
      return toToken22(data, pos, 1, minor, options);
    }
    function decodeString82(data, pos, _minor, options) {
      return toToken22(data, pos, 2, readUint82(data, pos + 1, options), options);
    }
    function decodeString162(data, pos, _minor, options) {
      return toToken22(data, pos, 3, readUint162(data, pos + 1, options), options);
    }
    function decodeString322(data, pos, _minor, options) {
      return toToken22(data, pos, 5, readUint322(data, pos + 1, options), options);
    }
    function decodeString642(data, pos, _minor, options) {
      const l = readUint642(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${decodeErrPrefix2} 64-bit integer string lengths not supported`);
      }
      return toToken22(data, pos, 9, l, options);
    }
    var encodeString2 = encodeBytes2;
    function toToken32(_data, _pos, prefix, length22) {
      return new Token2(Type2.array, length22, prefix);
    }
    function decodeArrayCompact2(data, pos, minor, _options) {
      return toToken32(data, pos, 1, minor);
    }
    function decodeArray82(data, pos, _minor, options) {
      return toToken32(data, pos, 2, readUint82(data, pos + 1, options));
    }
    function decodeArray162(data, pos, _minor, options) {
      return toToken32(data, pos, 3, readUint162(data, pos + 1, options));
    }
    function decodeArray322(data, pos, _minor, options) {
      return toToken32(data, pos, 5, readUint322(data, pos + 1, options));
    }
    function decodeArray642(data, pos, _minor, options) {
      const l = readUint642(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${decodeErrPrefix2} 64-bit integer array lengths not supported`);
      }
      return toToken32(data, pos, 9, l);
    }
    function decodeArrayIndefinite2(data, pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
      }
      return toToken32(data, pos, 1, Infinity);
    }
    function encodeArray2(buf22, token) {
      encodeUintValue2(buf22, Type2.array.majorEncoded, token.value);
    }
    encodeArray2.compareTokens = encodeUint2.compareTokens;
    encodeArray2.encodedSize = function encodedSize52(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
    function toToken42(_data, _pos, prefix, length22) {
      return new Token2(Type2.map, length22, prefix);
    }
    function decodeMapCompact2(data, pos, minor, _options) {
      return toToken42(data, pos, 1, minor);
    }
    function decodeMap82(data, pos, _minor, options) {
      return toToken42(data, pos, 2, readUint82(data, pos + 1, options));
    }
    function decodeMap162(data, pos, _minor, options) {
      return toToken42(data, pos, 3, readUint162(data, pos + 1, options));
    }
    function decodeMap322(data, pos, _minor, options) {
      return toToken42(data, pos, 5, readUint322(data, pos + 1, options));
    }
    function decodeMap642(data, pos, _minor, options) {
      const l = readUint642(data, pos + 1, options);
      if (typeof l === "bigint") {
        throw new Error(`${decodeErrPrefix2} 64-bit integer map lengths not supported`);
      }
      return toToken42(data, pos, 9, l);
    }
    function decodeMapIndefinite2(data, pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
      }
      return toToken42(data, pos, 1, Infinity);
    }
    function encodeMap2(buf22, token) {
      encodeUintValue2(buf22, Type2.map.majorEncoded, token.value);
    }
    encodeMap2.compareTokens = encodeUint2.compareTokens;
    encodeMap2.encodedSize = function encodedSize62(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
    function decodeTagCompact2(_data, _pos, minor, _options) {
      return new Token2(Type2.tag, minor, 1);
    }
    function decodeTag82(data, pos, _minor, options) {
      return new Token2(Type2.tag, readUint82(data, pos + 1, options), 2);
    }
    function decodeTag162(data, pos, _minor, options) {
      return new Token2(Type2.tag, readUint162(data, pos + 1, options), 3);
    }
    function decodeTag322(data, pos, _minor, options) {
      return new Token2(Type2.tag, readUint322(data, pos + 1, options), 5);
    }
    function decodeTag642(data, pos, _minor, options) {
      return new Token2(Type2.tag, readUint642(data, pos + 1, options), 9);
    }
    function encodeTag2(buf22, token) {
      encodeUintValue2(buf22, Type2.tag.majorEncoded, token.value);
    }
    encodeTag2.compareTokens = encodeUint2.compareTokens;
    encodeTag2.encodedSize = function encodedSize72(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
    var MINOR_FALSE2 = 20;
    var MINOR_TRUE2 = 21;
    var MINOR_NULL2 = 22;
    var MINOR_UNDEFINED2 = 23;
    function decodeUndefined2(_data, _pos, _minor, options) {
      if (options.allowUndefined === false) {
        throw new Error(`${decodeErrPrefix2} undefined values are not supported`);
      } else if (options.coerceUndefinedToNull === true) {
        return new Token2(Type2.null, null, 1);
      }
      return new Token2(Type2.undefined, void 0, 1);
    }
    function decodeBreak2(_data, _pos, _minor, options) {
      if (options.allowIndefinite === false) {
        throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
      }
      return new Token2(Type2.break, void 0, 1);
    }
    function createToken2(value, bytes, options) {
      if (options) {
        if (options.allowNaN === false && Number.isNaN(value)) {
          throw new Error(`${decodeErrPrefix2} NaN values are not supported`);
        }
        if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
          throw new Error(`${decodeErrPrefix2} Infinity values are not supported`);
        }
      }
      return new Token2(Type2.float, value, bytes);
    }
    function decodeFloat162(data, pos, _minor, options) {
      return createToken2(readFloat162(data, pos + 1), 3, options);
    }
    function decodeFloat322(data, pos, _minor, options) {
      return createToken2(readFloat322(data, pos + 1), 5, options);
    }
    function decodeFloat642(data, pos, _minor, options) {
      return createToken2(readFloat642(data, pos + 1), 9, options);
    }
    function encodeFloat2(buf22, token, options) {
      const float = token.value;
      if (float === false) {
        buf22.push([Type2.float.majorEncoded | MINOR_FALSE2]);
      } else if (float === true) {
        buf22.push([Type2.float.majorEncoded | MINOR_TRUE2]);
      } else if (float === null) {
        buf22.push([Type2.float.majorEncoded | MINOR_NULL2]);
      } else if (float === void 0) {
        buf22.push([Type2.float.majorEncoded | MINOR_UNDEFINED2]);
      } else {
        let decoded;
        let success = false;
        if (!options || options.float64 !== true) {
          encodeFloat162(float);
          decoded = readFloat162(ui8a2, 1);
          if (float === decoded || Number.isNaN(float)) {
            ui8a2[0] = 249;
            buf22.push(ui8a2.slice(0, 3));
            success = true;
          } else {
            encodeFloat322(float);
            decoded = readFloat322(ui8a2, 1);
            if (float === decoded) {
              ui8a2[0] = 250;
              buf22.push(ui8a2.slice(0, 5));
              success = true;
            }
          }
        }
        if (!success) {
          encodeFloat642(float);
          decoded = readFloat642(ui8a2, 1);
          ui8a2[0] = 251;
          buf22.push(ui8a2.slice(0, 9));
        }
      }
    }
    encodeFloat2.encodedSize = function encodedSize82(token, options) {
      const float = token.value;
      if (float === false || float === true || float === null || float === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat162(float);
        let decoded = readFloat162(ui8a2, 1);
        if (float === decoded || Number.isNaN(float)) {
          return 3;
        }
        encodeFloat322(float);
        decoded = readFloat322(ui8a2, 1);
        if (float === decoded) {
          return 5;
        }
      }
      return 9;
    };
    var buffer2 = new ArrayBuffer(9);
    var dataView2 = new DataView(buffer2, 1);
    var ui8a2 = new Uint8Array(buffer2, 0);
    function encodeFloat162(inp) {
      if (inp === Infinity) {
        dataView2.setUint16(0, 31744, false);
      } else if (inp === -Infinity) {
        dataView2.setUint16(0, 64512, false);
      } else if (Number.isNaN(inp)) {
        dataView2.setUint16(0, 32256, false);
      } else {
        dataView2.setFloat32(0, inp);
        const valu32 = dataView2.getUint32(0);
        const exponent = (valu32 & 2139095040) >> 23;
        const mantissa = valu32 & 8388607;
        if (exponent === 255) {
          dataView2.setUint16(0, 31744, false);
        } else if (exponent === 0) {
          dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
        } else {
          const logicalExponent = exponent - 127;
          if (logicalExponent < -24) {
            dataView2.setUint16(0, 0);
          } else if (logicalExponent < -14) {
            dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
          } else {
            dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
          }
        }
      }
    }
    function readFloat162(ui8a22, pos) {
      if (ui8a22.length - pos < 2) {
        throw new Error(`${decodeErrPrefix2} not enough data for float16`);
      }
      const half = (ui8a22[pos] << 8) + ui8a22[pos + 1];
      if (half === 31744) {
        return Infinity;
      }
      if (half === 64512) {
        return -Infinity;
      }
      if (half === 32256) {
        return NaN;
      }
      const exp = half >> 10 & 31;
      const mant = half & 1023;
      let val;
      if (exp === 0) {
        val = mant * 2 ** -24;
      } else if (exp !== 31) {
        val = (mant + 1024) * 2 ** (exp - 25);
      } else {
        val = mant === 0 ? Infinity : NaN;
      }
      return half & 32768 ? -val : val;
    }
    function encodeFloat322(inp) {
      dataView2.setFloat32(0, inp, false);
    }
    function readFloat322(ui8a22, pos) {
      if (ui8a22.length - pos < 4) {
        throw new Error(`${decodeErrPrefix2} not enough data for float32`);
      }
      const offset = (ui8a22.byteOffset || 0) + pos;
      return new DataView(ui8a22.buffer, offset, 4).getFloat32(0, false);
    }
    function encodeFloat642(inp) {
      dataView2.setFloat64(0, inp, false);
    }
    function readFloat642(ui8a22, pos) {
      if (ui8a22.length - pos < 8) {
        throw new Error(`${decodeErrPrefix2} not enough data for float64`);
      }
      const offset = (ui8a22.byteOffset || 0) + pos;
      return new DataView(ui8a22.buffer, offset, 8).getFloat64(0, false);
    }
    encodeFloat2.compareTokens = encodeUint2.compareTokens;
    function invalidMinor2(data, pos, minor) {
      throw new Error(`${decodeErrPrefix2} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
    }
    function errorer2(msg) {
      return () => {
        throw new Error(`${decodeErrPrefix2} ${msg}`);
      };
    }
    var jump2 = [];
    for (let i = 0; i <= 23; i++) {
      jump2[i] = invalidMinor2;
    }
    jump2[24] = decodeUint82;
    jump2[25] = decodeUint162;
    jump2[26] = decodeUint322;
    jump2[27] = decodeUint642;
    jump2[28] = invalidMinor2;
    jump2[29] = invalidMinor2;
    jump2[30] = invalidMinor2;
    jump2[31] = invalidMinor2;
    for (let i = 32; i <= 55; i++) {
      jump2[i] = invalidMinor2;
    }
    jump2[56] = decodeNegint82;
    jump2[57] = decodeNegint162;
    jump2[58] = decodeNegint322;
    jump2[59] = decodeNegint642;
    jump2[60] = invalidMinor2;
    jump2[61] = invalidMinor2;
    jump2[62] = invalidMinor2;
    jump2[63] = invalidMinor2;
    for (let i = 64; i <= 87; i++) {
      jump2[i] = decodeBytesCompact2;
    }
    jump2[88] = decodeBytes82;
    jump2[89] = decodeBytes162;
    jump2[90] = decodeBytes322;
    jump2[91] = decodeBytes642;
    jump2[92] = invalidMinor2;
    jump2[93] = invalidMinor2;
    jump2[94] = invalidMinor2;
    jump2[95] = errorer2("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump2[i] = decodeStringCompact2;
    }
    jump2[120] = decodeString82;
    jump2[121] = decodeString162;
    jump2[122] = decodeString322;
    jump2[123] = decodeString642;
    jump2[124] = invalidMinor2;
    jump2[125] = invalidMinor2;
    jump2[126] = invalidMinor2;
    jump2[127] = errorer2("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump2[i] = decodeArrayCompact2;
    }
    jump2[152] = decodeArray82;
    jump2[153] = decodeArray162;
    jump2[154] = decodeArray322;
    jump2[155] = decodeArray642;
    jump2[156] = invalidMinor2;
    jump2[157] = invalidMinor2;
    jump2[158] = invalidMinor2;
    jump2[159] = decodeArrayIndefinite2;
    for (let i = 160; i <= 183; i++) {
      jump2[i] = decodeMapCompact2;
    }
    jump2[184] = decodeMap82;
    jump2[185] = decodeMap162;
    jump2[186] = decodeMap322;
    jump2[187] = decodeMap642;
    jump2[188] = invalidMinor2;
    jump2[189] = invalidMinor2;
    jump2[190] = invalidMinor2;
    jump2[191] = decodeMapIndefinite2;
    for (let i = 192; i <= 215; i++) {
      jump2[i] = decodeTagCompact2;
    }
    jump2[216] = decodeTag82;
    jump2[217] = decodeTag162;
    jump2[218] = decodeTag322;
    jump2[219] = decodeTag642;
    jump2[220] = invalidMinor2;
    jump2[221] = invalidMinor2;
    jump2[222] = invalidMinor2;
    jump2[223] = invalidMinor2;
    for (let i = 224; i <= 243; i++) {
      jump2[i] = errorer2("simple values are not supported");
    }
    jump2[244] = invalidMinor2;
    jump2[245] = invalidMinor2;
    jump2[246] = invalidMinor2;
    jump2[247] = decodeUndefined2;
    jump2[248] = errorer2("simple values are not supported");
    jump2[249] = decodeFloat162;
    jump2[250] = decodeFloat322;
    jump2[251] = decodeFloat642;
    jump2[252] = invalidMinor2;
    jump2[253] = invalidMinor2;
    jump2[254] = invalidMinor2;
    jump2[255] = decodeBreak2;
    var quick2 = [];
    for (let i = 0; i < 24; i++) {
      quick2[i] = new Token2(Type2.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick2[31 - i] = new Token2(Type2.negint, i, 1);
    }
    quick2[64] = new Token2(Type2.bytes, new Uint8Array(0), 1);
    quick2[96] = new Token2(Type2.string, "", 1);
    quick2[128] = new Token2(Type2.array, 0, 1);
    quick2[160] = new Token2(Type2.map, 0, 1);
    quick2[244] = new Token2(Type2.false, false, 1);
    quick2[245] = new Token2(Type2.true, true, 1);
    quick2[246] = new Token2(Type2.null, null, 1);
    function quickEncodeToken2(token) {
      switch (token.type) {
        case Type2.false:
          return fromArray2([244]);
        case Type2.true:
          return fromArray2([245]);
        case Type2.null:
          return fromArray2([246]);
        case Type2.bytes:
          if (!token.value.length) {
            return fromArray2([64]);
          }
          return;
        case Type2.string:
          if (token.value === "") {
            return fromArray2([96]);
          }
          return;
        case Type2.array:
          if (token.value === 0) {
            return fromArray2([128]);
          }
          return;
        case Type2.map:
          if (token.value === 0) {
            return fromArray2([160]);
          }
          return;
        case Type2.uint:
          if (token.value < 24) {
            return fromArray2([Number(token.value)]);
          }
          return;
        case Type2.negint:
          if (token.value >= -24) {
            return fromArray2([31 - Number(token.value)]);
          }
      }
    }
    var defaultEncodeOptions2 = {
      float64: false,
      mapSorter: mapSorter2,
      quickEncodeToken: quickEncodeToken2
    };
    function makeCborEncoders2() {
      const encoders = [];
      encoders[Type2.uint.major] = encodeUint2;
      encoders[Type2.negint.major] = encodeNegint2;
      encoders[Type2.bytes.major] = encodeBytes2;
      encoders[Type2.string.major] = encodeString2;
      encoders[Type2.array.major] = encodeArray2;
      encoders[Type2.map.major] = encodeMap2;
      encoders[Type2.tag.major] = encodeTag2;
      encoders[Type2.float.major] = encodeFloat2;
      return encoders;
    }
    var cborEncoders2 = makeCborEncoders2();
    var buf2 = new Bl2();
    var Ref2 = class {
      constructor(obj, parent) {
        this.obj = obj;
        this.parent = parent;
      }
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix2} object contains circular references`);
        }
        return new Ref2(obj, stack);
      }
    };
    var simpleTokens2 = {
      null: new Token2(Type2.null, null),
      undefined: new Token2(Type2.undefined, void 0),
      true: new Token2(Type2.true, true),
      false: new Token2(Type2.false, false),
      emptyArray: new Token2(Type2.array, 0),
      emptyMap: new Token2(Type2.map, 0)
    };
    var typeEncoders2 = {
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token2(Type2.float, obj);
        } else if (obj >= 0) {
          return new Token2(Type2.uint, obj);
        } else {
          return new Token2(Type2.negint, obj);
        }
      },
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token2(Type2.uint, obj);
        } else {
          return new Token2(Type2.negint, obj);
        }
      },
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, obj);
      },
      string(obj, _typ, _options, _refStack) {
        return new Token2(Type2.string, obj);
      },
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens2.true : simpleTokens2.false;
      },
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens2.null;
      },
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens2.undefined;
      },
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, new Uint8Array(obj));
      },
      DataView(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens2.emptyArray,
              new Token2(Type2.break)
            ];
          }
          return simpleTokens2.emptyArray;
        }
        refStack = Ref2.createCheck(refStack, obj);
        const entries = [];
        let i = 0;
        for (const e of obj) {
          entries[i++] = objectToTokens2(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [
            new Token2(Type2.array, obj.length),
            entries,
            new Token2(Type2.break)
          ];
        }
        return [
          new Token2(Type2.array, obj.length),
          entries
        ];
      },
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys = isMap ? obj.keys() : Object.keys(obj);
        const length22 = isMap ? obj.size : keys.length;
        if (!length22) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens2.emptyMap,
              new Token2(Type2.break)
            ];
          }
          return simpleTokens2.emptyMap;
        }
        refStack = Ref2.createCheck(refStack, obj);
        const entries = [];
        let i = 0;
        for (const key of keys) {
          entries[i++] = [
            objectToTokens2(key, options, refStack),
            objectToTokens2(isMap ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries2(entries, options);
        if (options.addBreakTokens) {
          return [
            new Token2(Type2.map, length22),
            entries,
            new Token2(Type2.break)
          ];
        }
        return [
          new Token2(Type2.map, length22),
          entries
        ];
      }
    };
    typeEncoders2.Map = typeEncoders2.Object;
    typeEncoders2.Buffer = typeEncoders2.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders2[`${typ}Array`] = typeEncoders2.DataView;
    }
    function objectToTokens2(obj, options = {}, refStack) {
      const typ = is22(obj);
      const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders2[typ];
      if (typeof customTypeEncoder === "function") {
        const tokens = customTypeEncoder(obj, typ, options, refStack);
        if (tokens != null) {
          return tokens;
        }
      }
      const typeEncoder = typeEncoders2[typ];
      if (!typeEncoder) {
        throw new Error(`${encodeErrPrefix2} unsupported type: ${typ}`);
      }
      return typeEncoder(obj, typ, options, refStack);
    }
    function sortMapEntries2(entries, options) {
      if (options.mapSorter) {
        entries.sort(options.mapSorter);
      }
    }
    function mapSorter2(e1, e2) {
      const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
      const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
      if (keyToken1.type !== keyToken2.type) {
        return keyToken1.type.compare(keyToken2.type);
      }
      const major = keyToken1.type.major;
      const tcmp = cborEncoders2[major].compareTokens(keyToken1, keyToken2);
      if (tcmp === 0) {
        console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
      }
      return tcmp;
    }
    function tokensToEncoded2(buf22, tokens, encoders, options) {
      if (Array.isArray(tokens)) {
        for (const token of tokens) {
          tokensToEncoded2(buf22, token, encoders, options);
        }
      } else {
        encoders[tokens.type.major](buf22, tokens, options);
      }
    }
    function encodeCustom2(data, encoders, options) {
      const tokens = objectToTokens2(data, options);
      if (!Array.isArray(tokens) && options.quickEncodeToken) {
        const quickBytes = options.quickEncodeToken(tokens);
        if (quickBytes) {
          return quickBytes;
        }
        const encoder = encoders[tokens.type.major];
        if (encoder.encodedSize) {
          const size = encoder.encodedSize(tokens, options);
          const buf22 = new Bl2(size);
          encoder(buf22, tokens, options);
          if (buf22.chunks.length !== 1) {
            throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
          }
          return asU8A2(buf22.chunks[0]);
        }
      }
      buf2.reset();
      tokensToEncoded2(buf2, tokens, encoders, options);
      return buf2.toBytes(true);
    }
    function encode62(data, options) {
      options = Object.assign({}, defaultEncodeOptions2, options);
      return encodeCustom2(data, cborEncoders2, options);
    }
    var defaultDecodeOptions = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    var Tokeniser = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
      }
      done() {
        return this.pos >= this.data.length;
      }
      next() {
        const byt = this.data[this.pos];
        let token = quick2[byt];
        if (token === void 0) {
          const decoder2 = jump2[byt];
          if (!decoder2) {
            throw new Error(`${decodeErrPrefix2} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder2(this.data, this.pos, minor, this.options);
        }
        this.pos += token.encodedLength;
        return token;
      }
    };
    var DONE2 = Symbol.for("DONE");
    var BREAK2 = Symbol.for("BREAK");
    function tokenToArray(token, tokeniser, options) {
      const arr = [];
      for (let i = 0; i < token.value; i++) {
        const value = tokensToObject(tokeniser, options);
        if (value === BREAK2) {
          if (token.value === Infinity) {
            break;
          }
          throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed array`);
        }
        if (value === DONE2) {
          throw new Error(`${decodeErrPrefix2} found array but not enough entries (got ${i}, expected ${token.value})`);
        }
        arr[i] = value;
      }
      return arr;
    }
    function tokenToMap(token, tokeniser, options) {
      const useMaps = options.useMaps === true;
      const obj = useMaps ? void 0 : {};
      const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
      for (let i = 0; i < token.value; i++) {
        const key = tokensToObject(tokeniser, options);
        if (key === BREAK2) {
          if (token.value === Infinity) {
            break;
          }
          throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed map`);
        }
        if (key === DONE2) {
          throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
        }
        if (useMaps !== true && typeof key !== "string") {
          throw new Error(`${decodeErrPrefix2} non-string keys not supported (got ${typeof key})`);
        }
        const value = tokensToObject(tokeniser, options);
        if (value === DONE2) {
          throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
        }
        if (useMaps) {
          m.set(key, value);
        } else {
          obj[key] = value;
        }
      }
      return useMaps ? m : obj;
    }
    function tokensToObject(tokeniser, options) {
      if (tokeniser.done()) {
        return DONE2;
      }
      const token = tokeniser.next();
      if (token.type === Type2.break) {
        return BREAK2;
      }
      if (token.type.terminal) {
        return token.value;
      }
      if (token.type === Type2.array) {
        return tokenToArray(token, tokeniser, options);
      }
      if (token.type === Type2.map) {
        return tokenToMap(token, tokeniser, options);
      }
      if (token.type === Type2.tag) {
        if (options.tags && typeof options.tags[token.value] === "function") {
          const tagged = tokensToObject(tokeniser, options);
          return options.tags[token.value](tagged);
        }
        throw new Error(`${decodeErrPrefix2} tag not supported (${token.value})`);
      }
      throw new Error("unsupported");
    }
    function decode62(data, options) {
      if (!(data instanceof Uint8Array)) {
        throw new Error(`${decodeErrPrefix2} data to decode must be a Uint8Array`);
      }
      options = Object.assign({}, defaultDecodeOptions, options);
      const tokeniser = options.tokenizer || new Tokeniser(data, options);
      const decoded = tokensToObject(tokeniser, options);
      if (decoded === DONE2) {
        throw new Error(`${decodeErrPrefix2} did not find any content to decode`);
      }
      if (decoded === BREAK2) {
        throw new Error(`${decodeErrPrefix2} got unexpected break`);
      }
      if (!tokeniser.done()) {
        throw new Error(`${decodeErrPrefix2} too many terminals, data makes no sense`);
      }
      return decoded;
    }
    var CID_CBOR_TAG2 = 42;
    function cidEncoder2(obj) {
      if (obj.asCID !== obj) {
        return null;
      }
      const cid2 = CID2.asCID(obj);
      if (!cid2) {
        return null;
      }
      const bytes = new Uint8Array(cid2.bytes.byteLength + 1);
      bytes.set(cid2.bytes, 1);
      return [
        new Token2(Type2.tag, CID_CBOR_TAG2),
        new Token2(Type2.bytes, bytes)
      ];
    }
    function undefinedEncoder2() {
      throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
    }
    function numberEncoder2(num) {
      if (Number.isNaN(num)) {
        throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
      }
      if (num === Infinity || num === -Infinity) {
        throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
      }
      return null;
    }
    var encodeOptions2 = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder2,
        undefined: undefinedEncoder2,
        number: numberEncoder2
      }
    };
    function cidDecoder2(bytes) {
      if (bytes[0] !== 0) {
        throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
      }
      return CID2.decode(bytes.subarray(1));
    }
    var decodeOptions2 = {
      allowIndefinite: false,
      coerceUndefinedToNull: true,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions2.tags[CID_CBOR_TAG2] = cidDecoder2;
    var name22 = "dag-cbor";
    var code3 = 113;
    var encode72 = (node) => encode62(node, encodeOptions2);
    var decode72 = (data) => decode62(data, decodeOptions2);
    var cborEncode = encode72;
    var cborDecode = decode72;
    var dataToCborBlock = async (data) => {
      return encode52({
        value: data,
        codec: esm_exports2,
        hasher: sha2563
      });
    };
    var cidForCbor4 = async (data) => {
      const block = await dataToCborBlock(data);
      return block.cid;
    };
    var cborBytesToRecord = (bytes) => {
      const val = cborDecode(bytes);
      if (!check_exports.is(val, schema.map)) {
        throw new Error(`Expected object, got: ${val}`);
      }
      return val;
    };
    var verifyCidForBytes = async (cid2, bytes) => {
      const digest22 = await sha2563.digest(bytes);
      const expected = CID2.createV1(cid2.code, digest22);
      if (!cid2.equals(expected)) {
        throw new Error(
          `Not a valid CID for bytes. Expected: ${expected.toString()} Got: ${cid2.toString()}`
        );
      }
    };
    var sha256ToCid = (hash, codec) => {
      const digest22 = digest_exports2.create(sha2563.code, hash);
      return CID2.createV1(codec, digest22);
    };
    var sha256RawToCid = (hash) => {
      return sha256ToCid(hash, code22);
    };
    var VerifyCidTransform = class extends import_stream5.Transform {
      constructor(cid2) {
        super();
        this.cid = cid2;
        this.hasher = import_crypto22.default.createHash("sha256");
      }
      _transform(chunk, _enc, cb) {
        this.hasher.update(chunk);
        cb(null, chunk);
      }
      _flush(cb) {
        try {
          const cid2 = sha256RawToCid(this.hasher.digest());
          if (this.cid.equals(cid2)) {
            return cb();
          } else {
            return cb(new VerifyCidError(this.cid, cid2));
          }
        } catch (_err) {
          const err = _err instanceof Error ? _err : new Error("Unexpected error", { cause: _err });
          return cb(err);
        }
      }
    };
    var VerifyCidError = class extends Error {
      constructor(expected, actual) {
        super("Bad cid check");
        this.expected = expected;
        this.actual = actual;
      }
    };
    var decoder;
    try {
      decoder = new TextDecoder();
    } catch (error) {
    }
    var src22;
    var srcEnd;
    var position = 0;
    var EMPTY_ARRAY = [];
    var LEGACY_RECORD_INLINE_ID = 105;
    var RECORD_DEFINITIONS_ID = 57342;
    var RECORD_INLINE_ID = 57343;
    var BUNDLED_STRINGS_ID = 57337;
    var PACKED_REFERENCE_TAG_ID = 6;
    var STOP_CODE = {};
    var strings = EMPTY_ARRAY;
    var stringPosition = 0;
    var currentDecoder = {};
    var currentStructures;
    var srcString;
    var srcStringStart = 0;
    var srcStringEnd = 0;
    var bundledStrings;
    var referenceMap;
    var currentExtensions = [];
    var currentExtensionRanges = [];
    var packedValues;
    var dataView22;
    var restoreMapsAsObject;
    var defaultOptions = {
      useRecords: false,
      mapsAsObjects: true
    };
    var sequentialMode = false;
    var Decoder22 = class {
      constructor(options) {
        if (options) {
          if ((options.keyMap || options._keyMap) && !options.useRecords) {
            options.useRecords = false;
            options.mapsAsObjects = true;
          }
          if (options.useRecords === false && options.mapsAsObjects === void 0)
            options.mapsAsObjects = true;
          if (options.getStructures)
            options.getShared = options.getStructures;
          if (options.getShared && !options.structures)
            (options.structures = []).uninitialized = true;
          if (options.keyMap) {
            this.mapKey = /* @__PURE__ */ new Map();
            for (let [k, v] of Object.entries(options.keyMap))
              this.mapKey.set(v, k);
          }
        }
        Object.assign(this, options);
      }
      decodeKey(key) {
        return this.keyMap ? this.mapKey.get(key) || key : key;
      }
      encodeKey(key) {
        return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
      }
      encodeKeys(rec) {
        if (!this._keyMap)
          return rec;
        let map = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(rec))
          map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
        return map;
      }
      decodeKeys(map) {
        if (!this._keyMap || map.constructor.name != "Map")
          return map;
        if (!this._mapKey) {
          this._mapKey = /* @__PURE__ */ new Map();
          for (let [k, v] of Object.entries(this._keyMap))
            this._mapKey.set(v, k);
        }
        let res = {};
        map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
        return res;
      }
      mapDecode(source, end) {
        let res = this.decode(source);
        if (this._keyMap) {
          switch (res.constructor.name) {
            case "Array":
              return res.map((r) => this.decodeKeys(r));
          }
        }
        return res;
      }
      decode(source, end) {
        if (src22) {
          return saveState(() => {
            clearSource();
            return this ? this.decode(source, end) : Decoder22.prototype.decode.call(defaultOptions, source, end);
          });
        }
        srcEnd = end > -1 ? end : source.length;
        position = 0;
        stringPosition = 0;
        srcStringEnd = 0;
        srcString = null;
        strings = EMPTY_ARRAY;
        bundledStrings = null;
        src22 = source;
        try {
          dataView22 = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
        } catch (error) {
          src22 = null;
          if (source instanceof Uint8Array)
            throw error;
          throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
        }
        if (this instanceof Decoder22) {
          currentDecoder = this;
          packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
          if (this.structures) {
            currentStructures = this.structures;
            return checkedRead();
          } else if (!currentStructures || currentStructures.length > 0) {
            currentStructures = [];
          }
        } else {
          currentDecoder = defaultOptions;
          if (!currentStructures || currentStructures.length > 0)
            currentStructures = [];
          packedValues = null;
        }
        return checkedRead();
      }
      decodeMultiple(source, forEach2) {
        let values, lastPosition = 0;
        try {
          let size = source.length;
          sequentialMode = true;
          let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
          if (forEach2) {
            if (forEach2(value) === false) {
              return;
            }
            while (position < size) {
              lastPosition = position;
              if (forEach2(checkedRead()) === false) {
                return;
              }
            }
          } else {
            values = [value];
            while (position < size) {
              lastPosition = position;
              values.push(checkedRead());
            }
            return values;
          }
        } catch (error) {
          error.lastPosition = lastPosition;
          error.values = values;
          throw error;
        } finally {
          sequentialMode = false;
          clearSource();
        }
      }
    };
    function checkedRead() {
      try {
        let result = read22();
        if (bundledStrings) {
          if (position >= bundledStrings.postBundlePosition) {
            let error = new Error("Unexpected bundle position");
            error.incomplete = true;
            throw error;
          }
          position = bundledStrings.postBundlePosition;
          bundledStrings = null;
        }
        if (position == srcEnd) {
          currentStructures = null;
          src22 = null;
          if (referenceMap)
            referenceMap = null;
        } else if (position > srcEnd) {
          let error = new Error("Unexpected end of CBOR data");
          error.incomplete = true;
          throw error;
        } else if (!sequentialMode) {
          throw new Error("Data read, but end of buffer not reached");
        }
        return result;
      } catch (error) {
        clearSource();
        if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
          error.incomplete = true;
        }
        throw error;
      }
    }
    function read22() {
      let token = src22[position++];
      let majorType = token >> 5;
      token = token & 31;
      if (token > 23) {
        switch (token) {
          case 24:
            token = src22[position++];
            break;
          case 25:
            if (majorType == 7) {
              return getFloat16();
            }
            token = dataView22.getUint16(position);
            position += 2;
            break;
          case 26:
            if (majorType == 7) {
              let value = dataView22.getFloat32(position);
              if (currentDecoder.useFloat32 > 2) {
                let multiplier = mult10[(src22[position] & 127) << 1 | src22[position + 1] >> 7];
                position += 4;
                return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
              }
              position += 4;
              return value;
            }
            token = dataView22.getUint32(position);
            position += 4;
            break;
          case 27:
            if (majorType == 7) {
              let value = dataView22.getFloat64(position);
              position += 8;
              return value;
            }
            if (majorType > 1) {
              if (dataView22.getUint32(position) > 0)
                throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
              token = dataView22.getUint32(position + 4);
            } else if (currentDecoder.int64AsNumber) {
              token = dataView22.getUint32(position) * 4294967296;
              token += dataView22.getUint32(position + 4);
            } else
              token = dataView22.getBigUint64(position);
            position += 8;
            break;
          case 31:
            switch (majorType) {
              case 2:
              case 3:
                throw new Error("Indefinite length not supported for byte or text strings");
              case 4:
                let array = [];
                let value, i = 0;
                while ((value = read22()) != STOP_CODE) {
                  array[i++] = value;
                }
                return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
              case 5:
                let key;
                if (currentDecoder.mapsAsObjects) {
                  let object = {};
                  if (currentDecoder.keyMap)
                    while ((key = read22()) != STOP_CODE)
                      object[safeKey(currentDecoder.decodeKey(key))] = read22();
                  else
                    while ((key = read22()) != STOP_CODE)
                      object[safeKey(key)] = read22();
                  return object;
                } else {
                  if (restoreMapsAsObject) {
                    currentDecoder.mapsAsObjects = true;
                    restoreMapsAsObject = false;
                  }
                  let map = /* @__PURE__ */ new Map();
                  if (currentDecoder.keyMap)
                    while ((key = read22()) != STOP_CODE)
                      map.set(currentDecoder.decodeKey(key), read22());
                  else
                    while ((key = read22()) != STOP_CODE)
                      map.set(key, read22());
                  return map;
                }
              case 7:
                return STOP_CODE;
              default:
                throw new Error("Invalid major type for indefinite length " + majorType);
            }
          default:
            throw new Error("Unknown token " + token);
        }
      }
      switch (majorType) {
        case 0:
          return token;
        case 1:
          return ~token;
        case 2:
          return readBin(token);
        case 3:
          if (srcStringEnd >= position) {
            return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);
          }
          if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
            let string22 = token < 16 ? shortStringInJS(token) : longStringInJS(token);
            if (string22 != null)
              return string22;
          }
          return readFixedString(token);
        case 4:
          let array = new Array(token);
          for (let i = 0; i < token; i++)
            array[i] = read22();
          return array;
        case 5:
          if (currentDecoder.mapsAsObjects) {
            let object = {};
            if (currentDecoder.keyMap)
              for (let i = 0; i < token; i++)
                object[safeKey(currentDecoder.decodeKey(read22()))] = read22();
            else
              for (let i = 0; i < token; i++)
                object[safeKey(read22())] = read22();
            return object;
          } else {
            if (restoreMapsAsObject) {
              currentDecoder.mapsAsObjects = true;
              restoreMapsAsObject = false;
            }
            let map = /* @__PURE__ */ new Map();
            if (currentDecoder.keyMap)
              for (let i = 0; i < token; i++)
                map.set(currentDecoder.decodeKey(read22()), read22());
            else
              for (let i = 0; i < token; i++)
                map.set(read22(), read22());
            return map;
          }
        case 6:
          if (token >= BUNDLED_STRINGS_ID) {
            let structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read)
                structure.read = createStructureReader(structure);
              return structure.read();
            }
            if (token < 65536) {
              if (token == RECORD_INLINE_ID) {
                let length22 = readJustLength();
                let id = read22();
                let structure2 = read22();
                recordDefinition(id, structure2);
                let object = {};
                if (currentDecoder.keyMap)
                  for (let i = 2; i < length22; i++) {
                    let key = currentDecoder.decodeKey(structure2[i - 2]);
                    object[safeKey(key)] = read22();
                  }
                else
                  for (let i = 2; i < length22; i++) {
                    let key = structure2[i - 2];
                    object[safeKey(key)] = read22();
                  }
                return object;
              } else if (token == RECORD_DEFINITIONS_ID) {
                let length22 = readJustLength();
                let id = read22();
                for (let i = 2; i < length22; i++) {
                  recordDefinition(id++, read22());
                }
                return read22();
              } else if (token == BUNDLED_STRINGS_ID) {
                return readBundleExt();
              }
              if (currentDecoder.getShared) {
                loadShared();
                structure = currentStructures[token & 8191];
                if (structure) {
                  if (!structure.read)
                    structure.read = createStructureReader(structure);
                  return structure.read();
                }
              }
            }
          }
          let extension = currentExtensions[token];
          if (extension) {
            if (extension.handlesRead)
              return extension(read22);
            else
              return extension(read22());
          } else {
            let input = read22();
            for (let i = 0; i < currentExtensionRanges.length; i++) {
              let value = currentExtensionRanges[i](token, input);
              if (value !== void 0)
                return value;
            }
            return new Tag(input, token);
          }
        case 7:
          switch (token) {
            case 20:
              return false;
            case 21:
              return true;
            case 22:
              return null;
            case 23:
              return;
            case 31:
            default:
              let packedValue = (packedValues || getPackedValues())[token];
              if (packedValue !== void 0)
                return packedValue;
              throw new Error("Unknown token " + token);
          }
        default:
          if (isNaN(token)) {
            let error = new Error("Unexpected end of CBOR data");
            error.incomplete = true;
            throw error;
          }
          throw new Error("Unknown CBOR token " + token);
      }
    }
    var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
    function createStructureReader(structure) {
      function readObject() {
        let length22 = src22[position++];
        length22 = length22 & 31;
        if (length22 > 23) {
          switch (length22) {
            case 24:
              length22 = src22[position++];
              break;
            case 25:
              length22 = dataView22.getUint16(position);
              position += 2;
              break;
            case 26:
              length22 = dataView22.getUint32(position);
              position += 4;
              break;
            default:
              throw new Error("Expected array header, but got " + src22[position - 1]);
          }
        }
        let compiledReader = this.compiledReader;
        while (compiledReader) {
          if (compiledReader.propertyCount === length22)
            return compiledReader(read22);
          compiledReader = compiledReader.next;
        }
        if (this.slowReads++ >= 3) {
          let array = this.length == length22 ? this : this.slice(0, length22);
          compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
          if (this.compiledReader)
            compiledReader.next = this.compiledReader;
          compiledReader.propertyCount = length22;
          this.compiledReader = compiledReader;
          return compiledReader(read22);
        }
        let object = {};
        if (currentDecoder.keyMap)
          for (let i = 0; i < length22; i++)
            object[safeKey(currentDecoder.decodeKey(this[i]))] = read22();
        else
          for (let i = 0; i < length22; i++) {
            object[safeKey(this[i])] = read22();
          }
        return object;
      }
      structure.slowReads = 0;
      return readObject;
    }
    function safeKey(key) {
      return key === "__proto__" ? "__proto_" : key;
    }
    var readFixedString = readStringJS;
    var readString8 = readStringJS;
    var readString16 = readStringJS;
    var readString32 = readStringJS;
    var isNativeAccelerationEnabled = false;
    function setExtractor(extractStrings) {
      isNativeAccelerationEnabled = true;
      readFixedString = readString(1);
      readString8 = readString(2);
      readString16 = readString(3);
      readString32 = readString(5);
      function readString(headerLength) {
        return function readString2(length22) {
          let string22 = strings[stringPosition++];
          if (string22 == null) {
            if (bundledStrings)
              return readStringJS(length22);
            let extraction = extractStrings(position, srcEnd, length22, src22);
            if (typeof extraction == "string") {
              string22 = extraction;
              strings = EMPTY_ARRAY;
            } else {
              strings = extraction;
              stringPosition = 1;
              srcStringEnd = 1;
              string22 = strings[0];
              if (string22 === void 0)
                throw new Error("Unexpected end of buffer");
            }
          }
          let srcStringLength = string22.length;
          if (srcStringLength <= length22) {
            position += length22;
            return string22;
          }
          srcString = string22;
          srcStringStart = position;
          srcStringEnd = position + srcStringLength;
          position += length22;
          return string22.slice(0, length22);
        };
      }
    }
    function readStringJS(length22) {
      let result;
      if (length22 < 16) {
        if (result = shortStringInJS(length22))
          return result;
      }
      if (length22 > 64 && decoder)
        return decoder.decode(src22.subarray(position, position += length22));
      const end = position + length22;
      const units = [];
      result = "";
      while (position < end) {
        const byte1 = src22[position++];
        if ((byte1 & 128) === 0) {
          units.push(byte1);
        } else if ((byte1 & 224) === 192) {
          const byte2 = src22[position++] & 63;
          units.push((byte1 & 31) << 6 | byte2);
        } else if ((byte1 & 240) === 224) {
          const byte2 = src22[position++] & 63;
          const byte3 = src22[position++] & 63;
          units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 248) === 240) {
          const byte2 = src22[position++] & 63;
          const byte3 = src22[position++] & 63;
          const byte4 = src22[position++] & 63;
          let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
          if (unit > 65535) {
            unit -= 65536;
            units.push(unit >>> 10 & 1023 | 55296);
            unit = 56320 | unit & 1023;
          }
          units.push(unit);
        } else {
          units.push(byte1);
        }
        if (units.length >= 4096) {
          result += fromCharCode.apply(String, units);
          units.length = 0;
        }
      }
      if (units.length > 0) {
        result += fromCharCode.apply(String, units);
      }
      return result;
    }
    var fromCharCode = String.fromCharCode;
    function longStringInJS(length22) {
      let start = position;
      let bytes = new Array(length22);
      for (let i = 0; i < length22; i++) {
        const byte = src22[position++];
        if ((byte & 128) > 0) {
          position = start;
          return;
        }
        bytes[i] = byte;
      }
      return fromCharCode.apply(String, bytes);
    }
    function shortStringInJS(length22) {
      if (length22 < 4) {
        if (length22 < 2) {
          if (length22 === 0)
            return "";
          else {
            let a = src22[position++];
            if ((a & 128) > 1) {
              position -= 1;
              return;
            }
            return fromCharCode(a);
          }
        } else {
          let a = src22[position++];
          let b = src22[position++];
          if ((a & 128) > 0 || (b & 128) > 0) {
            position -= 2;
            return;
          }
          if (length22 < 3)
            return fromCharCode(a, b);
          let c = src22[position++];
          if ((c & 128) > 0) {
            position -= 3;
            return;
          }
          return fromCharCode(a, b, c);
        }
      } else {
        let a = src22[position++];
        let b = src22[position++];
        let c = src22[position++];
        let d = src22[position++];
        if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
          position -= 4;
          return;
        }
        if (length22 < 6) {
          if (length22 === 4)
            return fromCharCode(a, b, c, d);
          else {
            let e = src22[position++];
            if ((e & 128) > 0) {
              position -= 5;
              return;
            }
            return fromCharCode(a, b, c, d, e);
          }
        } else if (length22 < 8) {
          let e = src22[position++];
          let f = src22[position++];
          if ((e & 128) > 0 || (f & 128) > 0) {
            position -= 6;
            return;
          }
          if (length22 < 7)
            return fromCharCode(a, b, c, d, e, f);
          let g = src22[position++];
          if ((g & 128) > 0) {
            position -= 7;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g);
        } else {
          let e = src22[position++];
          let f = src22[position++];
          let g = src22[position++];
          let h = src22[position++];
          if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
            position -= 8;
            return;
          }
          if (length22 < 10) {
            if (length22 === 8)
              return fromCharCode(a, b, c, d, e, f, g, h);
            else {
              let i = src22[position++];
              if ((i & 128) > 0) {
                position -= 9;
                return;
              }
              return fromCharCode(a, b, c, d, e, f, g, h, i);
            }
          } else if (length22 < 12) {
            let i = src22[position++];
            let j = src22[position++];
            if ((i & 128) > 0 || (j & 128) > 0) {
              position -= 10;
              return;
            }
            if (length22 < 11)
              return fromCharCode(a, b, c, d, e, f, g, h, i, j);
            let k = src22[position++];
            if ((k & 128) > 0) {
              position -= 11;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
          } else {
            let i = src22[position++];
            let j = src22[position++];
            let k = src22[position++];
            let l = src22[position++];
            if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
              position -= 12;
              return;
            }
            if (length22 < 14) {
              if (length22 === 12)
                return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
              else {
                let m = src22[position++];
                if ((m & 128) > 0) {
                  position -= 13;
                  return;
                }
                return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
              }
            } else {
              let m = src22[position++];
              let n = src22[position++];
              if ((m & 128) > 0 || (n & 128) > 0) {
                position -= 14;
                return;
              }
              if (length22 < 15)
                return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
              let o = src22[position++];
              if ((o & 128) > 0) {
                position -= 15;
                return;
              }
              return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
            }
          }
        }
      }
    }
    function readBin(length22) {
      return currentDecoder.copyBuffers ? Uint8Array.prototype.slice.call(src22, position, position += length22) : src22.subarray(position, position += length22);
    }
    var f32Array = new Float32Array(1);
    var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
    function getFloat16() {
      let byte0 = src22[position++];
      let byte1 = src22[position++];
      let exponent = (byte0 & 127) >> 2;
      if (exponent === 31) {
        if (byte1 || byte0 & 3)
          return NaN;
        return byte0 & 128 ? -Infinity : Infinity;
      }
      if (exponent === 0) {
        let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
        return byte0 & 128 ? -abs : abs;
      }
      u8Array[3] = byte0 & 128 | (exponent >> 1) + 56;
      u8Array[2] = (byte0 & 7) << 5 | byte1 >> 3;
      u8Array[1] = byte1 << 5;
      u8Array[0] = 0;
      return f32Array[0];
    }
    var keyCache = new Array(4096);
    var Tag = class {
      constructor(value, tag) {
        this.value = value;
        this.tag = tag;
      }
    };
    currentExtensions[0] = (dateString) => {
      return new Date(dateString);
    };
    currentExtensions[1] = (epochSec) => {
      return new Date(Math.round(epochSec * 1e3));
    };
    currentExtensions[2] = (buffer22) => {
      let value = BigInt(0);
      for (let i = 0, l = buffer22.byteLength; i < l; i++) {
        value = BigInt(buffer22[i]) + value << BigInt(8);
      }
      return value;
    };
    currentExtensions[3] = (buffer22) => {
      return BigInt(-1) - currentExtensions[2](buffer22);
    };
    currentExtensions[4] = (fraction) => {
      return +(fraction[1] + "e" + fraction[0]);
    };
    currentExtensions[5] = (fraction) => {
      return fraction[1] * Math.exp(fraction[0] * Math.log(2));
    };
    var recordDefinition = (id, structure) => {
      id = id - 57344;
      let existingStructure = currentStructures[id];
      if (existingStructure && existingStructure.isShared) {
        (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
      }
      currentStructures[id] = structure;
      structure.read = createStructureReader(structure);
    };
    currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
      let length22 = data.length;
      let structure = data[1];
      recordDefinition(data[0], structure);
      let object = {};
      for (let i = 2; i < length22; i++) {
        let key = structure[i - 2];
        object[safeKey(key)] = data[i];
      }
      return object;
    };
    currentExtensions[14] = (value) => {
      if (bundledStrings)
        return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);
      return new Tag(value, 14);
    };
    currentExtensions[15] = (value) => {
      if (bundledStrings)
        return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);
      return new Tag(value, 15);
    };
    var glbl = { Error, RegExp };
    currentExtensions[27] = (data) => {
      return (glbl[data[0]] || Error)(data[1], data[2]);
    };
    var packedTable = (read3) => {
      if (src22[position++] != 132)
        throw new Error("Packed values structure must be followed by a 4 element array");
      let newPackedValues = read3();
      packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
      packedValues.prefixes = read3();
      packedValues.suffixes = read3();
      return read3();
    };
    packedTable.handlesRead = true;
    currentExtensions[51] = packedTable;
    currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => {
      if (!packedValues) {
        if (currentDecoder.getShared)
          loadShared();
        else
          return new Tag(data, PACKED_REFERENCE_TAG_ID);
      }
      if (typeof data == "number")
        return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];
      throw new Error("No support for non-integer packed references yet");
    };
    currentExtensions[28] = (read3) => {
      if (!referenceMap) {
        referenceMap = /* @__PURE__ */ new Map();
        referenceMap.id = 0;
      }
      let id = referenceMap.id++;
      let token = src22[position];
      let target2;
      if (token >> 5 == 4)
        target2 = [];
      else
        target2 = {};
      let refEntry = { target: target2 };
      referenceMap.set(id, refEntry);
      let targetProperties = read3();
      if (refEntry.used)
        return Object.assign(target2, targetProperties);
      refEntry.target = targetProperties;
      return targetProperties;
    };
    currentExtensions[28].handlesRead = true;
    currentExtensions[29] = (id) => {
      let refEntry = referenceMap.get(id);
      refEntry.used = true;
      return refEntry.target;
    };
    currentExtensions[258] = (array) => new Set(array);
    (currentExtensions[259] = (read3) => {
      if (currentDecoder.mapsAsObjects) {
        currentDecoder.mapsAsObjects = false;
        restoreMapsAsObject = true;
      }
      return read3();
    }).handlesRead = true;
    function combine(a, b) {
      if (typeof a === "string")
        return a + b;
      if (a instanceof Array)
        return a.concat(b);
      return Object.assign({}, a, b);
    }
    function getPackedValues() {
      if (!packedValues) {
        if (currentDecoder.getShared)
          loadShared();
        else
          throw new Error("No packed values available");
      }
      return packedValues;
    }
    var SHARED_DATA_TAG_ID = 1399353956;
    currentExtensionRanges.push((tag, input) => {
      if (tag >= 225 && tag <= 255)
        return combine(getPackedValues().prefixes[tag - 224], input);
      if (tag >= 28704 && tag <= 32767)
        return combine(getPackedValues().prefixes[tag - 28672], input);
      if (tag >= 1879052288 && tag <= 2147483647)
        return combine(getPackedValues().prefixes[tag - 1879048192], input);
      if (tag >= 216 && tag <= 223)
        return combine(input, getPackedValues().suffixes[tag - 216]);
      if (tag >= 27647 && tag <= 28671)
        return combine(input, getPackedValues().suffixes[tag - 27639]);
      if (tag >= 1811940352 && tag <= 1879048191)
        return combine(input, getPackedValues().suffixes[tag - 1811939328]);
      if (tag == SHARED_DATA_TAG_ID) {
        return {
          packedValues,
          structures: currentStructures.slice(0),
          version: input
        };
      }
      if (tag == 55799)
        return input;
    });
    var isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
    var typedArrays = [
      Uint8Array,
      Uint8ClampedArray,
      Uint16Array,
      Uint32Array,
      typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
      Int8Array,
      Int16Array,
      Int32Array,
      typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
      Float32Array,
      Float64Array
    ];
    var typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
    for (let i = 0; i < typedArrays.length; i++) {
      registerTypedArray(typedArrays[i], typedArrayTags[i]);
    }
    function registerTypedArray(TypedArray, tag) {
      let dvMethod = "get" + TypedArray.name.slice(0, -5);
      if (typeof TypedArray !== "function")
        TypedArray = null;
      let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
      for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
        if (!littleEndian && bytesPerElement == 1)
          continue;
        let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
        currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? (buffer22) => {
          if (!TypedArray)
            throw new Error("Could not find typed array for code " + tag);
          return new TypedArray(Uint8Array.prototype.slice.call(buffer22, 0).buffer);
        } : (buffer22) => {
          if (!TypedArray)
            throw new Error("Could not find typed array for code " + tag);
          let dv = new DataView(buffer22.buffer, buffer22.byteOffset, buffer22.byteLength);
          let elements = buffer22.length >> sizeShift;
          let ta = new TypedArray(elements);
          let method = dv[dvMethod];
          for (let i = 0; i < elements; i++) {
            ta[i] = method.call(dv, i << sizeShift, littleEndian);
          }
          return ta;
        };
      }
    }
    function readBundleExt() {
      let length22 = readJustLength();
      let bundlePosition = position + read22();
      for (let i = 2; i < length22; i++) {
        let bundleLength = readJustLength();
        position += bundleLength;
      }
      let dataPosition = position;
      position = bundlePosition;
      bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];
      bundledStrings.position0 = 0;
      bundledStrings.position1 = 0;
      bundledStrings.postBundlePosition = position;
      position = dataPosition;
      return read22();
    }
    function readJustLength() {
      let token = src22[position++] & 31;
      if (token > 23) {
        switch (token) {
          case 24:
            token = src22[position++];
            break;
          case 25:
            token = dataView22.getUint16(position);
            position += 2;
            break;
          case 26:
            token = dataView22.getUint32(position);
            position += 4;
            break;
        }
      }
      return token;
    }
    function loadShared() {
      if (currentDecoder.getShared) {
        let sharedData = saveState(() => {
          src22 = null;
          return currentDecoder.getShared();
        }) || {};
        let updatedStructures = sharedData.structures || [];
        currentDecoder.sharedVersion = sharedData.version;
        packedValues = currentDecoder.sharedValues = sharedData.packedValues;
        if (currentStructures === true)
          currentDecoder.structures = currentStructures = updatedStructures;
        else
          currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
      }
    }
    function saveState(callback) {
      let savedSrcEnd = srcEnd;
      let savedPosition = position;
      let savedStringPosition = stringPosition;
      let savedSrcStringStart = srcStringStart;
      let savedSrcStringEnd = srcStringEnd;
      let savedSrcString = srcString;
      let savedStrings = strings;
      let savedReferenceMap = referenceMap;
      let savedBundledStrings = bundledStrings;
      let savedSrc = new Uint8Array(src22.slice(0, srcEnd));
      let savedStructures = currentStructures;
      let savedDecoder = currentDecoder;
      let savedSequentialMode = sequentialMode;
      let value = callback();
      srcEnd = savedSrcEnd;
      position = savedPosition;
      stringPosition = savedStringPosition;
      srcStringStart = savedSrcStringStart;
      srcStringEnd = savedSrcStringEnd;
      srcString = savedSrcString;
      strings = savedStrings;
      referenceMap = savedReferenceMap;
      bundledStrings = savedBundledStrings;
      src22 = savedSrc;
      sequentialMode = savedSequentialMode;
      currentStructures = savedStructures;
      currentDecoder = savedDecoder;
      dataView22 = new DataView(src22.buffer, src22.byteOffset, src22.byteLength);
      return value;
    }
    function clearSource() {
      src22 = null;
      referenceMap = null;
      currentStructures = null;
    }
    function addExtension(extension) {
      currentExtensions[extension.tag] = extension.decode;
    }
    var mult10 = new Array(147);
    for (let i = 0; i < 256; i++) {
      mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
    }
    var defaultDecoder = new Decoder22({ useRecords: false });
    var decode8 = defaultDecoder.decode;
    var decodeMultiple = defaultDecoder.decodeMultiple;
    var FLOAT32_OPTIONS = {
      NEVER: 0,
      ALWAYS: 1,
      DECIMAL_ROUND: 3,
      DECIMAL_FIT: 4
    };
    var textEncoder32;
    try {
      textEncoder32 = new TextEncoder();
    } catch (error) {
    }
    var extensions;
    var extensionClasses;
    var Buffer2 = globalThis.Buffer;
    var hasNodeBuffer = typeof Buffer2 !== "undefined";
    var ByteArrayAllocate = hasNodeBuffer ? Buffer2.allocUnsafeSlow : Uint8Array;
    var ByteArray = hasNodeBuffer ? Buffer2 : Uint8Array;
    var MAX_STRUCTURES = 256;
    var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
    var throwOnIterable;
    var target;
    var targetView;
    var position2 = 0;
    var safeEnd;
    var bundledStrings2 = null;
    var MAX_BUNDLE_SIZE = 61440;
    var hasNonLatin = /[\u0080-\uFFFF]/;
    var RECORD_SYMBOL = Symbol("record-id");
    var Encoder22 = class extends Decoder22 {
      constructor(options) {
        super(options);
        this.offset = 0;
        let typeBuffer;
        let start;
        let sharedStructures;
        let hasSharedUpdate;
        let structures;
        let referenceMap2;
        options = options || {};
        let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string22, position3, maxBytes) {
          return target.utf8Write(string22, position3, maxBytes);
        } : textEncoder32 && textEncoder32.encodeInto ? function(string22, position3) {
          return textEncoder32.encodeInto(string22, target.subarray(position3)).written;
        } : false;
        let encoder = this;
        let hasSharedStructures = options.structures || options.saveStructures;
        let maxSharedStructures = options.maxSharedStructures;
        if (maxSharedStructures == null)
          maxSharedStructures = hasSharedStructures ? 128 : 0;
        if (maxSharedStructures > 8190)
          throw new Error("Maximum maxSharedStructure is 8190");
        let isSequential = options.sequential;
        if (isSequential) {
          maxSharedStructures = 0;
        }
        if (!this.structures)
          this.structures = [];
        if (this.saveStructures)
          this.saveShared = this.saveStructures;
        let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;
        let sharedPackedObjectMap2;
        if (sharedValues) {
          sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
          for (let i = 0, l = sharedValues.length; i < l; i++) {
            sharedPackedObjectMap2[sharedValues[i]] = i;
          }
        }
        let recordIdsToRemove = [];
        let transitionsCount = 0;
        let serializationsSinceTransitionRebuild = 0;
        this.mapEncode = function(value, encodeOptions22) {
          if (this._keyMap && !this._mapped) {
            switch (value.constructor.name) {
              case "Array":
                value = value.map((r) => this.encodeKeys(r));
                break;
            }
          }
          return this.encode(value, encodeOptions22);
        };
        this.encode = function(value, encodeOptions22) {
          if (!target) {
            target = new ByteArrayAllocate(8192);
            targetView = new DataView(target.buffer, 0, 8192);
            position2 = 0;
          }
          safeEnd = target.length - 10;
          if (safeEnd - position2 < 2048) {
            target = new ByteArrayAllocate(target.length);
            targetView = new DataView(target.buffer, 0, target.length);
            safeEnd = target.length - 10;
            position2 = 0;
          } else if (encodeOptions22 === REUSE_BUFFER_MODE)
            position2 = position2 + 7 & 2147483640;
          start = position2;
          if (encoder.useSelfDescribedHeader) {
            targetView.setUint32(position2, 3654940416);
            position2 += 3;
          }
          referenceMap2 = encoder.structuredClone ? /* @__PURE__ */ new Map() : null;
          if (encoder.bundleStrings && typeof value !== "string") {
            bundledStrings2 = [];
            bundledStrings2.size = Infinity;
          } else
            bundledStrings2 = null;
          sharedStructures = encoder.structures;
          if (sharedStructures) {
            if (sharedStructures.uninitialized) {
              let sharedData = encoder.getShared() || {};
              encoder.structures = sharedStructures = sharedData.structures || [];
              encoder.sharedVersion = sharedData.version;
              let sharedValues2 = encoder.sharedValues = sharedData.packedValues;
              if (sharedValues2) {
                sharedPackedObjectMap2 = {};
                for (let i = 0, l = sharedValues2.length; i < l; i++)
                  sharedPackedObjectMap2[sharedValues2[i]] = i;
              }
            }
            let sharedStructuresLength = sharedStructures.length;
            if (sharedStructuresLength > maxSharedStructures && !isSequential)
              sharedStructuresLength = maxSharedStructures;
            if (!sharedStructures.transitions) {
              sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
              for (let i = 0; i < sharedStructuresLength; i++) {
                let keys = sharedStructures[i];
                if (!keys)
                  continue;
                let nextTransition, transition = sharedStructures.transitions;
                for (let j = 0, l = keys.length; j < l; j++) {
                  if (transition[RECORD_SYMBOL] === void 0)
                    transition[RECORD_SYMBOL] = i;
                  let key = keys[j];
                  nextTransition = transition[key];
                  if (!nextTransition) {
                    nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                  }
                  transition = nextTransition;
                }
                transition[RECORD_SYMBOL] = i | 1048576;
              }
            }
            if (!isSequential)
              sharedStructures.nextId = sharedStructuresLength;
          }
          if (hasSharedUpdate)
            hasSharedUpdate = false;
          structures = sharedStructures || [];
          packedObjectMap2 = sharedPackedObjectMap2;
          if (options.pack) {
            let packedValues2 = /* @__PURE__ */ new Map();
            packedValues2.values = [];
            packedValues2.encoder = encoder;
            packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
            packedValues2.objectMap = sharedPackedObjectMap2 || false;
            packedValues2.samplingPackedValues = samplingPackedValues;
            findRepetitiveStrings(value, packedValues2);
            if (packedValues2.values.length > 0) {
              target[position2++] = 216;
              target[position2++] = 51;
              writeArrayHeader(4);
              let valuesArray = packedValues2.values;
              encode92(valuesArray);
              writeArrayHeader(0);
              writeArrayHeader(0);
              packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
              for (let i = 0, l = valuesArray.length; i < l; i++) {
                packedObjectMap2[valuesArray[i]] = i;
              }
            }
          }
          throwOnIterable = encodeOptions22 & THROW_ON_ITERABLE;
          try {
            if (throwOnIterable)
              return;
            encode92(value);
            if (bundledStrings2) {
              writeBundles(start, encode92);
            }
            encoder.offset = position2;
            if (referenceMap2 && referenceMap2.idsToInsert) {
              position2 += referenceMap2.idsToInsert.length * 2;
              if (position2 > safeEnd)
                makeRoom(position2);
              encoder.offset = position2;
              let serialized = insertIds(target.subarray(start, position2), referenceMap2.idsToInsert);
              referenceMap2 = null;
              return serialized;
            }
            if (encodeOptions22 & REUSE_BUFFER_MODE) {
              target.start = start;
              target.end = position2;
              return target;
            }
            return target.subarray(start, position2);
          } finally {
            if (sharedStructures) {
              if (serializationsSinceTransitionRebuild < 10)
                serializationsSinceTransitionRebuild++;
              if (sharedStructures.length > maxSharedStructures)
                sharedStructures.length = maxSharedStructures;
              if (transitionsCount > 1e4) {
                sharedStructures.transitions = null;
                serializationsSinceTransitionRebuild = 0;
                transitionsCount = 0;
                if (recordIdsToRemove.length > 0)
                  recordIdsToRemove = [];
              } else if (recordIdsToRemove.length > 0 && !isSequential) {
                for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
                  recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
                }
                recordIdsToRemove = [];
              }
            }
            if (hasSharedUpdate && encoder.saveShared) {
              if (encoder.structures.length > maxSharedStructures) {
                encoder.structures = encoder.structures.slice(0, maxSharedStructures);
              }
              let returnBuffer = target.subarray(start, position2);
              if (encoder.updateSharedData() === false)
                return encoder.encode(value);
              return returnBuffer;
            }
            if (encodeOptions22 & RESET_BUFFER_MODE)
              position2 = start;
          }
        };
        this.findCommonStringsToPack = () => {
          samplingPackedValues = /* @__PURE__ */ new Map();
          if (!sharedPackedObjectMap2)
            sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
          return (options2) => {
            let threshold = options2 && options2.threshold || 4;
            let position3 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
            if (!sharedValues)
              sharedValues = this.sharedValues = [];
            for (let [key, status] of samplingPackedValues) {
              if (status.count > threshold) {
                sharedPackedObjectMap2[key] = position3++;
                sharedValues.push(key);
                hasSharedUpdate = true;
              }
            }
            while (this.saveShared && this.updateSharedData() === false) {
            }
            samplingPackedValues = null;
          };
        };
        const encode92 = (value) => {
          if (position2 > safeEnd)
            target = makeRoom(position2);
          var type = typeof value;
          var length22;
          if (type === "string") {
            if (packedObjectMap2) {
              let packedPosition = packedObjectMap2[value];
              if (packedPosition >= 0) {
                if (packedPosition < 16)
                  target[position2++] = packedPosition + 224;
                else {
                  target[position2++] = 198;
                  if (packedPosition & 1)
                    encode92(15 - packedPosition >> 1);
                  else
                    encode92(packedPosition - 16 >> 1);
                }
                return;
              } else if (samplingPackedValues && !options.pack) {
                let status = samplingPackedValues.get(value);
                if (status)
                  status.count++;
                else
                  samplingPackedValues.set(value, {
                    count: 1
                  });
              }
            }
            let strLength = value.length;
            if (bundledStrings2 && strLength >= 4 && strLength < 1024) {
              if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
                let extStart;
                let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
                if (position2 + maxBytes2 > safeEnd)
                  target = makeRoom(position2 + maxBytes2);
                target[position2++] = 217;
                target[position2++] = 223;
                target[position2++] = 249;
                target[position2++] = bundledStrings2.position ? 132 : 130;
                target[position2++] = 26;
                extStart = position2 - start;
                position2 += 4;
                if (bundledStrings2.position) {
                  writeBundles(start, encode92);
                }
                bundledStrings2 = ["", ""];
                bundledStrings2.size = 0;
                bundledStrings2.position = extStart;
              }
              let twoByte = hasNonLatin.test(value);
              bundledStrings2[twoByte ? 0 : 1] += value;
              target[position2++] = twoByte ? 206 : 207;
              encode92(strLength);
              return;
            }
            let headerSize;
            if (strLength < 32) {
              headerSize = 1;
            } else if (strLength < 256) {
              headerSize = 2;
            } else if (strLength < 65536) {
              headerSize = 3;
            } else {
              headerSize = 5;
            }
            let maxBytes = strLength * 3;
            if (position2 + maxBytes > safeEnd)
              target = makeRoom(position2 + maxBytes);
            if (strLength < 64 || !encodeUtf8) {
              let i, c1, c2, strPosition = position2 + headerSize;
              for (i = 0; i < strLength; i++) {
                c1 = value.charCodeAt(i);
                if (c1 < 128) {
                  target[strPosition++] = c1;
                } else if (c1 < 2048) {
                  target[strPosition++] = c1 >> 6 | 192;
                  target[strPosition++] = c1 & 63 | 128;
                } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
                  c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                  i++;
                  target[strPosition++] = c1 >> 18 | 240;
                  target[strPosition++] = c1 >> 12 & 63 | 128;
                  target[strPosition++] = c1 >> 6 & 63 | 128;
                  target[strPosition++] = c1 & 63 | 128;
                } else {
                  target[strPosition++] = c1 >> 12 | 224;
                  target[strPosition++] = c1 >> 6 & 63 | 128;
                  target[strPosition++] = c1 & 63 | 128;
                }
              }
              length22 = strPosition - position2 - headerSize;
            } else {
              length22 = encodeUtf8(value, position2 + headerSize, maxBytes);
            }
            if (length22 < 24) {
              target[position2++] = 96 | length22;
            } else if (length22 < 256) {
              if (headerSize < 2) {
                target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length22);
              }
              target[position2++] = 120;
              target[position2++] = length22;
            } else if (length22 < 65536) {
              if (headerSize < 3) {
                target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length22);
              }
              target[position2++] = 121;
              target[position2++] = length22 >> 8;
              target[position2++] = length22 & 255;
            } else {
              if (headerSize < 5) {
                target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length22);
              }
              target[position2++] = 122;
              targetView.setUint32(position2, length22);
              position2 += 4;
            }
            position2 += length22;
          } else if (type === "number") {
            if (value >>> 0 === value) {
              if (value < 24) {
                target[position2++] = value;
              } else if (value < 256) {
                target[position2++] = 24;
                target[position2++] = value;
              } else if (value < 65536) {
                target[position2++] = 25;
                target[position2++] = value >> 8;
                target[position2++] = value & 255;
              } else {
                target[position2++] = 26;
                targetView.setUint32(position2, value);
                position2 += 4;
              }
            } else if (value >> 0 === value) {
              if (value >= -24) {
                target[position2++] = 31 - value;
              } else if (value >= -256) {
                target[position2++] = 56;
                target[position2++] = ~value;
              } else if (value >= -65536) {
                target[position2++] = 57;
                targetView.setUint16(position2, ~value);
                position2 += 2;
              } else {
                target[position2++] = 58;
                targetView.setUint32(position2, ~value);
                position2 += 4;
              }
            } else {
              let useFloat32;
              if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
                target[position2++] = 250;
                targetView.setFloat32(position2, value);
                let xShifted;
                if (useFloat32 < 4 || (xShifted = value * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
                  position2 += 4;
                  return;
                } else
                  position2--;
              }
              target[position2++] = 251;
              targetView.setFloat64(position2, value);
              position2 += 8;
            }
          } else if (type === "object") {
            if (!value)
              target[position2++] = 246;
            else {
              if (referenceMap2) {
                let referee = referenceMap2.get(value);
                if (referee) {
                  target[position2++] = 216;
                  target[position2++] = 29;
                  target[position2++] = 25;
                  if (!referee.references) {
                    let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                    referee.references = [];
                    idsToInsert.push(referee);
                  }
                  referee.references.push(position2 - start);
                  position2 += 2;
                  return;
                } else
                  referenceMap2.set(value, { offset: position2 - start });
              }
              let constructor = value.constructor;
              if (constructor === Object) {
                writeObject(value, true);
              } else if (constructor === Array) {
                length22 = value.length;
                if (length22 < 24) {
                  target[position2++] = 128 | length22;
                } else {
                  writeArrayHeader(length22);
                }
                for (let i = 0; i < length22; i++) {
                  encode92(value[i]);
                }
              } else if (constructor === Map) {
                if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
                  target[position2++] = 217;
                  target[position2++] = 1;
                  target[position2++] = 3;
                }
                length22 = value.size;
                if (length22 < 24) {
                  target[position2++] = 160 | length22;
                } else if (length22 < 256) {
                  target[position2++] = 184;
                  target[position2++] = length22;
                } else if (length22 < 65536) {
                  target[position2++] = 185;
                  target[position2++] = length22 >> 8;
                  target[position2++] = length22 & 255;
                } else {
                  target[position2++] = 186;
                  targetView.setUint32(position2, length22);
                  position2 += 4;
                }
                if (encoder.keyMap) {
                  for (let [key, entryValue] of value) {
                    encode92(encoder.encodeKey(key));
                    encode92(entryValue);
                  }
                } else {
                  for (let [key, entryValue] of value) {
                    encode92(key);
                    encode92(entryValue);
                  }
                }
              } else {
                for (let i = 0, l = extensions.length; i < l; i++) {
                  let extensionClass = extensionClasses[i];
                  if (value instanceof extensionClass) {
                    let extension = extensions[i];
                    let tag = extension.tag;
                    if (tag == void 0)
                      tag = extension.getTag && extension.getTag.call(this, value);
                    if (tag < 24) {
                      target[position2++] = 192 | tag;
                    } else if (tag < 256) {
                      target[position2++] = 216;
                      target[position2++] = tag;
                    } else if (tag < 65536) {
                      target[position2++] = 217;
                      target[position2++] = tag >> 8;
                      target[position2++] = tag & 255;
                    } else if (tag > -1) {
                      target[position2++] = 218;
                      targetView.setUint32(position2, tag);
                      position2 += 4;
                    }
                    extension.encode.call(this, value, encode92, makeRoom);
                    return;
                  }
                }
                if (value[Symbol.iterator]) {
                  if (throwOnIterable) {
                    let error = new Error("Iterable should be serialized as iterator");
                    error.iteratorNotHandled = true;
                    throw error;
                  }
                  target[position2++] = 159;
                  for (let entry of value) {
                    encode92(entry);
                  }
                  target[position2++] = 255;
                  return;
                }
                if (value[Symbol.asyncIterator] || isBlob2(value)) {
                  let error = new Error("Iterable/blob should be serialized as iterator");
                  error.iteratorNotHandled = true;
                  throw error;
                }
                writeObject(value, !value.hasOwnProperty);
              }
            }
          } else if (type === "boolean") {
            target[position2++] = value ? 245 : 244;
          } else if (type === "bigint") {
            if (value < BigInt(1) << BigInt(64) && value >= 0) {
              target[position2++] = 27;
              targetView.setBigUint64(position2, value);
            } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
              target[position2++] = 59;
              targetView.setBigUint64(position2, -value - BigInt(1));
            } else {
              if (this.largeBigIntToFloat) {
                target[position2++] = 251;
                targetView.setFloat64(position2, Number(value));
              } else {
                throw new RangeError(value + " was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");
              }
            }
            position2 += 8;
          } else if (type === "undefined") {
            target[position2++] = 247;
          } else {
            throw new Error("Unknown type: " + type);
          }
        };
        const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
          let keys = Object.keys(object);
          let vals = Object.values(object);
          let length22 = keys.length;
          if (length22 < 24) {
            target[position2++] = 160 | length22;
          } else if (length22 < 256) {
            target[position2++] = 184;
            target[position2++] = length22;
          } else if (length22 < 65536) {
            target[position2++] = 185;
            target[position2++] = length22 >> 8;
            target[position2++] = length22 & 255;
          } else {
            target[position2++] = 186;
            targetView.setUint32(position2, length22);
            position2 += 4;
          }
          let key;
          if (encoder.keyMap) {
            for (let i = 0; i < length22; i++) {
              encode92(encodeKey(keys[i]));
              encode92(vals[i]);
            }
          } else {
            for (let i = 0; i < length22; i++) {
              encode92(keys[i]);
              encode92(vals[i]);
            }
          }
        } : (object, safePrototype) => {
          target[position2++] = 185;
          let objectOffset = position2 - start;
          position2 += 2;
          let size = 0;
          if (encoder.keyMap) {
            for (let key in object)
              if (safePrototype || object.hasOwnProperty(key)) {
                encode92(encoder.encodeKey(key));
                encode92(object[key]);
                size++;
              }
          } else {
            for (let key in object)
              if (safePrototype || object.hasOwnProperty(key)) {
                encode92(key);
                encode92(object[key]);
                size++;
              }
          }
          target[objectOffset++ + start] = size >> 8;
          target[objectOffset + start] = size & 255;
        } : (object, safePrototype) => {
          let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
          let newTransitions = 0;
          let length22 = 0;
          let parentRecordId;
          let keys;
          if (this.keyMap) {
            keys = Object.keys(object).map((k) => this.encodeKey(k));
            length22 = keys.length;
            for (let i = 0; i < length22; i++) {
              let key = keys[i];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                newTransitions++;
              }
              transition = nextTransition;
            }
          } else {
            for (let key in object)
              if (safePrototype || object.hasOwnProperty(key)) {
                nextTransition = transition[key];
                if (!nextTransition) {
                  if (transition[RECORD_SYMBOL] & 1048576) {
                    parentRecordId = transition[RECORD_SYMBOL] & 65535;
                  }
                  nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
                length22++;
              }
          }
          let recordId = transition[RECORD_SYMBOL];
          if (recordId !== void 0) {
            recordId &= 65535;
            target[position2++] = 217;
            target[position2++] = recordId >> 8 | 224;
            target[position2++] = recordId & 255;
          } else {
            if (!keys)
              keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
            if (parentRecordId === void 0) {
              recordId = structures.nextId++;
              if (!recordId) {
                recordId = 0;
                structures.nextId = 1;
              }
              if (recordId >= MAX_STRUCTURES) {
                structures.nextId = (recordId = maxSharedStructures) + 1;
              }
            } else {
              recordId = parentRecordId;
            }
            structures[recordId] = keys;
            if (recordId < maxSharedStructures) {
              target[position2++] = 217;
              target[position2++] = recordId >> 8 | 224;
              target[position2++] = recordId & 255;
              transition = structures.transitions;
              for (let i = 0; i < length22; i++) {
                if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
                  transition[RECORD_SYMBOL] = recordId;
                transition = transition[keys[i]];
              }
              transition[RECORD_SYMBOL] = recordId | 1048576;
              hasSharedUpdate = true;
            } else {
              transition[RECORD_SYMBOL] = recordId;
              targetView.setUint32(position2, 3655335680);
              position2 += 3;
              if (newTransitions)
                transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
              if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
                recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
              recordIdsToRemove.push(transition);
              writeArrayHeader(length22 + 2);
              encode92(57344 + recordId);
              encode92(keys);
              if (safePrototype === null)
                return;
              for (let key in object)
                if (safePrototype || object.hasOwnProperty(key))
                  encode92(object[key]);
              return;
            }
          }
          if (length22 < 24) {
            target[position2++] = 128 | length22;
          } else {
            writeArrayHeader(length22);
          }
          if (safePrototype === null)
            return;
          for (let key in object)
            if (safePrototype || object.hasOwnProperty(key))
              encode92(object[key]);
        };
        const makeRoom = (end) => {
          let newSize;
          if (end > 16777216) {
            if (end - start > MAX_BUFFER_SIZE)
              throw new Error("Encoded buffer would be larger than maximum buffer size");
            newSize = Math.min(
              MAX_BUFFER_SIZE,
              Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
            );
          } else
            newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
          let newBuffer = new ByteArrayAllocate(newSize);
          targetView = new DataView(newBuffer.buffer, 0, newSize);
          if (target.copy)
            target.copy(newBuffer, 0, start, end);
          else
            newBuffer.set(target.slice(start, end));
          position2 -= start;
          start = 0;
          safeEnd = newBuffer.length - 10;
          return target = newBuffer;
        };
        let chunkThreshold = 100;
        let continuedChunkThreshold = 1e3;
        this.encodeAsIterable = function(value, options2) {
          return startEncoding(value, options2, encodeObjectAsIterable);
        };
        this.encodeAsAsyncIterable = function(value, options2) {
          return startEncoding(value, options2, encodeObjectAsAsyncIterable);
        };
        function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
          let constructor = object.constructor;
          if (constructor === Object) {
            let useRecords = encoder.useRecords !== false;
            if (useRecords)
              writeObject(object, null);
            else
              writeEntityLength(Object.keys(object).length, 160);
            for (let key in object) {
              let value = object[key];
              if (!useRecords)
                encode92(key);
              if (value && typeof value === "object") {
                if (iterateProperties[key])
                  yield* encodeObjectAsIterable(value, iterateProperties[key]);
                else
                  yield* tryEncode(value, iterateProperties, key);
              } else
                encode92(value);
            }
          } else if (constructor === Array) {
            let length22 = object.length;
            writeArrayHeader(length22);
            for (let i = 0; i < length22; i++) {
              let value = object[i];
              if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
                if (iterateProperties.element)
                  yield* encodeObjectAsIterable(value, iterateProperties.element);
                else
                  yield* tryEncode(value, iterateProperties, "element");
              } else
                encode92(value);
            }
          } else if (object[Symbol.iterator]) {
            target[position2++] = 159;
            for (let value of object) {
              if (value && (typeof value === "object" || position2 - start > chunkThreshold)) {
                if (iterateProperties.element)
                  yield* encodeObjectAsIterable(value, iterateProperties.element);
                else
                  yield* tryEncode(value, iterateProperties, "element");
              } else
                encode92(value);
            }
            target[position2++] = 255;
          } else if (isBlob2(object)) {
            writeEntityLength(object.size, 64);
            yield target.subarray(start, position2);
            yield object;
            restartEncoding();
          } else if (object[Symbol.asyncIterator]) {
            target[position2++] = 159;
            yield target.subarray(start, position2);
            yield object;
            restartEncoding();
            target[position2++] = 255;
          } else {
            encode92(object);
          }
          if (finalIterable && position2 > start)
            yield target.subarray(start, position2);
          else if (position2 - start > chunkThreshold) {
            yield target.subarray(start, position2);
            restartEncoding();
          }
        }
        function* tryEncode(value, iterateProperties, key) {
          let restart = position2 - start;
          try {
            encode92(value);
            if (position2 - start > chunkThreshold) {
              yield target.subarray(start, position2);
              restartEncoding();
            }
          } catch (error) {
            if (error.iteratorNotHandled) {
              iterateProperties[key] = {};
              position2 = start + restart;
              yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
            } else
              throw error;
          }
        }
        function restartEncoding() {
          chunkThreshold = continuedChunkThreshold;
          encoder.encode(null, THROW_ON_ITERABLE);
        }
        function startEncoding(value, options2, encodeIterable) {
          if (options2 && options2.chunkThreshold)
            chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
          else
            chunkThreshold = 100;
          if (value && typeof value === "object") {
            encoder.encode(null, THROW_ON_ITERABLE);
            return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
          }
          return [encoder.encode(value)];
        }
        async function* encodeObjectAsAsyncIterable(value, iterateProperties) {
          for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
            let constructor = encodedValue.constructor;
            if (constructor === ByteArray || constructor === Uint8Array)
              yield encodedValue;
            else if (isBlob2(encodedValue)) {
              let reader = encodedValue.stream().getReader();
              let next;
              while (!(next = await reader.read()).done) {
                yield next.value;
              }
            } else if (encodedValue[Symbol.asyncIterator]) {
              for await (let asyncValue of encodedValue) {
                restartEncoding();
                if (asyncValue)
                  yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));
                else
                  yield encoder.encode(asyncValue);
              }
            } else {
              yield encodedValue;
            }
          }
        }
      }
      useBuffer(buffer22) {
        target = buffer22;
        targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
        position2 = 0;
      }
      clearSharedData() {
        if (this.structures)
          this.structures = [];
        if (this.sharedValues)
          this.sharedValues = void 0;
      }
      updateSharedData() {
        let lastVersion = this.sharedVersion || 0;
        this.sharedVersion = lastVersion + 1;
        let structuresCopy = this.structures.slice(0);
        let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
        let saveResults = this.saveShared(
          sharedData,
          (existingShared) => (existingShared && existingShared.version || 0) == lastVersion
        );
        if (saveResults === false) {
          sharedData = this.getShared() || {};
          this.structures = sharedData.structures || [];
          this.sharedValues = sharedData.packedValues;
          this.sharedVersion = sharedData.version;
          this.structures.nextId = this.structures.length;
        } else {
          structuresCopy.forEach((structure, i) => this.structures[i] = structure);
        }
        return saveResults;
      }
    };
    function writeEntityLength(length22, majorValue) {
      if (length22 < 24)
        target[position2++] = majorValue | length22;
      else if (length22 < 256) {
        target[position2++] = majorValue | 24;
        target[position2++] = length22;
      } else if (length22 < 65536) {
        target[position2++] = majorValue | 25;
        target[position2++] = length22 >> 8;
        target[position2++] = length22 & 255;
      } else {
        target[position2++] = majorValue | 26;
        targetView.setUint32(position2, length22);
        position2 += 4;
      }
    }
    var SharedData = class {
      constructor(structures, values, version22) {
        this.structures = structures;
        this.packedValues = values;
        this.version = version22;
      }
    };
    function writeArrayHeader(length22) {
      if (length22 < 24)
        target[position2++] = 128 | length22;
      else if (length22 < 256) {
        target[position2++] = 152;
        target[position2++] = length22;
      } else if (length22 < 65536) {
        target[position2++] = 153;
        target[position2++] = length22 >> 8;
        target[position2++] = length22 & 255;
      } else {
        target[position2++] = 154;
        targetView.setUint32(position2, length22);
        position2 += 4;
      }
    }
    var BlobConstructor = typeof Blob === "undefined" ? function() {
    } : Blob;
    function isBlob2(object) {
      if (object instanceof BlobConstructor)
        return true;
      let tag = object[Symbol.toStringTag];
      return tag === "Blob" || tag === "File";
    }
    function findRepetitiveStrings(value, packedValues2) {
      switch (typeof value) {
        case "string":
          if (value.length > 3) {
            if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
              return;
            let packedStatus = packedValues2.get(value);
            if (packedStatus) {
              if (++packedStatus.count == 2) {
                packedValues2.values.push(value);
              }
            } else {
              packedValues2.set(value, {
                count: 1
              });
              if (packedValues2.samplingPackedValues) {
                let status = packedValues2.samplingPackedValues.get(value);
                if (status)
                  status.count++;
                else
                  packedValues2.samplingPackedValues.set(value, {
                    count: 1
                  });
              }
            }
          }
          break;
        case "object":
          if (value) {
            if (value instanceof Array) {
              for (let i = 0, l = value.length; i < l; i++) {
                findRepetitiveStrings(value[i], packedValues2);
              }
            } else {
              let includeKeys = !packedValues2.encoder.useRecords;
              for (var key in value) {
                if (value.hasOwnProperty(key)) {
                  if (includeKeys)
                    findRepetitiveStrings(key, packedValues2);
                  findRepetitiveStrings(value[key], packedValues2);
                }
              }
            }
          }
          break;
        case "function":
          console.log(value);
      }
    }
    var isLittleEndianMachine2 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
    extensionClasses = [
      Date,
      Set,
      Error,
      RegExp,
      Tag,
      ArrayBuffer,
      Uint8Array,
      Uint8ClampedArray,
      Uint16Array,
      Uint32Array,
      typeof BigUint64Array == "undefined" ? function() {
      } : BigUint64Array,
      Int8Array,
      Int16Array,
      Int32Array,
      typeof BigInt64Array == "undefined" ? function() {
      } : BigInt64Array,
      Float32Array,
      Float64Array,
      SharedData
    ];
    extensions = [
      {
        tag: 1,
        encode(date, encode92) {
          let seconds = date.getTime() / 1e3;
          if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
            target[position2++] = 26;
            targetView.setUint32(position2, seconds);
            position2 += 4;
          } else {
            target[position2++] = 251;
            targetView.setFloat64(position2, seconds);
            position2 += 8;
          }
        }
      },
      {
        tag: 258,
        encode(set, encode92) {
          let array = Array.from(set);
          encode92(array);
        }
      },
      {
        tag: 27,
        encode(error, encode92) {
          encode92([error.name, error.message]);
        }
      },
      {
        tag: 27,
        encode(regex, encode92) {
          encode92(["RegExp", regex.source, regex.flags]);
        }
      },
      {
        getTag(tag) {
          return tag.tag;
        },
        encode(tag, encode92) {
          encode92(tag.value);
        }
      },
      {
        encode(arrayBuffer, encode92, makeRoom) {
          writeBuffer(arrayBuffer, makeRoom);
        }
      },
      {
        getTag(typedArray) {
          if (typedArray.constructor === Uint8Array) {
            if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
              return 64;
          }
        },
        encode(typedArray, encode92, makeRoom) {
          writeBuffer(typedArray, makeRoom);
        }
      },
      typedArrayEncoder(68, 1),
      typedArrayEncoder(69, 2),
      typedArrayEncoder(70, 4),
      typedArrayEncoder(71, 8),
      typedArrayEncoder(72, 1),
      typedArrayEncoder(77, 2),
      typedArrayEncoder(78, 4),
      typedArrayEncoder(79, 8),
      typedArrayEncoder(85, 4),
      typedArrayEncoder(86, 8),
      {
        encode(sharedData, encode92) {
          let packedValues2 = sharedData.packedValues || [];
          let sharedStructures = sharedData.structures || [];
          if (packedValues2.values.length > 0) {
            target[position2++] = 216;
            target[position2++] = 51;
            writeArrayHeader(4);
            let valuesArray = packedValues2.values;
            encode92(valuesArray);
            writeArrayHeader(0);
            writeArrayHeader(0);
            packedObjectMap = Object.create(sharedPackedObjectMap || null);
            for (let i = 0, l = valuesArray.length; i < l; i++) {
              packedObjectMap[valuesArray[i]] = i;
            }
          }
          if (sharedStructures) {
            targetView.setUint32(position2, 3655335424);
            position2 += 3;
            let definitions = sharedStructures.slice(0);
            definitions.unshift(57344);
            definitions.push(new Tag(sharedData.version, 1399353956));
            encode92(definitions);
          } else
            encode92(new Tag(sharedData.version, 1399353956));
        }
      }
    ];
    function typedArrayEncoder(tag, size) {
      if (!isLittleEndianMachine2 && size > 1)
        tag -= 4;
      return {
        tag,
        encode: function writeExtBuffer(typedArray, encode92) {
          let length22 = typedArray.byteLength;
          let offset = typedArray.byteOffset || 0;
          let buffer22 = typedArray.buffer || typedArray;
          encode92(hasNodeBuffer ? Buffer2.from(buffer22, offset, length22) : new Uint8Array(buffer22, offset, length22));
        }
      };
    }
    function writeBuffer(buffer22, makeRoom) {
      let length22 = buffer22.byteLength;
      if (length22 < 24) {
        target[position2++] = 64 + length22;
      } else if (length22 < 256) {
        target[position2++] = 88;
        target[position2++] = length22;
      } else if (length22 < 65536) {
        target[position2++] = 89;
        target[position2++] = length22 >> 8;
        target[position2++] = length22 & 255;
      } else {
        target[position2++] = 90;
        targetView.setUint32(position2, length22);
        position2 += 4;
      }
      if (position2 + length22 >= target.length) {
        makeRoom(position2 + length22);
      }
      target.set(buffer22.buffer ? buffer22 : new Uint8Array(buffer22), position2);
      position2 += length22;
    }
    function insertIds(serialized, idsToInsert) {
      let nextId;
      let distanceToMove = idsToInsert.length * 2;
      let lastEnd = serialized.length - distanceToMove;
      idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
      for (let id = 0; id < idsToInsert.length; id++) {
        let referee = idsToInsert[id];
        referee.id = id;
        for (let position3 of referee.references) {
          serialized[position3++] = id >> 8;
          serialized[position3] = id & 255;
        }
      }
      while (nextId = idsToInsert.pop()) {
        let offset = nextId.offset;
        serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
        distanceToMove -= 2;
        let position3 = offset + distanceToMove;
        serialized[position3++] = 216;
        serialized[position3++] = 28;
        lastEnd = offset;
      }
      return serialized;
    }
    function writeBundles(start, encode92) {
      targetView.setUint32(bundledStrings2.position + start, position2 - bundledStrings2.position - start + 1);
      let writeStrings = bundledStrings2;
      bundledStrings2 = null;
      encode92(writeStrings[0]);
      encode92(writeStrings[1]);
    }
    function addExtension2(extension) {
      if (extension.Class) {
        if (!extension.encode)
          throw new Error("Extension has no encode function");
        extensionClasses.unshift(extension.Class);
        extensions.unshift(extension);
      }
      addExtension(extension);
    }
    var defaultEncoder = new Encoder22({ useRecords: false });
    var encode82 = defaultEncoder.encode;
    var encodeAsIterable = defaultEncoder.encodeAsIterable;
    var encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable;
    var { NEVER: NEVER2, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
    var REUSE_BUFFER_MODE = 512;
    var RESET_BUFFER_MODE = 1024;
    var THROW_ON_ITERABLE = 2048;
    var import_module = require("module");
    var import_meta = {};
    var nativeAccelerationDisabled = process.env.CBOR_NATIVE_ACCELERATION_DISABLED !== void 0 && process.env.CBOR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === "true";
    if (!nativeAccelerationDisabled) {
      let extractor;
      try {
        if (typeof require == "function")
          extractor = require_cbor_extract();
        else
          extractor = (0, import_module.createRequire)(import_meta.url)("cbor-extract");
        if (extractor)
          setExtractor(extractor.extractStrings);
      } catch (error) {
      }
    }
    addExtension2({
      Class: CID2,
      tag: 42,
      encode: () => {
        throw new Error("cannot encode cids");
      },
      decode: (bytes) => {
        if (bytes[0] !== 0) {
          throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
        }
        return CID2.decode(bytes.subarray(1));
      }
    });
    var cborDecodeMulti = (encoded) => {
      const decoded = [];
      decodeMultiple(encoded, (value) => {
        decoded.push(value);
      });
      return decoded;
    };
    var import_pino = __toESM2(require_pino());
    var allSystemsEnabled = !process.env.LOG_SYSTEMS;
    var enabledSystems = (process.env.LOG_SYSTEMS || "").replace(",", " ").split(" ");
    var enabledEnv = process.env.LOG_ENABLED;
    var enabled = enabledEnv === "true" || enabledEnv === "t" || enabledEnv === "1";
    var level = process.env.LOG_LEVEL || "info";
    var config = {
      enabled,
      level
    };
    var rootLogger = process.env.LOG_DESTINATION ? (0, import_pino.default)(config, import_pino.default.destination(process.env.LOG_DESTINATION)) : (0, import_pino.default)(config);
    var subsystems = {};
    var subsystemLogger = (name3) => {
      if (subsystems[name3])
        return subsystems[name3];
      const subsystemEnabled = enabled && (allSystemsEnabled || enabledSystems.indexOf(name3) > -1);
      subsystems[name3] = rootLogger.child(
        { name: name3 },
        { level: subsystemEnabled ? level : "silent" }
      );
      return subsystems[name3];
    };
    var import_stream32 = require("stream");
    var forwardStreamErrors = (...streams) => {
      for (let i = 0; i < streams.length; ++i) {
        const stream4 = streams[i];
        const next = streams[i + 1];
        if (next) {
          stream4.once("error", (err) => next.emit("error", err));
        }
      }
    };
    var cloneStream = (stream4) => {
      const passthrough = new import_stream32.PassThrough();
      forwardStreamErrors(stream4, passthrough);
      return stream4.pipe(passthrough);
    };
    var streamSize = async (stream4) => {
      let size = 0;
      for await (const chunk of stream4) {
        size += chunk.length;
      }
      return size;
    };
    var streamToBytes = async (stream4) => {
      const bufs = [];
      for await (const bytes of stream4) {
        bufs.push(bytes);
      }
      return new Uint8Array(Buffer.concat(bufs));
    };
    var byteIterableToStream = (iter) => {
      return import_stream32.Readable.from(iter, { objectMode: false });
    };
    var bytesToStream = (bytes) => {
      const stream4 = new import_stream32.Readable();
      stream4.push(bytes);
      stream4.push(null);
      return stream4;
    };
    var MaxSizeChecker = class extends import_stream32.Transform {
      constructor(maxSize, createError) {
        super();
        this.maxSize = maxSize;
        this.createError = createError;
        this.totalSize = 0;
      }
      _transform(chunk, _enc, cb) {
        this.totalSize += chunk.length;
        if (this.totalSize > this.maxSize) {
          return this.destroy(this.createError());
        }
        return cb(null, chunk);
      }
    };
  }
});

// ../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util3 = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util3.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// ../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util3 = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util3.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream4) {
      return typeof stream4 !== "function" && typeof stream4 !== "string" && typeof stream4 !== "boolean" && typeof stream4 !== "number" && !Buffer.isBuffer(stream4);
    };
    CombinedStream.prototype.append = function(stream4) {
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        if (!(stream4 instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream4, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream4.on("data", this._checkDataSize.bind(this));
          stream4 = newStream;
        }
        this._handleErrors(stream4);
        if (this.pauseStreams) {
          stream4.pause();
        }
      }
      this._streams.push(stream4);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream4 = this._streams.shift();
      if (typeof stream4 == "undefined") {
        this.end();
        return;
      }
      if (typeof stream4 !== "function") {
        this._pipeNext(stream4);
        return;
      }
      var getStream = stream4;
      getStream(function(stream5) {
        var isStreamLike = CombinedStream.isStreamLike(stream5);
        if (isStreamLike) {
          stream5.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream5);
        }
        this._pipeNext(stream5);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream4) {
      this._currentStream = stream4;
      var isStreamLike = CombinedStream.isStreamLike(stream4);
      if (isStreamLike) {
        stream4.on("end", this._getNext.bind(this));
        stream4.pipe(this, { end: false });
        return;
      }
      var value = stream4;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream4) {
      var self2 = this;
      stream4.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream4) {
        if (!stream4.dataSize) {
          return;
        }
        self2.dataSize += stream4.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = __commonJS({
  "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from3 = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from3 > to || from3 === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync2 = false;
      defer(function() {
        isAsync2 = true;
      });
      return function async_callback(err, result) {
        if (isAsync2) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// ../../node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "../../node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src2) {
      Object.keys(src2).forEach(function(prop) {
        dst[prop] = dst[prop] || src2[prop];
      });
      return dst;
    };
  }
});

// ../../node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "../../node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util3 = require("util");
    var path = require("path");
    var http2 = require("http");
    var https2 = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData3;
    util3.inherits(FormData3, CombinedStream);
    function FormData3(options) {
      if (!(this instanceof FormData3)) {
        return new FormData3(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData3.LINE_BREAK = "\r\n";
    FormData3.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData3.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append2 = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util3.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append2(header);
      append2(value);
      append2(footer);
      this._trackLength(header, value, options);
    };
    FormData3.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData3.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData3.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData3.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData3.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData3.LINE_BREAK + contents + FormData3.LINE_BREAK;
    };
    FormData3.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData3.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData3.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData3.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData3.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData3.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData3.LINE_BREAK;
    };
    FormData3.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData3.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData3.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData3.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData3.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData3.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData3.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData3.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData3.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length2) {
          knownLength += length2;
        });
        cb(null, knownLength);
      });
    };
    FormData3.prototype.submit = function(params, cb) {
      var request, options, defaults2 = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https2.request(options);
      } else {
        request = http2.request(options);
      }
      this.getLength(function(err, length2) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length2) {
          request.setHeader("Content-Length", length2);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData3.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData3.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// ../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "../../node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl2(url2) {
      var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl2;
  }
});

// ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream4) {
      const level = supportsColor(stream4, stream4 && stream4.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util3 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util3.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/.pnpm/follow-redirects@1.15.6/node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/.pnpm/follow-redirects@1.15.6/node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../node_modules/.pnpm/follow-redirects@1.15.6/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/.pnpm/follow-redirects@1.15.6/node_modules/follow-redirects/index.js"(exports2, module2) {
    var url2 = require("url");
    var URL2 = url2.URL;
    var http2 = require("http");
    var https2 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var useNativeURL = false;
    try {
      assert(new URL2());
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop2;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer4(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction2(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value) {
      this._options.headers[name2] = value;
      this._currentRequest.setHeader(name2, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url2.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer2 = buffers[i++];
              if (!request.finished) {
                request.write(buffer2.data, buffer2.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url2.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction2(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString2(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction2(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop2() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url2.parse(input));
        if (!isString2(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base3) {
      return useNativeURL ? new URL2(relative, base3) : parseUrl(url2.resolve(base3, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread3 = target || {};
      for (var key of preservedUrlFields) {
        spread3[key] = urlObject[key];
      }
      if (spread3.hostname.startsWith("[")) {
        spread3.hostname = spread3.hostname.slice(1, -1);
      }
      if (spread3.port !== "") {
        spread3.port = Number(spread3.port);
      }
      spread3.path = spread3.search ? spread3.pathname + spread3.search : spread3.pathname;
      return spread3;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code2, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code2;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code2 + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop2);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction2(value) {
      return typeof value === "function";
    }
    function isBuffer4(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// ../../node_modules/.pnpm/@atproto+crypto@0.3.0/node_modules/@atproto/crypto/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/.pnpm/@atproto+crypto@0.3.0/node_modules/@atproto/crypto/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all3) => {
      for (var name22 in all3)
        __defProp2(target, name22, { get: all3[name22], enumerable: true });
    };
    var __copyProps2 = (to, from32, except, desc) => {
      if (from32 && typeof from32 === "object" || typeof from32 === "function") {
        for (let key of __getOwnPropNames2(from32))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from32[key], enumerable: !(desc = __getOwnPropDesc2(from32, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target, mod2));
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var src_exports22 = {};
    __export2(src_exports22, {
      BASE58_MULTIBASE_PREFIX: () => BASE58_MULTIBASE_PREFIX,
      DID_KEY_PREFIX: () => DID_KEY_PREFIX,
      P256Keypair: () => P256Keypair,
      P256_DID_PREFIX: () => P256_DID_PREFIX,
      P256_JWT_ALG: () => P256_JWT_ALG2,
      SECP256K1_DID_PREFIX: () => SECP256K1_DID_PREFIX,
      SECP256K1_JWT_ALG: () => SECP256K1_JWT_ALG2,
      Secp256k1Keypair: () => Secp256k1Keypair,
      bytesToMultibase: () => bytesToMultibase,
      formatDidKey: () => formatDidKey,
      formatMultikey: () => formatMultikey,
      multibaseToBytes: () => multibaseToBytes,
      p256Plugin: () => p256Plugin,
      parseDidKey: () => parseDidKey2,
      parseMultikey: () => parseMultikey,
      randomBytes: () => randomBytes2,
      randomIntFromSeed: () => randomIntFromSeed,
      randomStr: () => randomStr,
      secp256k1Plugin: () => secp256k1Plugin,
      sha256: () => sha25632,
      verifySignature: () => verifySignature2,
      verifySignatureUtf8: () => verifySignatureUtf8
    });
    module2.exports = __toCommonJS2(src_exports22);
    var P256_DID_PREFIX = new Uint8Array([128, 36]);
    var SECP256K1_DID_PREFIX = new Uint8Array([231, 1]);
    var BASE58_MULTIBASE_PREFIX = "z";
    var DID_KEY_PREFIX = "did:key:";
    var P256_JWT_ALG2 = "ES256";
    var SECP256K1_JWT_ALG2 = "ES256K";
    function concat3(arrays, length22) {
      if (!length22) {
        length22 = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output2 = new Uint8Array(length22);
      let offset = 0;
      for (const arr of arrays) {
        output2.set(arr, offset);
        offset += arr.length;
      }
      return output2;
    }
    function equals4(a, b) {
      if (a === b) {
        return true;
      }
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    var identity_exports3 = {};
    __export2(identity_exports3, {
      identity: () => identity3
    });
    function base3(ALPHABET2, name22) {
      if (ALPHABET2.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET2.length; i++) {
        var x = ALPHABET2.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET2.length;
      var LEADER = ALPHABET2.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode52(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length22 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length22) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length22 = i2;
          pbegin++;
        }
        var it2 = size - length22;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET2.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length22 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length22) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length22 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length22;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode62(string22) {
        var buffer2 = decodeUnsafe(string22);
        if (buffer2) {
          return buffer2;
        }
        throw new Error(`Non-${name22} character`);
      }
      return {
        encode: encode52,
        decodeUnsafe,
        decode: decode62
      };
    }
    var src2 = base3;
    var _brrp__multiformats_scope_baseX2 = src2;
    var base_x_default2 = _brrp__multiformats_scope_baseX2;
    var empty2 = new Uint8Array(0);
    var equals22 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce2 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var fromString4 = (str) => new TextEncoder().encode(str);
    var toString6 = (b) => new TextDecoder().decode(b);
    var Encoder2 = class {
      constructor(name22, prefix, baseEncode) {
        this.name = name22;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder2 = class {
      constructor(name22, prefix, baseDecode) {
        this.name = name22;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or2(this, decoder);
      }
    };
    var ComposedDecoder2 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or2(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or2 = (left, right) => new ComposedDecoder2({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    var Codec2 = class {
      constructor(name22, prefix, baseEncode, baseDecode) {
        this.name = name22;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder2(name22, prefix, baseEncode);
        this.decoder = new Decoder2(name22, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from3 = ({ name: name22, prefix, encode: encode52, decode: decode62 }) => new Codec2(name22, prefix, encode52, decode62);
    var baseX2 = ({ prefix, name: name22, alphabet: alphabet22 }) => {
      const { encode: encode52, decode: decode62 } = base_x_default2(alphabet22, name22);
      return from3({
        prefix,
        name: name22,
        encode: encode52,
        decode: (text) => coerce2(decode62(text))
      });
    };
    var decode7 = (string22, alphabet22, bitsPerChar, name22) => {
      const codes = {};
      for (let i = 0; i < alphabet22.length; ++i) {
        codes[alphabet22[i]] = i;
      }
      let end = string22.length;
      while (string22[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string22[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name22} character`);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode9 = (data, alphabet22, bitsPerChar) => {
      const pad = alphabet22[alphabet22.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer2 = buffer2 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet22[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet22[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46482 = ({ name: name22, prefix, bitsPerChar, alphabet: alphabet22 }) => {
      return from3({
        prefix,
        name: name22,
        encode(input) {
          return encode9(input, alphabet22, bitsPerChar);
        },
        decode(input) {
          return decode7(input, alphabet22, bitsPerChar, name22);
        }
      });
    };
    var identity3 = from3({
      prefix: "\0",
      name: "identity",
      encode: (buf2) => toString6(buf2),
      decode: (str) => fromString4(str)
    });
    var base2_exports2 = {};
    __export2(base2_exports2, {
      base2: () => base22
    });
    var base22 = rfc46482({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    var base8_exports2 = {};
    __export2(base8_exports2, {
      base8: () => base82
    });
    var base82 = rfc46482({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    var base10_exports2 = {};
    __export2(base10_exports2, {
      base10: () => base102
    });
    var base102 = baseX2({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    var base16_exports2 = {};
    __export2(base16_exports2, {
      base16: () => base162,
      base16upper: () => base16upper2
    });
    var base162 = rfc46482({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper2 = rfc46482({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    var base32_exports2 = {};
    __export2(base32_exports2, {
      base32: () => base322,
      base32hex: () => base32hex2,
      base32hexpad: () => base32hexpad2,
      base32hexpadupper: () => base32hexpadupper2,
      base32hexupper: () => base32hexupper2,
      base32pad: () => base32pad2,
      base32padupper: () => base32padupper2,
      base32upper: () => base32upper2,
      base32z: () => base32z2
    });
    var base322 = rfc46482({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper2 = rfc46482({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad2 = rfc46482({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper2 = rfc46482({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex2 = rfc46482({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper2 = rfc46482({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad2 = rfc46482({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper2 = rfc46482({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z2 = rfc46482({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    var base36_exports2 = {};
    __export2(base36_exports2, {
      base36: () => base362,
      base36upper: () => base36upper2
    });
    var base362 = baseX2({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper2 = baseX2({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    var base58_exports2 = {};
    __export2(base58_exports2, {
      base58btc: () => base58btc2,
      base58flickr: () => base58flickr2
    });
    var base58btc2 = baseX2({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr2 = baseX2({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    var base64_exports2 = {};
    __export2(base64_exports2, {
      base64: () => base642,
      base64pad: () => base64pad2,
      base64url: () => base64url2,
      base64urlpad: () => base64urlpad2
    });
    var base642 = rfc46482({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad2 = rfc46482({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url2 = rfc46482({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad2 = rfc46482({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    var base256emoji_exports2 = {};
    __export2(base256emoji_exports2, {
      base256emoji: () => base256emoji2
    });
    var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars2 = alphabet2.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    var alphabetCharsToBytes2 = alphabet2.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode22(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars2[c];
        return p;
      }, "");
    }
    function decode22(str) {
      const byts = [];
      for (const char of str) {
        const byt = alphabetCharsToBytes2[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji2 = from3({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode22,
      decode: decode22
    });
    var sha2_exports2 = {};
    __export2(sha2_exports2, {
      sha256: () => sha2563,
      sha512: () => sha5122
    });
    var import_crypto3 = __toESM2(require("crypto"), 1);
    var encode_12 = encode32;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode32(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode32.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode32 = read2;
    var MSB$12 = 128;
    var REST$12 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$12);
      read2.bytes = counter - offset;
      return res;
    }
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    var length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    var varint2 = {
      encode: encode_12,
      decode: decode32,
      encodingLength: length2
    };
    var _brrp_varint2 = varint2;
    var varint_default2 = _brrp_varint2;
    var decode42 = (data, offset = 0) => {
      const code22 = varint_default2.decode(data, offset);
      return [
        code22,
        varint_default2.decode.bytes
      ];
    };
    var encodeTo2 = (int, target, offset = 0) => {
      varint_default2.encode(int, target, offset);
      return target;
    };
    var encodingLength2 = (int) => {
      return varint_default2.encodingLength(int);
    };
    var create2 = (code22, digest22) => {
      const size = digest22.byteLength;
      const sizeOffset = encodingLength2(code22);
      const digestOffset = sizeOffset + encodingLength2(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      encodeTo2(code22, bytes2, 0);
      encodeTo2(size, bytes2, sizeOffset);
      bytes2.set(digest22, digestOffset);
      return new Digest2(code22, size, digest22, bytes2);
    };
    var decode52 = (multihash) => {
      const bytes2 = coerce2(multihash);
      const [code22, sizeOffset] = decode42(bytes2);
      const [size, digestOffset] = decode42(bytes2.subarray(sizeOffset));
      const digest22 = bytes2.subarray(sizeOffset + digestOffset);
      if (digest22.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest2(code22, size, digest22, bytes2);
    };
    var equals32 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals22(a.bytes, b.bytes);
      }
    };
    var Digest2 = class {
      constructor(code22, size, digest22, bytes2) {
        this.code = code22;
        this.size = size;
        this.digest = digest22;
        this.bytes = bytes2;
      }
    };
    var from22 = ({ name: name22, code: code22, encode: encode52 }) => new Hasher2(name22, code22, encode52);
    var Hasher2 = class {
      constructor(name22, code22, encode52) {
        this.name = name22;
        this.code = code22;
        this.encode = encode52;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? create2(this.code, result) : result.then((digest22) => create2(this.code, digest22));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var sha2563 = from22({
      name: "sha2-256",
      code: 18,
      encode: (input) => coerce2(import_crypto3.default.createHash("sha256").update(input).digest())
    });
    var sha5122 = from22({
      name: "sha2-512",
      code: 19,
      encode: (input) => coerce2(import_crypto3.default.createHash("sha512").update(input).digest())
    });
    var identity_exports22 = {};
    __export2(identity_exports22, {
      identity: () => identity22
    });
    var code2 = 0;
    var name2 = "identity";
    var encode42 = coerce2;
    var digest2 = (input) => create2(code2, encode42(input));
    var identity22 = {
      code: code2,
      name: name2,
      encode: encode42,
      digest: digest2
    };
    var textEncoder4 = new TextEncoder();
    var textDecoder3 = new TextDecoder();
    var CID2 = class {
      constructor(version22, code22, multihash, bytes2) {
        this.code = code22;
        this.version = version22;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden2,
          byteLength: hidden2,
          code: readonly2,
          version: readonly2,
          multihash: readonly2,
          bytes: readonly2,
          _baseCache: hidden2,
          asCID: hidden2
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code22, multihash } = this;
            if (code22 !== DAG_PB_CODE2) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE2) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID2.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code22, digest: digest22 } = this.multihash;
            const multihash = create2(code22, digest22);
            return CID2.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals32(this.multihash, other.multihash);
      }
      toString(base33) {
        const { bytes: bytes2, version: version22, _baseCache } = this;
        switch (version22) {
          case 0:
            return toStringV02(bytes2, _baseCache, base33 || base58btc2.encoder);
          default:
            return toStringV12(bytes2, _baseCache, base33 || base322.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate2(/^0\.0/, IS_CID_DEPRECATION2);
        return !!(value && (value[cidSymbol2] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID2) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version22, code: code22, multihash, bytes: bytes2 } = value;
          return new CID2(version22, code22, multihash, bytes2 || encodeCID2(version22, code22, multihash.bytes));
        } else if (value != null && value[cidSymbol2] === true) {
          const { version: version22, multihash, code: code22 } = value;
          const digest22 = decode52(multihash);
          return CID2.create(version22, code22, digest22);
        } else {
          return null;
        }
      }
      static create(version22, code22, digest22) {
        if (typeof code22 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version22) {
          case 0: {
            if (code22 !== DAG_PB_CODE2) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE2}) block encoding`);
            } else {
              return new CID2(version22, code22, digest22, digest22.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID2(version22, code22, digest22.bytes);
            return new CID2(version22, code22, digest22, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest22) {
        return CID2.create(0, DAG_PB_CODE2, digest22);
      }
      static createV1(code22, digest22) {
        return CID2.create(1, code22, digest22);
      }
      static decode(bytes2) {
        const [cid2, remainder] = CID2.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid2;
      }
      static decodeFirst(bytes2) {
        const specs = CID2.inspectBytes(bytes2);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce2(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest22 = new Digest2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid2 = specs.version === 0 ? CID2.createV0(digest22) : CID2.createV1(specs.codec, digest22);
        return [
          cid2,
          bytes2.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length22] = decode42(initialBytes.subarray(offset));
          offset += length22;
          return i;
        };
        let version22 = next();
        let codec = DAG_PB_CODE2;
        if (version22 === 18) {
          version22 = 0;
          offset = 0;
        } else if (version22 === 1) {
          codec = next();
        }
        if (version22 !== 0 && version22 !== 1) {
          throw new RangeError(`Invalid CID version ${version22}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version22,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base33) {
        const [prefix, bytes2] = parseCIDtoBytes2(source, base33);
        const cid2 = CID2.decode(bytes2);
        cid2._baseCache.set(prefix, source);
        return cid2;
      }
    };
    var parseCIDtoBytes2 = (source, base33) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base33 || base58btc2;
          return [
            base58btc2.prefix,
            decoder.decode(`${base58btc2.prefix}${source}`)
          ];
        }
        case base58btc2.prefix: {
          const decoder = base33 || base58btc2;
          return [
            base58btc2.prefix,
            decoder.decode(source)
          ];
        }
        case base322.prefix: {
          const decoder = base33 || base322;
          return [
            base322.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base33 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base33.decode(source)
          ];
        }
      }
    };
    var toStringV02 = (bytes2, cache, base33) => {
      const { prefix } = base33;
      if (prefix !== base58btc2.prefix) {
        throw Error(`Cannot string encode V0 in ${base33.name} encoding`);
      }
      const cid2 = cache.get(prefix);
      if (cid2 == null) {
        const cid22 = base33.encode(bytes2).slice(1);
        cache.set(prefix, cid22);
        return cid22;
      } else {
        return cid2;
      }
    };
    var toStringV12 = (bytes2, cache, base33) => {
      const { prefix } = base33;
      const cid2 = cache.get(prefix);
      if (cid2 == null) {
        const cid22 = base33.encode(bytes2);
        cache.set(prefix, cid22);
        return cid22;
      } else {
        return cid2;
      }
    };
    var DAG_PB_CODE2 = 112;
    var SHA_256_CODE2 = 18;
    var encodeCID2 = (version22, code22, multihash) => {
      const codeOffset = encodingLength2(version22);
      const hashOffset = codeOffset + encodingLength2(code22);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo2(version22, bytes2, 0);
      encodeTo2(code22, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    var cidSymbol2 = Symbol.for("@ipld/js-cid/CID");
    var readonly2 = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden2 = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version2 = "0.0.0-dev";
    var deprecate2 = (range, message) => {
      if (range.test(version2)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    var IS_CID_DEPRECATION2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    var bases2 = {
      ...identity_exports3,
      ...base2_exports2,
      ...base8_exports2,
      ...base10_exports2,
      ...base16_exports2,
      ...base32_exports2,
      ...base36_exports2,
      ...base58_exports2,
      ...base64_exports2,
      ...base256emoji_exports2
    };
    var hashes2 = {
      ...sha2_exports2,
      ...identity_exports22
    };
    function createCodec2(name22, prefix, encode52, decode62) {
      return {
        name: name22,
        prefix,
        encoder: {
          name: name22,
          prefix,
          encode: encode52
        },
        decoder: { decode: decode62 }
      };
    }
    var string2 = createCodec2("utf8", "u", (buf2) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf2);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    var ascii2 = createCodec2("ascii", "a", (buf2) => {
      let string22 = "a";
      for (let i = 0; i < buf2.length; i++) {
        string22 += String.fromCharCode(buf2[i]);
      }
      return string22;
    }, (str) => {
      str = str.substring(1);
      const buf2 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf2[i] = str.charCodeAt(i);
      }
      return buf2;
    });
    var BASES2 = {
      utf8: string2,
      "utf-8": string2,
      hex: bases2.base16,
      latin1: ascii2,
      ascii: ascii2,
      binary: ascii2,
      ...bases2
    };
    var bases_default2 = BASES2;
    function fromString22(string22, encoding = "utf8") {
      const base33 = bases_default2[encoding];
      if (!base33) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base33.decoder.decode(`${base33.prefix}${string22}`);
    }
    function toString22(array, encoding = "utf8") {
      const base33 = bases_default2[encoding];
      if (!base33) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      return base33.encoder.encode(array).substring(1);
    }
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    var assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    var assert_default = assert;
    var nc = __toESM2(require("node:crypto"), 1);
    var crypto22 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;
    var u8a = (a) => a instanceof Uint8Array;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function utf8ToBytes2(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes2(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    var Hash = class {
      clone() {
        return this._cloneInto();
      }
    };
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function randomBytes(bytesLength = 32) {
      if (crypto22 && typeof crypto22.getRandomValues === "function") {
        return crypto22.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    var HMAC = class extends Hash {
      constructor(hash2, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        assert_default.hash(hash2);
        const key = toBytes(_key);
        this.iHash = hash2.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash2.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf2) {
        assert_default.exists(this);
        this.iHash.update(buf2);
        return this;
      }
      digestInto(out) {
        assert_default.exists(this);
        assert_default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
    hmac.create = (hash2, key) => new HMAC(hash2, key);
    var utils_exports2 = {};
    __export2(utils_exports2, {
      bitGet: () => bitGet,
      bitLen: () => bitLen,
      bitMask: () => bitMask,
      bitSet: () => bitSet,
      bytesToHex: () => bytesToHex,
      bytesToNumberBE: () => bytesToNumberBE,
      bytesToNumberLE: () => bytesToNumberLE,
      concatBytes: () => concatBytes2,
      createHmacDrbg: () => createHmacDrbg,
      ensureBytes: () => ensureBytes,
      equalBytes: () => equalBytes,
      hexToBytes: () => hexToBytes,
      hexToNumber: () => hexToNumber,
      numberToBytesBE: () => numberToBytesBE,
      numberToBytesLE: () => numberToBytesLE,
      numberToHexUnpadded: () => numberToHexUnpadded,
      numberToVarBytesBE: () => numberToVarBytesBE,
      utf8ToBytes: () => utf8ToBytes22,
      validateObject: () => validateObject
    });
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var u8a2 = (a) => a instanceof Uint8Array;
    var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes2) {
      if (!u8a2(bytes2))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes2.length; i++) {
        hex += hexes2[bytes2[i]];
      }
      return hex;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    function bytesToNumberBE(bytes2) {
      return hexToNumber(bytesToHex(bytes2));
    }
    function bytesToNumberLE(bytes2) {
      if (!u8a2(bytes2))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (u8a2(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    function concatBytes2(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a2(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
          return false;
      return true;
    }
    function utf8ToBytes22(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes2(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators3, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators3))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    var _0n2 = BigInt(0);
    var _1n2 = BigInt(1);
    var _2n2 = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n2 ? result : b + result;
    }
    function pow(num, power, modulo) {
      if (modulo <= _0n2 || power < _0n2)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n2)
        return _0n2;
      let res = _1n2;
      while (power > _0n2) {
        if (power & _1n2)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n2;
      }
      return res;
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n2) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number2, modulo) {
      if (number2 === _0n2 || modulo <= _0n2) {
        throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
      }
      let a = mod(number2, modulo);
      let b = modulo;
      let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
      while (a !== _0n2) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n2)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function tonelliShanks(P) {
      const legendreC = (P - _1n2) / _2n2;
      let Q, S, Z;
      for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
        ;
      for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n2) / _4n;
        return function tonelliFast(Fp3, n) {
          const root = Fp3.pow(n, p1div4);
          if (!Fp3.eql(Fp3.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n2) / _2n2;
      return function tonelliSlow(Fp3, n) {
        if (Fp3.pow(n, legendreC) === Fp3.neg(Fp3.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp3.pow(Fp3.mul(Fp3.ONE, Z), Q);
        let x = Fp3.pow(n, Q1div2);
        let b = Fp3.pow(n, Q);
        while (!Fp3.eql(b, Fp3.ONE)) {
          if (Fp3.eql(b, Fp3.ZERO))
            return Fp3.ZERO;
          let m = 1;
          for (let t2 = Fp3.sqr(b); m < r; m++) {
            if (Fp3.eql(t2, Fp3.ONE))
              break;
            t2 = Fp3.sqr(t2);
          }
          const ge = Fp3.pow(g, _1n2 << BigInt(r - m - 1));
          g = Fp3.sqr(ge);
          x = Fp3.mul(x, ge);
          b = Fp3.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n2) / _4n;
        return function sqrt3mod4(Fp3, n) {
          const root = Fp3.pow(n, p1div4);
          if (!Fp3.eql(Fp3.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp3, n) {
          const n2 = Fp3.mul(n, _2n2);
          const v = Fp3.pow(n2, c1);
          const nv = Fp3.mul(n, v);
          const i = Fp3.mul(Fp3.mul(nv, _2n2), v);
          const root = Fp3.mul(nv, Fp3.sub(i, Fp3.ONE));
          if (!Fp3.eql(Fp3.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return validateObject(field, opts);
    }
    function FpPow(f, num, power) {
      if (power < _0n2)
        throw new Error("Expected power > 0");
      if (power === _0n2)
        return f.ONE;
      if (power === _1n2)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n2) {
        if (power & _1n2)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n2;
      }
      return p;
    }
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
      if (ORDER <= _0n2)
        throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: bitMask(BITS),
        ZERO: _0n2,
        ONE: _1n2,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n2 <= num && num < ORDER;
        },
        is0: (num) => num === _0n2,
        isOdd: (num) => (num & _1n2) === _1n2,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
        fromBytes: (bytes2) => {
          if (bytes2.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
          return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
        }
      });
      return Object.freeze(f);
    }
    function hashToPrivateScalar(hash2, groupOrder, isLE2 = false) {
      hash2 = ensureBytes("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE2 ? bytesToNumberLE(hash2) : bytesToNumberBE(hash2);
      return mod(num, groupOrder - _1n2) + _1n2;
    }
    var _0n3 = BigInt(0);
    var _1n3 = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n3) {
            if (n & _1n3)
              p = p.add(d);
            d = d.double();
            n >>= _1n3;
          }
          return p;
        },
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base33 = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base33 = p;
            points.push(base33);
            for (let i = 1; i < windowSize; i++) {
              base33 = base33.add(p);
              points.push(base33);
            }
            p = base33.double();
          }
          return points;
        },
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n3;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    function validateBasic(curve) {
      validateField(curve.Fp);
      validateObject(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...nLength(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    function validatePointOpts(curve) {
      const opts = validateBasic(curve);
      validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp: Fp3, a } = opts;
      if (endo) {
        if (!Fp3.eql(a, Fp3.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports2;
    var DER = {
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice2 = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice2(h(sig.s));
        const r = slice2(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n4 = BigInt(0);
    var _1n4 = BigInt(1);
    var _2n3 = BigInt(2);
    var _3n2 = BigInt(3);
    var _4n2 = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp: Fp3 } = CURVE;
      const toBytes2 = CURVE.toBytes || ((c, point, isCompressed) => {
        const a = point.toAffine();
        return concatBytes2(Uint8Array.from([4]), Fp3.toBytes(a.x), Fp3.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes2) => {
        const tail = bytes2.subarray(1);
        const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp3.sqr(x);
        const x3 = Fp3.mul(x2, x);
        return Fp3.add(Fp3.add(x3, Fp3.mul(x, a)), b);
      }
      if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point2))
          throw new Error("ProjectivePoint expected");
      }
      class Point2 {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp3.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp3.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp3.isValid(pz))
            throw new Error("z required");
        }
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp3.isValid(x) || !Fp3.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point2)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp3.eql(i, Fp3.ZERO);
          if (is0(x) && is0(y))
            return Point2.ZERO;
          return new Point2(x, y, Fp3.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static normalizeZ(points) {
          const toInv = Fp3.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
        }
        static fromHex(hex) {
          const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        static fromPrivateKey(privateKey) {
          return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint)
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp3.isValid(x) || !Fp3.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp3.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp3.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp3.isOdd)
            return !Fp3.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X2, Z1));
          const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
          return U1 && U2;
        }
        negate() {
          return new Point2(this.px, Fp3.neg(this.py), this.pz);
        }
        double() {
          const { a, b } = CURVE;
          const b3 = Fp3.mul(b, _3n2);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
          let t0 = Fp3.mul(X1, X1);
          let t1 = Fp3.mul(Y1, Y1);
          let t2 = Fp3.mul(Z1, Z1);
          let t3 = Fp3.mul(X1, Y1);
          t3 = Fp3.add(t3, t3);
          Z3 = Fp3.mul(X1, Z1);
          Z3 = Fp3.add(Z3, Z3);
          X3 = Fp3.mul(a, Z3);
          Y3 = Fp3.mul(b3, t2);
          Y3 = Fp3.add(X3, Y3);
          X3 = Fp3.sub(t1, Y3);
          Y3 = Fp3.add(t1, Y3);
          Y3 = Fp3.mul(X3, Y3);
          X3 = Fp3.mul(t3, X3);
          Z3 = Fp3.mul(b3, Z3);
          t2 = Fp3.mul(a, t2);
          t3 = Fp3.sub(t0, t2);
          t3 = Fp3.mul(a, t3);
          t3 = Fp3.add(t3, Z3);
          Z3 = Fp3.add(t0, t0);
          t0 = Fp3.add(Z3, t0);
          t0 = Fp3.add(t0, t2);
          t0 = Fp3.mul(t0, t3);
          Y3 = Fp3.add(Y3, t0);
          t2 = Fp3.mul(Y1, Z1);
          t2 = Fp3.add(t2, t2);
          t0 = Fp3.mul(t2, t3);
          X3 = Fp3.sub(X3, t0);
          Z3 = Fp3.mul(t2, t1);
          Z3 = Fp3.add(Z3, Z3);
          Z3 = Fp3.add(Z3, Z3);
          return new Point2(X3, Y3, Z3);
        }
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
          const a = CURVE.a;
          const b3 = Fp3.mul(CURVE.b, _3n2);
          let t0 = Fp3.mul(X1, X2);
          let t1 = Fp3.mul(Y1, Y2);
          let t2 = Fp3.mul(Z1, Z2);
          let t3 = Fp3.add(X1, Y1);
          let t4 = Fp3.add(X2, Y2);
          t3 = Fp3.mul(t3, t4);
          t4 = Fp3.add(t0, t1);
          t3 = Fp3.sub(t3, t4);
          t4 = Fp3.add(X1, Z1);
          let t5 = Fp3.add(X2, Z2);
          t4 = Fp3.mul(t4, t5);
          t5 = Fp3.add(t0, t2);
          t4 = Fp3.sub(t4, t5);
          t5 = Fp3.add(Y1, Z1);
          X3 = Fp3.add(Y2, Z2);
          t5 = Fp3.mul(t5, X3);
          X3 = Fp3.add(t1, t2);
          t5 = Fp3.sub(t5, X3);
          Z3 = Fp3.mul(a, t4);
          X3 = Fp3.mul(b3, t2);
          Z3 = Fp3.add(X3, Z3);
          X3 = Fp3.sub(t1, Z3);
          Z3 = Fp3.add(t1, Z3);
          Y3 = Fp3.mul(X3, Z3);
          t1 = Fp3.add(t0, t0);
          t1 = Fp3.add(t1, t0);
          t2 = Fp3.mul(a, t2);
          t4 = Fp3.mul(b3, t4);
          t1 = Fp3.add(t1, t2);
          t2 = Fp3.sub(t0, t2);
          t2 = Fp3.mul(a, t2);
          t4 = Fp3.add(t4, t2);
          t0 = Fp3.mul(t1, t4);
          Y3 = Fp3.add(Y3, t0);
          t0 = Fp3.mul(t5, t4);
          X3 = Fp3.mul(t3, X3);
          X3 = Fp3.sub(X3, t0);
          t0 = Fp3.mul(t3, t1);
          Z3 = Fp3.mul(t5, Z3);
          Z3 = Fp3.add(Z3, t0);
          return new Point2(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point2.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp3.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
          });
        }
        multiplyUnsafe(n) {
          const I = Point2.ZERO;
          if (n === _0n4)
            return I;
          assertGE(n);
          if (n === _1n4)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n4 || k2 > _0n4) {
            if (k1 & _1n4)
              k1p = k1p.add(d);
            if (k2 & _1n4)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n4;
            k2 >>= _1n4;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point2.normalizeZ([point, fake])[0];
        }
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point2.BASE;
          const mul = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp3.ONE : Fp3.inv(z);
          const ax = Fp3.mul(x, iz);
          const ay = Fp3.mul(y, iz);
          const zz = Fp3.mul(z, iz);
          if (is0)
            return { x: Fp3.ZERO, y: Fp3.ZERO };
          if (!Fp3.eql(zz, Fp3.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n4)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point2, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n4)
            return this;
          if (clearCofactor)
            return clearCofactor(Point2, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes2(Point2, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
      Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point2,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = validateBasic(curve);
      validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp3.BYTES + 1;
      const uncompressedLen = 2 * Fp3.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n4 < num && num < Fp3.ORDER;
      }
      function modN(a) {
        return mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp3.toBytes(a.x);
          const cat = concatBytes2;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp3.toBytes(a.y));
          }
        },
        fromBytes(bytes2) {
          const len = bytes2.length;
          const head = bytes2[0];
          const tail = bytes2.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp3.sqrt(y2);
            const isYOdd = (y & _1n4) === _1n4;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp3.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
            const y = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number2) {
        const HALF = CURVE_ORDER >> _1n4;
        return number2 > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from32, to) => bytesToNumberBE(b.slice(from32, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = ensureBytes("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        static fromDER(hex) {
          const { r, s } = DER.toSig(ensureBytes("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN(ensureBytes("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp3.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point2.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        toDERRawBytes() {
          return hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return DER.hexFromSig({ r: this.r, s: this.s });
        }
        toCompactRawBytes() {
          return hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        randomPrivateKey: () => {
          const rand = CURVE.randomBytes(Fp3.BYTES + 8);
          const num = hashToPrivateScalar(rand, CURVE_ORDER);
          return numberToBytesBE(num, CURVE.nByteLength);
        },
        precompute(windowSize = 8, point = Point2.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point2)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point2.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes2) {
        const num = bytesToNumberBE(bytes2);
        const delta = bytes2.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
        return modN(bits2int(bytes2));
      };
      const ORDER_MASK = bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n4 <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash: hash2, randomBytes: randomBytes3 } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = ensureBytes("msgHash", msgHash);
        if (prehash)
          msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e = ent === true ? randomBytes3(Fp3.BYTES) : ent;
          seedArgs.push(ensureBytes("extraEntropy", e, Fp3.BYTES));
        }
        const seed = concatBytes2(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point2.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n4)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n4)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point2.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = ensureBytes("msgHash", msgHash);
        publicKey = ensureBytes("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point2.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is2 = invN(s);
        const u1 = modN(h * is2);
        const u2 = modN(r * is2);
        const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point2,
        Signature,
        utils
      };
    }
    function getHash(hash2) {
      return {
        hash: hash2,
        hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
        randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create22 = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
      return Object.freeze({ ...create22(defHash), create: create22 });
    }
    function setBigUint64(view, byteOffset, value, isLE2) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE2);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE2 ? 4 : 0;
      const l = isLE2 ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE2);
      view.setUint32(byteOffset + l, wl, isLE2);
    }
    var SHA2 = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        assert_default.exists(this);
        const { view, buffer: buffer2, blockLen } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView2 = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView2, pos);
            continue;
          }
          buffer2.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        assert_default.exists(this);
        assert_default.output(out, this);
        this.finished = true;
        const { buffer: buffer2, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer2[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer2[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE2);
      }
      digest() {
        const { buffer: buffer2, outputLen } = this;
        this.digestInto(buffer2);
        const res = buffer2.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer: buffer2, length: length22, finished, destroyed, pos } = this;
        to.length = length22;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length22 % blockLen)
          to.buffer.set(buffer2);
        return to;
      }
    };
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    var sha25622 = wrapConstructor(() => new SHA256());
    var sha224 = wrapConstructor(() => new SHA224());
    var Fp = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
    var CURVE_A = Fp.create(BigInt("-3"));
    var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
    var p256 = createCurve({
      a: CURVE_A,
      b: CURVE_B,
      Fp,
      n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
      Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
      Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
      h: BigInt(1),
      lowS: false
    }, sha25622);
    var compressPubkey = (pubkeyBytes) => {
      const point = p256.ProjectivePoint.fromHex(pubkeyBytes);
      return point.toRawBytes(true);
    };
    var decompressPubkey = (compressed) => {
      if (compressed.length !== 33) {
        throw new Error("Expected 33 byte compress pubkey");
      }
      const point = p256.ProjectivePoint.fromHex(compressed);
      return point.toRawBytes(false);
    };
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n5 = BigInt(1);
    var _2n4 = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n4) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = pow2(b3, _3n3, P) * b3 % P;
      const b9 = pow2(b6, _3n3, P) * b3 % P;
      const b11 = pow2(b9, _2n4, P) * b2 % P;
      const b22 = pow2(b11, _11n, P) * b11 % P;
      const b44 = pow2(b22, _22n, P) * b22 % P;
      const b88 = pow2(b44, _44n, P) * b44 % P;
      const b176 = pow2(b88, _88n, P) * b88 % P;
      const b220 = pow2(b176, _44n, P) * b44 % P;
      const b223 = pow2(b220, _3n3, P) * b3 % P;
      const t1 = pow2(b223, _23n, P) * b22 % P;
      const t2 = pow2(t1, _6n, P) * b2 % P;
      const root = pow2(t2, _2n4, P);
      if (!Fp2.eql(Fp2.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp2 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    var secp256k1 = createCurve({
      a: BigInt(0),
      b: BigInt(7),
      Fp: Fp2,
      n: secp256k1N,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = mod(k - c1 * a1 - c2 * a2, n);
          let k2 = mod(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha25622);
    var _0n5 = BigInt(0);
    var Point = secp256k1.ProjectivePoint;
    var compressPubkey2 = (pubkeyBytes) => {
      const point = secp256k1.ProjectivePoint.fromHex(pubkeyBytes);
      return point.toRawBytes(true);
    };
    var decompressPubkey2 = (compressed) => {
      if (compressed.length !== 33) {
        throw new Error("Expected 33 byte compress pubkey");
      }
      const point = secp256k1.ProjectivePoint.fromHex(compressed);
      return point.toRawBytes(false);
    };
    var verifyDidSig = async (did, data, sig, opts) => {
      const { jwtAlg, keyBytes } = parseDidKey2(did);
      if (jwtAlg !== P256_JWT_ALG2) {
        throw new Error(`Not a P-256 did:key: ${did}`);
      }
      return verifySig(keyBytes, data, sig, opts);
    };
    var verifySig = async (publicKey, data, sig, opts) => {
      const allowMalleable = opts?.allowMalleableSig ?? false;
      const msgHash = await sha25622(data);
      if (!allowMalleable && !isCompactFormat(sig)) {
        return false;
      }
      return p256.verify(sig, msgHash, publicKey, {
        lowS: !allowMalleable
      });
    };
    var isCompactFormat = (sig) => {
      try {
        const parsed = p256.Signature.fromCompact(sig);
        return equals4(parsed.toCompactRawBytes(), sig);
      } catch {
        return false;
      }
    };
    var p256Plugin = {
      prefix: P256_DID_PREFIX,
      jwtAlg: P256_JWT_ALG2,
      verifySignature: verifyDidSig
    };
    var plugin_default = p256Plugin;
    var verifyDidSig2 = async (did, data, sig, opts) => {
      const { jwtAlg, keyBytes } = parseDidKey2(did);
      if (jwtAlg !== SECP256K1_JWT_ALG2) {
        throw new Error(`Not a secp256k1 did:key: ${did}`);
      }
      return verifySig2(keyBytes, data, sig, opts);
    };
    var verifySig2 = async (publicKey, data, sig, opts) => {
      const allowMalleable = opts?.allowMalleableSig ?? false;
      const msgHash = await sha25622(data);
      if (!allowMalleable && !isCompactFormat2(sig)) {
        return false;
      }
      return secp256k1.verify(sig, msgHash, publicKey, {
        lowS: !allowMalleable
      });
    };
    var isCompactFormat2 = (sig) => {
      try {
        const parsed = secp256k1.Signature.fromCompact(sig);
        return equals4(parsed.toCompactRawBytes(), sig);
      } catch {
        return false;
      }
    };
    var secp256k1Plugin = {
      prefix: SECP256K1_DID_PREFIX,
      jwtAlg: SECP256K1_JWT_ALG2,
      verifySignature: verifyDidSig2
    };
    var plugin_default2 = secp256k1Plugin;
    var plugins = [plugin_default, plugin_default2];
    var plugins_default = plugins;
    var parseMultikey = (multikey) => {
      if (!multikey.startsWith(BASE58_MULTIBASE_PREFIX)) {
        throw new Error(`Incorrect prefix for multikey: ${multikey}`);
      }
      const prefixedBytes = fromString22(multikey.slice(BASE58_MULTIBASE_PREFIX.length), "base58btc");
      const plugin = plugins_default.find((p) => hasPrefix(prefixedBytes, p.prefix));
      if (!plugin) {
        throw new Error("Unsupported key type");
      }
      let keyBytes = prefixedBytes.slice(plugin.prefix.length);
      if (plugin.jwtAlg === P256_JWT_ALG2) {
        keyBytes = decompressPubkey(keyBytes);
      } else if (plugin.jwtAlg === SECP256K1_JWT_ALG2) {
        keyBytes = decompressPubkey2(keyBytes);
      }
      return {
        jwtAlg: plugin.jwtAlg,
        keyBytes
      };
    };
    var formatMultikey = (jwtAlg, keyBytes) => {
      const plugin = plugins_default.find((p) => p.jwtAlg === jwtAlg);
      if (!plugin) {
        throw new Error("Unsupported key type");
      }
      if (jwtAlg === P256_JWT_ALG2) {
        keyBytes = compressPubkey(keyBytes);
      } else if (jwtAlg === SECP256K1_JWT_ALG2) {
        keyBytes = compressPubkey2(keyBytes);
      }
      const prefixedBytes = concat3([plugin.prefix, keyBytes]);
      return BASE58_MULTIBASE_PREFIX + toString22(prefixedBytes, "base58btc");
    };
    var parseDidKey2 = (did) => {
      if (!did.startsWith(DID_KEY_PREFIX)) {
        throw new Error(`Incorrect prefix for did:key: ${did}`);
      }
      return parseMultikey(did.slice(DID_KEY_PREFIX.length));
    };
    var formatDidKey = (jwtAlg, keyBytes) => {
      return DID_KEY_PREFIX + formatMultikey(jwtAlg, keyBytes);
    };
    var hasPrefix = (bytes2, prefix) => {
      return equals4(prefix, bytes2.subarray(0, prefix.byteLength));
    };
    var multibaseToBytes = (mb) => {
      const base33 = mb[0];
      const key = mb.slice(1);
      switch (base33) {
        case "f":
          return fromString22(key, "base16");
        case "F":
          return fromString22(key, "base16upper");
        case "b":
          return fromString22(key, "base32");
        case "B":
          return fromString22(key, "base32upper");
        case "z":
          return fromString22(key, "base58btc");
        case "m":
          return fromString22(key, "base64");
        case "u":
          return fromString22(key, "base64url");
        case "U":
          return fromString22(key, "base64urlpad");
        default:
          throw new Error(`Unsupported multibase: :${mb}`);
      }
    };
    var bytesToMultibase = (mb, encoding) => {
      switch (encoding) {
        case "base16":
          return "f" + toString22(mb, encoding);
        case "base16upper":
          return "F" + toString22(mb, encoding);
        case "base32":
          return "b" + toString22(mb, encoding);
        case "base32upper":
          return "B" + toString22(mb, encoding);
        case "base58btc":
          return "z" + toString22(mb, encoding);
        case "base64":
          return "m" + toString22(mb, encoding);
        case "base64url":
          return "u" + toString22(mb, encoding);
        case "base64urlpad":
          return "U" + toString22(mb, encoding);
        default:
          throw new Error(`Unsupported multibase: :${mb}`);
      }
    };
    var sha25632 = async (input) => {
      const bytes2 = typeof input === "string" ? fromString22(input, "utf8") : input;
      return sha25622(bytes2);
    };
    var randomBytes2 = randomBytes;
    var randomStr = (byteLength, encoding) => {
      const bytes2 = randomBytes2(byteLength);
      return toString22(bytes2, encoding);
    };
    var randomIntFromSeed = async (seed, high, low = 0) => {
      const hash2 = await sha25632(seed);
      const number2 = Buffer.from(hash2).readUintBE(0, 6);
      const range = high - low;
      const normalized = number2 % range;
      return normalized + low;
    };
    var verifySignature2 = (didKey, data, sig, opts) => {
      const parsed = parseDidKey2(didKey);
      const plugin = plugins_default.find((p) => p.jwtAlg === parsed.jwtAlg);
      if (!plugin) {
        throw new Error(`Unsupported signature alg: ${parsed.jwtAlg}`);
      }
      return plugin.verifySignature(didKey, data, sig, opts);
    };
    var verifySignatureUtf8 = async (didKey, data, sig, opts) => {
      const dataBytes = fromString22(data, "utf8");
      const sigBytes = fromString22(sig, "base64url");
      return verifySignature2(didKey, dataBytes, sigBytes, opts);
    };
    var P256Keypair = class {
      constructor(privateKey, exportable) {
        this.privateKey = privateKey;
        this.exportable = exportable;
        this.jwtAlg = P256_JWT_ALG2;
        this.publicKey = p256.getPublicKey(privateKey);
      }
      static async create(opts) {
        const { exportable = false } = opts || {};
        const privKey = p256.utils.randomPrivateKey();
        return new P256Keypair(privKey, exportable);
      }
      static async import(privKey, opts) {
        const { exportable = false } = opts || {};
        const privKeyBytes = typeof privKey === "string" ? fromString22(privKey, "hex") : privKey;
        return new P256Keypair(privKeyBytes, exportable);
      }
      publicKeyBytes() {
        return this.publicKey;
      }
      publicKeyStr(encoding = "base64pad") {
        return toString22(this.publicKey, encoding);
      }
      did() {
        return formatDidKey(this.jwtAlg, this.publicKey);
      }
      async sign(msg) {
        const msgHash = await sha25622(msg);
        const sig = await p256.sign(msgHash, this.privateKey, { lowS: true });
        return sig.toCompactRawBytes();
      }
      async export() {
        if (!this.exportable) {
          throw new Error("Private key is not exportable");
        }
        return this.privateKey;
      }
    };
    var Secp256k1Keypair = class {
      constructor(privateKey, exportable) {
        this.privateKey = privateKey;
        this.exportable = exportable;
        this.jwtAlg = SECP256K1_JWT_ALG2;
        this.publicKey = secp256k1.getPublicKey(privateKey);
      }
      static async create(opts) {
        const { exportable = false } = opts || {};
        const privKey = secp256k1.utils.randomPrivateKey();
        return new Secp256k1Keypair(privKey, exportable);
      }
      static async import(privKey, opts) {
        const { exportable = false } = opts || {};
        const privKeyBytes = typeof privKey === "string" ? fromString22(privKey, "hex") : privKey;
        return new Secp256k1Keypair(privKeyBytes, exportable);
      }
      publicKeyBytes() {
        return this.publicKey;
      }
      publicKeyStr(encoding = "base64pad") {
        return toString22(this.publicKey, encoding);
      }
      did() {
        return formatDidKey(this.jwtAlg, this.publicKey);
      }
      async sign(msg) {
        const msgHash = await sha25622(msg);
        const sig = await secp256k1.sign(msgHash, this.privateKey, { lowS: true });
        return sig.toCompactRawBytes();
      }
      async export() {
        if (!this.exportable) {
          throw new Error("Private key is not exportable");
        }
        return this.privateKey;
      }
    };
  }
});

// src/index.ts
var src_exports2 = {};
__export(src_exports2, {
  Client: () => Client,
  GenesisHashError: () => GenesisHashError,
  ImproperOperationError: () => ImproperOperationError,
  ImproperlyFormattedDidError: () => ImproperlyFormattedDidError,
  InvalidSignatureError: () => InvalidSignatureError,
  LateRecoveryError: () => LateRecoveryError,
  MisorderedOperationError: () => MisorderedOperationError,
  PlcClientError: () => PlcClientError,
  PlcError: () => PlcError,
  UnsupportedKeyError: () => UnsupportedKeyError,
  addSignature: () => addSignature,
  assureValidCreationOp: () => assureValidCreationOp,
  assureValidNextOp: () => assureValidNextOp,
  assureValidSig: () => assureValidSig,
  atprotoOp: () => atprotoOp,
  createAtprotoUpdateOp: () => createAtprotoUpdateOp,
  createOp: () => createOp,
  createUpdateOp: () => createUpdateOp,
  def: () => def,
  deprecatedSignCreate: () => deprecatedSignCreate,
  didDocService: () => didDocService,
  didDocVerificationMethod: () => didDocVerificationMethod,
  didDocument: () => didDocument,
  didForCreateOp: () => didForCreateOp,
  ensureEvermeetPrefix: () => ensureEvermeetPrefix,
  ensureHttpPrefix: () => ensureHttpPrefix,
  exportedOp: () => exportedOp,
  formatAtprotoOp: () => formatAtprotoOp,
  formatDidDoc: () => formatDidDoc,
  getLastOpWithCid: () => getLastOpWithCid,
  indexedOperation: () => indexedOperation,
  normalizeOp: () => normalizeOp,
  opToData: () => opToData,
  signOperation: () => signOperation,
  tombstoneOp: () => tombstoneOp,
  updateAtprotoKeyOp: () => updateAtprotoKeyOp,
  updateHandleOp: () => updateHandleOp,
  updatePdsOp: () => updatePdsOp,
  updateRotationKeysOp: () => updateRotationKeysOp,
  validateOperationLog: () => validateOperationLog
});
module.exports = __toCommonJS(src_exports2);

// src/client.ts
var import_common12 = __toESM(require_dist());

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet2;
  while (size--) {
    str += alphabet2[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code2, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code2, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/platform/node/classes/URLSearchParams.js
var import_url = __toESM(require("url"), 1);
var URLSearchParams_default = import_url.default.URLSearchParams;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/platform/node/index.js
var node_default = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...node_default
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name2) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name2 = path[index++];
    if (name2 === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path.length;
    name2 = !name2 && utils_default.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils_default.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index);
    if (result && utils_default.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_http = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var import_util2 = __toESM(require("util"), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
var import_zlib = __toESM(require("zlib"), 1);

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/env/data.js
var VERSION = "1.6.8";

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform_default.classes.Blob;
  const protocol = parseProtocol(uri);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol === "data") {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
    const match = DATA_URL_PATTERN.exec(uri);
    if (!match) {
      throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer2 = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer2], { type: mime });
    }
    return buffer2;
  }
  throw new AxiosError_default("Unsupported protocol " + protocol, AxiosError_default.ERR_NOT_SUPPORT);
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/adapters/http.js
var import_stream4 = __toESM(require("stream"), 1);

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/AxiosTransformStream.js
var import_stream = __toESM(require("stream"), 1);

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  const threshold = 1e3 / freq;
  let timer = null;
  return function throttled(force, args) {
    const now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, args);
    }
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, args);
      }, threshold - (now - timestamp));
    }
  };
}
var throttle_default = throttle;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/AxiosTransformStream.js
var kInternals = Symbol("internals");
var AxiosTransformStream = class extends import_stream.default.Transform {
  constructor(options) {
    options = utils_default.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils_default.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const self2 = this;
    const internals = this[kInternals] = {
      length: options.length,
      timeWindow: options.timeWindow,
      ticksRate: options.ticksRate,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    const _speedometer = speedometer_default(internals.ticksRate * options.samplesCount, internals.timeWindow);
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
    let bytesNotified = 0;
    internals.updateProgress = throttle_default(function throttledHandler() {
      const totalBytes = internals.length;
      const bytesTransferred = internals.bytesSeen;
      const progressBytes = bytesTransferred - bytesNotified;
      if (!progressBytes || self2.destroyed)
        return;
      const rate = _speedometer(progressBytes);
      bytesNotified = bytesTransferred;
      process.nextTick(() => {
        self2.emit("progress", {
          "loaded": bytesTransferred,
          "total": totalBytes,
          "progress": totalBytes ? bytesTransferred / totalBytes : void 0,
          "bytes": progressBytes,
          "rate": rate ? rate : void 0,
          "estimated": rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
        });
      });
    }, internals.ticksRate);
    const onFinish = () => {
      internals.updateProgress(true);
    };
    this.once("end", onFinish);
    this.once("error", onFinish);
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const self2 = this;
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    function pushChunk(_chunk, _callback) {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      if (internals.isCaptured) {
        internals.updateProgress();
      }
      if (self2.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
  setLength(length2) {
    this[kInternals].length = +length2;
    return this;
  }
};
var AxiosTransformStream_default = AxiosTransformStream;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/adapters/http.js
var import_events = require("events");

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/formDataToStream.js
var import_util = require("util");
var import_stream2 = require("stream");

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
var readBlob_default = readBlob;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = utils_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = new import_util.TextEncoder();
var CRLF = "\r\n";
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;
var FormDataPart = class {
  constructor(name2, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils_default.isString(value);
    let headers = `Content-Disposition: form-data; name="${escapeName(name2)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name2;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils_default.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob_default(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name2) {
    return String(name2).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
};
var formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + utils_default.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils_default.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name2, value]) => {
    const part = new FormDataPart(name2, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils_default.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return import_stream2.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
var formDataToStream_default = formDataToStream;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
var import_stream3 = __toESM(require("stream"), 1);
var ZlibHeaderTransformStream = class extends import_stream3.default.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
};
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
  return utils_default.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
var callbackify_default = callbackify;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/adapters/http.js
var zlibOptions = {
  flush: import_zlib.default.constants.Z_SYNC_FLUSH,
  finishFlush: import_zlib.default.constants.Z_SYNC_FLUSH
};
var brotliOptions = {
  flush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: import_zlib.default.constants.BROTLI_OPERATION_FLUSH
};
var isBrotliSupported = utils_default.isFunction(import_zlib.default.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
  return protocol + ":";
});
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = (0, import_proxy_from_env.getProxyForUrl)(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base642 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base642;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
var isHttpAdapterSupported = typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone)
        return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
var resolveFamily = ({ address, family }) => {
  if (!utils_default.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
var buildAddressEntry = (address, family) => resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http_default = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let { data, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify_default(lookup, (value) => utils_default.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils_default.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new import_events.EventEmitter();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError_default(null, config, req) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, "http://localhost");
    const protocol = parsed.protocol || supportedProtocols[0];
    if (protocol === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils_default.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = import_stream4.default.Readable.from(convertedData);
      }
      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders_default(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError_default(
        "Unsupported protocol " + protocol,
        AxiosError_default.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers = AxiosHeaders_default.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const onDownloadProgress = config.onDownloadProgress;
    const onUploadProgress = config.onUploadProgress;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils_default.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data = formDataToStream_default(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await import_util2.default.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils_default.isBlob(data)) {
      data.size && headers.setContentType(data.type || "application/octet-stream");
      headers.setContentLength(data.size || 0);
      data = import_stream4.default.Readable.from(readBlob_default(data));
    } else if (data && !utils_default.isStream(data)) {
      if (Buffer.isBuffer(data)) {
      } else if (utils_default.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils_default.isString(data)) {
        data = Buffer.from(data, "utf-8");
      } else {
        return reject(new AxiosError_default(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
      headers.setContentLength(data.length, false);
      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError_default(
          "Request body larger than maxBodyLength limit",
          AxiosError_default.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
    if (utils_default.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils_default.isStream(data)) {
        data = import_stream4.default.Readable.from(data, { objectMode: false });
      }
      data = import_stream4.default.pipeline([data, new AxiosTransformStream_default({
        length: contentLength,
        maxRate: utils_default.toFiniteNumber(maxUploadRate)
      })], utils_default.noop);
      onUploadProgress && data.on("progress", (progress) => {
        onUploadProgress(Object.assign(progress, {
          upload: true
        }));
      });
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path;
    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils_default.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? import_https.default : import_http.default;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed)
        return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress) {
        const transformStream = new AxiosTransformStream_default({
          length: utils_default.toFiniteNumber(responseLength),
          maxRate: utils_default.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", (progress) => {
          onDownloadProgress(Object.assign(progress, {
            download: true
          }));
        });
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream_default());
            streams.push(import_zlib.default.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(import_zlib.default.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? import_stream4.default.pipeline(streams, utils_default.noop) : streams[0];
      const offListeners = import_stream4.default.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders_default(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError_default(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError_default.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError_default(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError_default.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed)
            return;
          reject(AxiosError_default.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils_default.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError_default.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject(AxiosError_default.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError_default(
          "error trying to parse `config.timeout` to int",
          AxiosError_default.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone)
          return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitional_default;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }
    if (utils_default.isStream(data)) {
      let ended = false;
      let errored = false;
      data.on("end", () => {
        ended = true;
      });
      data.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError_default("Request stream has been aborted", config, req));
        }
      });
      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value, expires, path, domain, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: http_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length2 } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length2; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        if (!err.stack) {
          err.stack = stack;
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err.stack += "\n" + stack;
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// ../../node_modules/.pnpm/axios@1.6.8/node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/is.js
var typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer2(value)) {
    return "Buffer";
  }
  const objectType2 = getObjectType(value);
  if (objectType2) {
    return objectType2;
  }
  return "Object";
}
function isBuffer2(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/token.js
var Type = class {
  constructor(major, name2, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name2;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
};
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
var Token = class {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/byte-utils.js
var useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
var textDecoder = new TextDecoder();
var textEncoder2 = new TextEncoder();
function isBuffer3(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer3(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
var toString3 = useBuffer ? (bytes, start, end) => {
  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8") : utf8Slice(bytes, start, end);
} : (bytes, start, end) => {
  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
};
var fromString = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder2.encode(string2) : utf8ToBytes(string2);
};
var fromArray = (arr) => {
  return Uint8Array.from(arr);
};
var slice = useBuffer ? (bytes, start, end) => {
  if (isBuffer3(bytes)) {
    return new Uint8Array(bytes.subarray(start, end));
  }
  return bytes.slice(start, end);
} : (bytes, start, end) => {
  return bytes.slice(start, end);
};
var concat = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off = 0;
  for (let b of chunks) {
    if (off + b.length > out.length) {
      b = b.subarray(0, out.length - off);
    }
    out.set(b, off);
    off += b.length;
  }
  return out;
};
var alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare(b1, b2) {
  if (isBuffer3(b1) && isBuffer3(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length2 = string2.length;
  let leadSurrogate = null;
  const bytes = [];
  for (let i = 0; i < length2; ++i) {
    codePoint = string2.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length2) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/bl.js
var defaultChunkSize = 256;
var Bl = class {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes.length < 64 && bytes.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes, 0);
      } else {
        this.chunks.push(bytes);
        this.maxCursor += bytes.length;
      }
    }
    this.cursor += bytes.length;
  }
  toBytes(reset = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat(this.chunks, this.cursor);
    }
    if (reset) {
      this.reset();
    }
    return byts;
  }
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/common.js
var decodeErrPrefix = "CBOR decode error:";
var encodeErrPrefix = "CBOR encode error:";
var uintMinorPrefixBytes = [];
uintMinorPrefixBytes[23] = 1;
uintMinorPrefixBytes[24] = 2;
uintMinorPrefixBytes[25] = 3;
uintMinorPrefixBytes[26] = 5;
uintMinorPrefixBytes[27] = 9;
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/0uint.js
var uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
var neg1b = BigInt(-1);
var pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf2 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token(Type.bytes, buf2, prefix + length2);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes.length);
  buf2.push(bytes);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes.length) + bytes.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString3(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString = encodeBytes;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length2) {
  return new Token(Type.array, length2, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length2) {
  return new Token(Type.map, length2, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/7float.js
var MINOR_FALSE = 20;
var MINOR_TRUE = 21;
var MINOR_NULL = 22;
var MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float = token.value;
  if (float === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float);
      decoded = readFloat16(ui8a, 1);
      if (float === decoded || Number.isNaN(float)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float);
        decoded = readFloat32(ui8a, 1);
        if (float === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float = token.value;
  if (float === false || float === true || float === null || float === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float);
    let decoded = readFloat16(ui8a, 1);
    if (float === decoded || Number.isNaN(float)) {
      return 3;
    }
    encodeFloat32(float);
    decoded = readFloat32(ui8a, 1);
    if (float === decoded) {
      return 5;
    }
  }
  return 9;
};
var buffer = new ArrayBuffer(9);
var dataView = new DataView(buffer, 1);
var ui8a = new Uint8Array(buffer, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
var jump = [];
for (let i = 0; i <= 23; i++) {
  jump[i] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i = 32; i <= 55; i++) {
  jump[i] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i = 64; i <= 87; i++) {
  jump[i] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i = 96; i <= 119; i++) {
  jump[i] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i = 128; i <= 151; i++) {
  jump[i] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i = 160; i <= 183; i++) {
  jump[i] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i = 192; i <= 215; i++) {
  jump[i] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i = 224; i <= 243; i++) {
  jump[i] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
var quick = [];
for (let i = 0; i < 24; i++) {
  quick[i] = new Token(Type.uint, i, 1);
}
for (let i = -1; i >= -24; i--) {
  quick[31 - i] = new Token(Type.negint, i, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/encode.js
var defaultEncodeOptions = {
  float64: false,
  mapSorter,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
var cborEncoders = makeCborEncoders();
var buf = new Bl();
var Ref = class _Ref {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p = this;
    do {
      if (p.obj === obj) {
        return true;
      }
    } while (p = p.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new _Ref(obj, stack);
  }
};
var simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
var typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const e of obj) {
      entries[i++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i = 0;
    for (const key of keys) {
      entries[i++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length2),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length2),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode3(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}

// ../../node_modules/.pnpm/cborg@1.10.2/node_modules/cborg/esm/lib/decode.js
var DONE = Symbol.for("DONE");
var BREAK = Symbol.for("BREAK");

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode4;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode4(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
var decode2 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode2,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/varint.js
var decode3 = (data, offset = 0) => {
  const code2 = varint_default.decode(data, offset);
  return [
    code2,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString2 = (str) => new TextEncoder().encode(str);
var toString4 = (b) => new TextDecoder().decode(b);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/digest.js
var create = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code2, size, digest2, bytes);
};
var decode4 = (multihash) => {
  const bytes = coerce(multihash);
  const [code2, sizeOffset] = decode3(bytes);
  const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size, digest2, bytes);
};
var equals2 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
  }
};
var Digest = class {
  constructor(code2, size, digest2, bytes) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes;
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET2, name2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET2.length; i++) {
    var x = ALPHABET2.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET2.length;
  var LEADER = ALPHABET2.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode9(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode7(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode9,
    decodeUnsafe,
    decode: decode7
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec = class {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name2, prefix, encode: encode9, decode: decode7 }) => new Codec(name2, prefix, encode9, decode7);
var baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode9, decode: decode7 } = base_x_default(alphabet2, name2);
  return from({
    prefix,
    name: name2,
    encode: encode9,
    decode: (text) => coerce(decode7(text))
  });
};
var decode5 = (string2, alphabet2, bitsPerChar, name2) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes[alphabet2[i]] = i;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode5 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer2 = buffer2 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name: name2,
    encode(input) {
      return encode5(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode5(input, alphabet2, bitsPerChar, name2);
    }
  });
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/cid.js
var CID = class _CID {
  constructor(version2, code2, multihash, bytes) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create(code2, digest2);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes } = value;
      return new _CID(version2, code2, multihash, bytes || encodeCID(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode4(multihash);
      return _CID.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version2, code2, digest2.bytes);
        return new _CID(version2, code2, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return _CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code2, digest2) {
    return _CID.create(1, code2, digest2);
  }
  static decode(bytes) {
    const [cid2, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid2;
  }
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid2 = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
    return [
      cid2,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i, length2] = decode3(initialBytes.subarray(offset));
      offset += length2;
      return i;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes] = parseCIDtoBytes(source, base3);
    const cid2 = _CID.decode(bytes);
    cid2._baseCache.set(prefix, source);
    return cid2;
  }
};
var parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base3 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid2 = cache.get(prefix);
  if (cid2 == null) {
    const cid3 = base3.encode(bytes).slice(1);
    cache.set(prefix, cid3);
    return cid3;
  } else {
    return cid2;
  }
};
var toStringV1 = (bytes, cache, base3) => {
  const { prefix } = base3;
  const cid2 = cache.get(prefix);
  if (cid2 == null) {
    const cid3 = base3.encode(bytes);
    cache.set(prefix, cid3);
    return cid3;
  } else {
    return cid2;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version2, code2, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes, 0);
  encodeTo(code2, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// ../../node_modules/.pnpm/@ipld+dag-cbor@7.0.3/node_modules/@ipld/dag-cbor/esm/index.js
var CID_CBOR_TAG = 42;
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid2 = CID.asCID(obj);
  if (!cid2) {
    return null;
  }
  const bytes = new Uint8Array(cid2.bytes.byteLength + 1);
  bytes.set(cid2.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
var decodeOptions = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
var encode6 = (node) => encode3(node, encodeOptions);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString4(buf2),
  decode: (str) => fromString2(str)
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
  p[i] = c;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
  p[c.codePointAt(0)] = i;
  return p;
}, []);
function encode7(data) {
  return data.reduce((p, c) => {
    p += alphabetBytesToChars[c];
    return p;
  }, "");
}
function decode6(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode7,
  decode: decode6
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2.js
var sha2_exports = {};
__export(sha2_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var import_crypto = __toESM(require("crypto"), 1);

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name: name2, code: code2, encode: encode9 }) => new Hasher(name2, code2, encode9);
var Hasher = class {
  constructor(name2, code2, encode9) {
    this.name = name2;
    this.code = code2;
    this.encode = encode9;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/sha2.js
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce(import_crypto.default.createHash("sha256").update(input).digest())
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce(import_crypto.default.createHash("sha512").update(input).digest())
});

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code = 0;
var name = "identity";
var encode8 = coerce;
var digest = (input) => create(code, encode8(input));
var identity2 = {
  code,
  name,
  encode: encode8,
  digest
};

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/codecs/json.js
var textEncoder3 = new TextEncoder();
var textDecoder2 = new TextDecoder();

// ../../node_modules/.pnpm/multiformats@9.9.0/node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_exports,
  ...identity_exports2
};

// ../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode9, decode7) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode9
    },
    decoder: { decode: decode7 }
  };
}
var string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i = 0; i < buf2.length; i++) {
    string2 += String.fromCharCode(buf2[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    buf2[i] = str.charCodeAt(i);
  }
  return buf2;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// ../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/from-string.js
function fromString3(string2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}

// ../../node_modules/.pnpm/uint8arrays@3.0.0/node_modules/uint8arrays/esm/src/to-string.js
function toString5(array, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.encoder.encode(array).substring(1);
}

// src/operations.ts
var import_crypto2 = __toESM(require_dist2());
var import_common11 = __toESM(require_dist());

// ../../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs
var util2;
(function(util3) {
  util3.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util3.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util3.assertNever = assertNever;
  util3.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util3.getValidEnumValues = (obj) => {
    const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util3.objectValues(filtered);
  };
  util3.objectValues = (obj) => {
    return util3.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util3.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util3.joinValues = joinValues;
  util3.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util2 || (util2 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util2.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util2.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util2.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util2.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util2.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util2.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def2) {
    this.spa = this.safeParseAsync;
    this._def = def2;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check5, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check5(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check5, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check5(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def2) {
    const defaultValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def2) {
    const catchValueFunc = typeof def2 === "function" ? def2 : () => def2;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check5 of this._def.checks) {
      if (check5.kind === "min") {
        if (input.data.length < check5.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check5.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "max") {
        if (input.data.length > check5.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check5.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "length") {
        const tooBig = input.data.length > check5.value;
        const tooSmall = input.data.length < check5.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check5.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check5.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check5.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check5.message
            });
          }
          status.dirty();
        }
      } else if (check5.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "regex") {
        check5.regex.lastIndex = 0;
        const testResult = check5.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "trim") {
        input.data = input.data.trim();
      } else if (check5.kind === "includes") {
        if (!input.data.includes(check5.value, check5.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check5.value, position: check5.position },
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check5.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check5.kind === "startsWith") {
        if (!input.data.startsWith(check5.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check5.value },
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "endsWith") {
        if (!input.data.endsWith(check5.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check5.value },
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "datetime") {
        const regex = datetimeRegex(check5);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "ip") {
        if (!isValidIP(input.data, check5.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check5);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check5) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check5]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check5 of this._def.checks) {
      if (check5.kind === "int") {
        if (!util2.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "min") {
        const tooSmall = check5.inclusive ? input.data < check5.value : input.data <= check5.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check5.value,
            type: "number",
            inclusive: check5.inclusive,
            exact: false,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "max") {
        const tooBig = check5.inclusive ? input.data > check5.value : input.data >= check5.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check5.value,
            type: "number",
            inclusive: check5.inclusive,
            exact: false,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check5.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check5.value,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check5.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check5);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check5) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check5]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util2.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check5 of this._def.checks) {
      if (check5.kind === "min") {
        const tooSmall = check5.inclusive ? input.data < check5.value : input.data <= check5.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check5.value,
            inclusive: check5.inclusive,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "max") {
        const tooBig = check5.inclusive ? input.data > check5.value : input.data >= check5.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check5.value,
            inclusive: check5.inclusive,
            message: check5.message
          });
          status.dirty();
        }
      } else if (check5.kind === "multipleOf") {
        if (input.data % check5.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check5.value,
            message: check5.message
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check5);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check5) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check5]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check5 of this._def.checks) {
      if (check5.kind === "min") {
        if (input.data.getTime() < check5.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check5.message,
            inclusive: true,
            exact: false,
            minimum: check5.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check5.kind === "max") {
        if (input.data.getTime() > check5.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check5.message,
            inclusive: true,
            exact: false,
            maximum: check5.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util2.assertNever(check5);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check5) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check5]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def2 = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def2.exactLength !== null) {
      const tooBig = ctx.data.length > def2.exactLength.value;
      const tooSmall = ctx.data.length < def2.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def2.exactLength.value : void 0,
          maximum: tooBig ? def2.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def2.exactLength.message
        });
        status.dirty();
      }
    }
    if (def2.minLength !== null) {
      if (ctx.data.length < def2.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.minLength.message
        });
        status.dirty();
      }
    }
    if (def2.maxLength !== null) {
      if (ctx.data.length > def2.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def2.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def2.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def2.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util2.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util2.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util2.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util2.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util2.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util2.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util2.objectKeys(b);
    const sharedKeys = util2.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def2 = this._def;
    if (def2.minSize !== null) {
      if (ctx.data.size < def2.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def2.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.minSize.message
        });
        status.dirty();
      }
    }
    if (def2.maxSize !== null) {
      if (ctx.data.size > def2.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def2.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def2.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return _ZodEnum.create(values);
  }
  exclude(values) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util2.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base3 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base3))
          return base3;
        const result = effect.transform(base3.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
          if (!isValid(base3))
            return base3;
          return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util2.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;

// src/types.ts
var cid = anyType().refine((obj) => CID.asCID(obj) !== null, {
  message: "Not a CID"
}).transform((obj) => CID.asCID(obj));
var service = objectType({
  type: stringType(),
  endpoint: stringType()
});
var documentData = objectType({
  did: stringType(),
  rotationKeys: arrayType(stringType()),
  verificationMethods: recordType(stringType()),
  alsoKnownAs: arrayType(stringType()),
  services: recordType(service)
});
var unsignedCreateOpV1 = objectType({
  type: literalType("create"),
  signingKey: stringType(),
  recoveryKey: stringType(),
  handle: stringType(),
  service: stringType(),
  prev: nullType()
});
var createOpV1 = unsignedCreateOpV1.extend({ sig: stringType() });
var unsignedOperation = objectType({
  type: literalType("plc_operation"),
  rotationKeys: arrayType(stringType()),
  verificationMethods: recordType(stringType()),
  alsoKnownAs: arrayType(stringType()),
  services: recordType(service),
  prev: stringType().nullable()
}).strict();
var operation = unsignedOperation.extend({ sig: stringType() }).strict();
var unsignedTombstone = objectType({
  type: literalType("plc_tombstone"),
  prev: stringType()
}).strict();
var tombstone = unsignedTombstone.extend({ sig: stringType() }).strict();
var opOrTombstone = unionType([operation, tombstone]);
var compatibleOp = unionType([createOpV1, operation]);
var compatibleOpOrTombstone = unionType([createOpV1, operation, tombstone]);
var indexedOperation = objectType({
  did: stringType(),
  operation: compatibleOpOrTombstone,
  cid,
  nullified: booleanType(),
  createdAt: dateType()
});
var exportedOp = objectType({
  did: stringType(),
  operation: compatibleOpOrTombstone,
  cid: stringType(),
  nullified: booleanType(),
  createdAt: stringType()
});
var didDocVerificationMethod = objectType({
  id: stringType(),
  type: stringType(),
  controller: stringType(),
  publicKeyMultibase: stringType()
});
var didDocService = objectType({
  id: stringType(),
  type: stringType(),
  serviceEndpoint: stringType()
});
var didDocument = objectType({
  "@context": arrayType(stringType()),
  id: stringType(),
  alsoKnownAs: arrayType(stringType()),
  verificationMethod: arrayType(didDocVerificationMethod),
  service: arrayType(didDocService)
});
var def = {
  documentData,
  createOpV1,
  unsignedOperation,
  operation,
  tombstone,
  opOrTombstone,
  compatibleOp,
  compatibleOpOrTombstone,
  indexedOperation,
  exportedOp,
  didDocument
};

// src/error.ts
var PlcError = class extends Error {
  plcError = true;
  constructor(msg) {
    super(msg);
  }
  static is(obj) {
    if (obj && typeof obj === "object" && obj["plcError"] === true) {
      return true;
    }
    return false;
  }
};
var ImproperOperationError = class extends PlcError {
  constructor(reason, op) {
    super(`Improperly formatted operation, ${reason}: ${op}`);
    this.reason = reason;
    this.op = op;
  }
};
var MisorderedOperationError = class extends PlcError {
  constructor() {
    super("Operations not correctly ordered");
  }
};
var LateRecoveryError = class extends PlcError {
  constructor(timeLapsed) {
    super(
      `Recovery operation occurred outside of the allowed 72 hr recovery window. Time lapsed: ${timeLapsed}`
    );
    this.timeLapsed = timeLapsed;
  }
};
var GenesisHashError = class extends PlcError {
  constructor(expected) {
    super(
      `Hash of genesis operation does not match DID identifier: ${expected}`
    );
    this.expected = expected;
  }
};
var InvalidSignatureError = class extends PlcError {
  constructor(op) {
    super(`Invalid signature on op: ${JSON.stringify(op)}`);
    this.op = op;
  }
};
var UnsupportedKeyError = class extends PlcError {
  constructor(key, err) {
    super(`Unsupported key type ${key}: ${err}`);
    this.key = key;
    this.err = err;
  }
};
var ImproperlyFormattedDidError = class extends PlcError {
  constructor(reason) {
    super(`Improperly formatted did: ${reason}`);
    this.reason = reason;
  }
};

// src/operations.ts
var didForCreateOp = async (op) => {
  const hashOfGenesis = await (0, import_crypto2.sha256)(encode6(op));
  const hashB32 = toString5(hashOfGenesis, "base32");
  const truncated = hashB32.slice(0, 24);
  return `did:plc:${truncated}`;
};
var formatAtprotoOp = (opts) => {
  return {
    type: "plc_operation",
    verificationMethods: {
      atproto: opts.signingKey
    },
    rotationKeys: opts.rotationKeys,
    alsoKnownAs: [ensureEvermeetPrefix(opts.handle)],
    services: {
      evermeet_host: {
        type: "EvermeetDataServer",
        endpoint: ensureHttpPrefix(opts.pds)
      }
    },
    prev: opts.prev?.toString() ?? null
  };
};
var atprotoOp = async (opts) => {
  return addSignature(formatAtprotoOp(opts), opts.signer);
};
var createOp = async (opts) => {
  const op = await atprotoOp({ ...opts, prev: null });
  const did = await didForCreateOp(op);
  return { op, did };
};
var createUpdateOp = async (lastOp, signer, fn) => {
  const prev = await (0, import_common11.cidForCbor)(lastOp);
  const { sig, ...normalized } = normalizeOp(lastOp);
  const unsigned = await fn(normalized);
  return addSignature(
    {
      ...unsigned,
      prev: prev.toString()
    },
    signer
  );
};
var createAtprotoUpdateOp = async (lastOp, signer, opts) => {
  return createUpdateOp(lastOp, signer, (normalized) => {
    const updated = { ...normalized };
    if (opts.signingKey) {
      updated.verificationMethods = {
        ...normalized.verificationMethods,
        atproto: opts.signingKey
      };
    }
    if (opts.handle) {
      const formatted = ensureEvermeetPrefix(opts.handle);
      const handleI = normalized.alsoKnownAs.findIndex(
        (h) => h.startsWith("at://")
      );
      if (handleI < 0) {
        updated.alsoKnownAs = [formatted, ...normalized.alsoKnownAs];
      } else {
        updated.alsoKnownAs = [
          ...normalized.alsoKnownAs.slice(0, handleI),
          formatted,
          ...normalized.alsoKnownAs.slice(handleI + 1)
        ];
      }
    }
    if (opts.pds) {
      const formatted = ensureHttpPrefix(opts.pds);
      updated.services = {
        ...normalized.services,
        atproto_pds: {
          type: "AtprotoPersonalDataServer",
          endpoint: formatted
        }
      };
    }
    if (opts.rotationKeys) {
      updated.rotationKeys = opts.rotationKeys;
    }
    return updated;
  });
};
var updateAtprotoKeyOp = async (lastOp, signer, signingKey) => {
  return createAtprotoUpdateOp(lastOp, signer, { signingKey });
};
var updateHandleOp = async (lastOp, signer, handle) => {
  return createAtprotoUpdateOp(lastOp, signer, { handle });
};
var updatePdsOp = async (lastOp, signer, pds) => {
  return createAtprotoUpdateOp(lastOp, signer, { pds });
};
var updateRotationKeysOp = async (lastOp, signer, rotationKeys) => {
  return createAtprotoUpdateOp(lastOp, signer, { rotationKeys });
};
var tombstoneOp = async (prev, key) => {
  return addSignature(
    {
      type: "plc_tombstone",
      prev: prev.toString()
    },
    key
  );
};
var addSignature = async (object, key) => {
  const data = new Uint8Array(encode6(object));
  const sig = await key.sign(data);
  return {
    ...object,
    sig: toString5(sig, "base64url")
  };
};
var signOperation = async (op, signingKey) => {
  return addSignature(op, signingKey);
};
var deprecatedSignCreate = async (op, signingKey) => {
  return addSignature(op, signingKey);
};
var normalizeOp = (op) => {
  if (import_common11.check.is(op, def.operation)) {
    return op;
  }
  return {
    type: "plc_operation",
    verificationMethods: {
      atproto: op.signingKey
    },
    rotationKeys: [op.recoveryKey, op.signingKey],
    alsoKnownAs: [ensureEvermeetPrefix(op.handle)],
    services: {
      atproto_pds: {
        type: "AtprotoPersonalDataServer",
        endpoint: ensureHttpPrefix(op.service)
      }
    },
    prev: op.prev,
    sig: op.sig
  };
};
var assureValidCreationOp = async (did, op) => {
  if (import_common11.check.is(op, def.tombstone)) {
    throw new MisorderedOperationError();
  }
  const normalized = normalizeOp(op);
  await assureValidSig(normalized.rotationKeys, op);
  const expectedDid = await didForCreateOp(op);
  if (expectedDid !== did) {
    throw new GenesisHashError(expectedDid);
  }
  if (op.prev !== null) {
    throw new ImproperOperationError("expected null prev on create", op);
  }
  const { verificationMethods, rotationKeys, alsoKnownAs, services } = normalized;
  return { did, verificationMethods, rotationKeys, alsoKnownAs, services };
};
var assureValidSig = async (allowedDidKeys, op) => {
  const { sig, ...opData } = op;
  if (sig.endsWith("=")) {
    throw new InvalidSignatureError(op);
  }
  const sigBytes = fromString3(sig, "base64url");
  const dataBytes = new Uint8Array(encode6(opData));
  for (const didKey of allowedDidKeys) {
    const isValid2 = await (0, import_crypto2.verifySignature)(didKey, dataBytes, sigBytes);
    if (isValid2) {
      return didKey;
    }
  }
  throw new InvalidSignatureError(op);
};
var ensureHttpPrefix = (str) => {
  if (str.startsWith("http://") || str.startsWith("https://")) {
    return str;
  }
  return `https://${str}`;
};
var ensureEvermeetPrefix = (str) => {
  if (str.startsWith("evermeet://")) {
    return str;
  }
  const stripped = str.replace("http://", "").replace("https://", "");
  return `evermeet://${stripped}`;
};

// src/client.ts
var Client = class {
  constructor(url2) {
    this.url = url2;
  }
  async makeGetReq(url2) {
    try {
      const res = await axios_default.get(url2);
      return res.data;
    } catch (err) {
      if (!axios_default.isAxiosError(err)) {
        throw err;
      }
      throw PlcClientError.fromAxiosError(err);
    }
  }
  async getDocument(did) {
    return await this.makeGetReq(`${this.url}/${encodeURIComponent(did)}`);
  }
  async getDocumentData(did) {
    return await this.makeGetReq(`${this.url}/${encodeURIComponent(did)}/data`);
  }
  async getOperationLog(did) {
    return await this.makeGetReq(`${this.url}/${encodeURIComponent(did)}/log`);
  }
  async getAuditableLog(did) {
    return await this.makeGetReq(
      `${this.url}/${encodeURIComponent(did)}/log/audit`
    );
  }
  postOpUrl(did) {
    return `${this.url}/${encodeURIComponent(did)}`;
  }
  async getLastOp(did) {
    return await this.makeGetReq(
      `${this.url}/${encodeURIComponent(did)}/log/last`
    );
  }
  async sendOperation(did, op) {
    console.log("op:", op);
    console.log("postOpUrl", this.postOpUrl(did));
    try {
      await axios_default.post(this.postOpUrl(did), op);
    } catch (err) {
      if (!axios_default.isAxiosError(err)) {
        throw err;
      }
      throw PlcClientError.fromAxiosError(err);
    }
  }
  async export(after, count) {
    const url2 = new URL(`${this.url}/export`);
    if (after) {
      url2.searchParams.append("after", after);
    }
    if (count !== void 0) {
      url2.searchParams.append("count", count.toString(10));
    }
    const res = await axios_default.get(url2.toString());
    const lines = res.data.split("\n");
    return lines.map((l) => JSON.parse(l));
  }
  async createDid(opts) {
    const op = await atprotoOp({ ...opts, prev: null });
    const did = await didForCreateOp(op);
    await this.sendOperation(did, op);
    return did;
  }
  async ensureLastOp(did) {
    const lastOp = await this.getLastOp(did);
    if (import_common12.check.is(lastOp, def.tombstone)) {
      throw new Error("Cannot apply op to tombstone");
    }
    return lastOp;
  }
  async updateData(did, signer, fn) {
    const lastOp = await this.ensureLastOp(did);
    const op = await createUpdateOp(lastOp, signer, fn);
    await this.sendOperation(did, op);
  }
  async updateAtprotoKey(did, signer, atprotoKey) {
    const lastOp = await this.ensureLastOp(did);
    const op = await updateAtprotoKeyOp(lastOp, signer, atprotoKey);
    await this.sendOperation(did, op);
  }
  async updateHandle(did, signer, handle) {
    const lastOp = await this.ensureLastOp(did);
    const op = await updateHandleOp(lastOp, signer, handle);
    await this.sendOperation(did, op);
  }
  async updatePds(did, signer, endpoint) {
    const lastOp = await this.ensureLastOp(did);
    const op = await updatePdsOp(lastOp, signer, endpoint);
    await this.sendOperation(did, op);
  }
  async updateRotationKeys(did, signer, keys) {
    const lastOp = await this.ensureLastOp(did);
    const op = await updateRotationKeysOp(lastOp, signer, keys);
    await this.sendOperation(did, op);
  }
  async tombstone(did, signer) {
    const lastOp = await this.ensureLastOp(did);
    const prev = await (0, import_common12.cidForCbor)(lastOp);
    const op = await tombstoneOp(prev, signer);
    await this.sendOperation(did, op);
  }
  async health() {
    return await this.makeGetReq(`${this.url}/_health`);
  }
};
var PlcClientError = class _PlcClientError extends Error {
  constructor(status, data, message) {
    super(message);
    this.status = status;
    this.data = data;
    this.message = message;
  }
  static fromAxiosError(err) {
    return new _PlcClientError(
      err.response?.status || 500,
      err.response?.data,
      err.message
    );
  }
};

// src/data.ts
var import_common13 = __toESM(require_dist());
var assureValidNextOp = async (did, ops, proposed) => {
  if (ops.length === 0) {
    await assureValidCreationOp(did, proposed);
    return { nullified: [], prev: null };
  }
  const proposedPrev = proposed.prev ? CID.parse(proposed.prev) : void 0;
  if (!proposedPrev) {
    throw new MisorderedOperationError();
  }
  const indexOfPrev = ops.findIndex((op) => proposedPrev.equals(op.cid));
  if (indexOfPrev < 0) {
    throw new MisorderedOperationError();
  }
  const opsInHistory = ops.slice(0, indexOfPrev + 1);
  const nullified = ops.slice(indexOfPrev + 1);
  const lastOp = opsInHistory.at(-1);
  if (!lastOp) {
    throw new MisorderedOperationError();
  }
  if (import_common13.check.is(lastOp.operation, def.tombstone)) {
    throw new MisorderedOperationError();
  }
  const lastOpNormalized = normalizeOp(lastOp.operation);
  const firstNullified = nullified[0];
  if (!firstNullified) {
    await assureValidSig(lastOpNormalized.rotationKeys, proposed);
    return { nullified: [], prev: proposedPrev };
  }
  const disputedSigner = await assureValidSig(
    lastOpNormalized.rotationKeys,
    firstNullified.operation
  );
  const indexOfSigner = lastOpNormalized.rotationKeys.indexOf(disputedSigner);
  const morePowerfulKeys = lastOpNormalized.rotationKeys.slice(0, indexOfSigner);
  await assureValidSig(morePowerfulKeys, proposed);
  if (nullified.length > 0) {
    const RECOVERY_WINDOW = 72 * import_common13.HOUR;
    const timeLapsed = Date.now() - firstNullified.createdAt.getTime();
    if (timeLapsed > RECOVERY_WINDOW) {
      throw new LateRecoveryError(timeLapsed);
    }
  }
  return {
    nullified: nullified.map((op) => op.cid),
    prev: proposedPrev
  };
};
var validateOperationLog = async (did, ops) => {
  const [first, ...rest] = ops;
  if (!import_common13.check.is(first, def.compatibleOp)) {
    throw new ImproperOperationError("incorrect structure", first);
  }
  for (const op of rest) {
    if (!import_common13.check.is(op, def.opOrTombstone)) {
      throw new ImproperOperationError("incorrect structure", op);
    }
  }
  let doc = await assureValidCreationOp(did, first);
  let prev = await (0, import_common13.cidForCbor)(first);
  for (let i = 0; i < rest.length; i++) {
    const op = rest[i];
    if (!op.prev || !CID.parse(op.prev).equals(prev)) {
      throw new MisorderedOperationError();
    }
    await assureValidSig(doc.rotationKeys, op);
    const data = opToData(did, op);
    if (data === null) {
      if (i === rest.length - 1) {
        return null;
      } else {
        throw new MisorderedOperationError();
      }
    }
    doc = data;
    prev = await (0, import_common13.cidForCbor)(op);
  }
  return doc;
};
var opToData = (did, op) => {
  if (import_common13.check.is(op, def.tombstone)) {
    return null;
  }
  const { verificationMethods, rotationKeys, alsoKnownAs, services } = normalizeOp(op);
  return { did, verificationMethods, rotationKeys, alsoKnownAs, services };
};
var getLastOpWithCid = async (ops) => {
  const op = ops.at(-1);
  if (!op) {
    throw new Error("log is empty");
  }
  const cid2 = await (0, import_common13.cidForCbor)(op);
  return { op, cid: cid2 };
};

// src/document.ts
var crypto2 = __toESM(require_dist2());
var formatDidDoc = (data) => {
  const context = [
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/multikey/v1"
  ];
  const verificationMethods = [];
  for (const [keyid, key] of Object.entries(data.verificationMethods)) {
    const info = formatKeyAndContext(key);
    if (!context.includes(info.context)) {
      context.push(info.context);
    }
    verificationMethods.push({
      id: `${data.did}#${keyid}`,
      type: info.type,
      controller: data.did,
      publicKeyMultibase: info.publicKeyMultibase
    });
  }
  const services = [];
  for (const [serviceId, service2] of Object.entries(data.services)) {
    services.push({
      id: `#${serviceId}`,
      type: service2.type,
      serviceEndpoint: service2.endpoint
    });
  }
  return {
    "@context": context,
    id: data.did,
    alsoKnownAs: data.alsoKnownAs,
    verificationMethod: verificationMethods,
    service: services
  };
};
var formatKeyAndContext = (key) => {
  let keyInfo;
  try {
    keyInfo = crypto2.parseDidKey(key);
  } catch (err) {
    throw new UnsupportedKeyError(key, err);
  }
  const { jwtAlg } = keyInfo;
  if (jwtAlg === crypto2.P256_JWT_ALG) {
    return {
      context: "https://w3id.org/security/suites/ecdsa-2019/v1",
      type: "Multikey",
      publicKeyMultibase: key.replace(/^(did:key:)/, "")
    };
  } else if (jwtAlg === crypto2.SECP256K1_JWT_ALG) {
    return {
      context: "https://w3id.org/security/suites/secp256k1-2019/v1",
      type: "Multikey",
      publicKeyMultibase: key.replace(/^(did:key:)/, "")
    };
  }
  throw new UnsupportedKeyError(key, `Unsupported key type: ${jwtAlg}`);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Client,
  GenesisHashError,
  ImproperOperationError,
  ImproperlyFormattedDidError,
  InvalidSignatureError,
  LateRecoveryError,
  MisorderedOperationError,
  PlcClientError,
  PlcError,
  UnsupportedKeyError,
  addSignature,
  assureValidCreationOp,
  assureValidNextOp,
  assureValidSig,
  atprotoOp,
  createAtprotoUpdateOp,
  createOp,
  createUpdateOp,
  def,
  deprecatedSignCreate,
  didDocService,
  didDocVerificationMethod,
  didDocument,
  didForCreateOp,
  ensureEvermeetPrefix,
  ensureHttpPrefix,
  exportedOp,
  formatAtprotoOp,
  formatDidDoc,
  getLastOpWithCid,
  indexedOperation,
  normalizeOp,
  opToData,
  signOperation,
  tombstoneOp,
  updateAtprotoKeyOp,
  updateHandleOp,
  updatePdsOp,
  updateRotationKeysOp,
  validateOperationLog
});
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

@atproto/crypto/dist/index.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.js.map
